{"mappings":"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","sources":["<anon>","src/worker/silhouetteAsync.worker.js","src/SilhouetteGenerator.js","node_modules/clipper2-js/fesm2015/clipper2-js.mjs","projects/clipper2-js/src/lib/minkowski.ts","projects/clipper2-js/src/lib/offset.ts","projects/clipper2-js/src/lib/rectclip.ts","projects/clipper2-js/src/lib/clipper.ts","projects/clipper2-js/src/lib/engine.ts","projects/clipper2-js/src/lib/core.ts","projects/clipper2-js/src/public-api.ts","projects/clipper2-js/src/clipper2-js.ts","src/utils/compressPoints.js","src/utils/triangleIsInsidePaths.js","src/utils/getSizeSortedTriList.js","src/utils/geometryUtils.js"],"sourcesContent":["(() => {\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire6c98\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire6c98\"] = parcelRequire;\n}\nimportScripts(\"./projectionAsync.worker.d112c604.js\");\nvar $9cb1892ec9b43230$exports = {};\n\nvar $e06gU = parcelRequire(\"e06gU\");\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  15 October 2022                                                 *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2022                                         *\r\n* Purpose   :  Minkowski Sum and Difference                                    *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/ //\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\n// Removed support for USINGZ\n//\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\n//\nclass $0b6dbf71c0c0eea1$export$d7b4df78e16216b1 {\n    static minkowskiInternal(pattern, path, isSum, isClosed) {\n        const delta = isClosed ? 0 : 1;\n        const patLen = pattern.length;\n        const pathLen = path.length;\n        const tmp = [];\n        for (const pathPt of path){\n            const path2 = [];\n            if (isSum) for (const basePt of pattern)path2.push({\n                x: pathPt.x + basePt.x,\n                y: pathPt.y + basePt.y\n            });\n            else for (const basePt of pattern)path2.push({\n                x: pathPt.x - basePt.x,\n                y: pathPt.y - basePt.y\n            });\n            tmp.push(path2);\n        }\n        const result = [];\n        let g = isClosed ? pathLen - 1 : 0;\n        let h = patLen - 1;\n        for(let i = delta; i < pathLen; i++){\n            for(let j = 0; j < patLen; j++){\n                const quad = [\n                    tmp[g][h],\n                    tmp[i][h],\n                    tmp[i][j],\n                    tmp[g][j]\n                ];\n                if (!$0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.isPositive(quad)) result.push($0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.reversePath(quad));\n                else result.push(quad);\n                h = j;\n            }\n            g = i;\n        }\n        return result;\n    }\n    static sum(pattern, path, isClosed) {\n        return $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.Union(this.minkowskiInternal(pattern, path, true, isClosed), undefined, $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.NonZero);\n    }\n    static diff(pattern, path, isClosed) {\n        return $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.Union(this.minkowskiInternal(pattern, path, false, isClosed), undefined, $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.NonZero);\n    }\n}\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  7 August 2023                                                   *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  Path Offset (Inflate/Shrink)                                    *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/ //\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\n// Removed support for USINGZ\n//\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\n//\nvar $0b6dbf71c0c0eea1$export$738d8b3921c27063;\n(function(JoinType) {\n    JoinType[JoinType[\"Square\"] = 0] = \"Square\";\n    JoinType[JoinType[\"Round\"] = 1] = \"Round\";\n    JoinType[JoinType[\"Miter\"] = 2] = \"Miter\";\n})($0b6dbf71c0c0eea1$export$738d8b3921c27063 || ($0b6dbf71c0c0eea1$export$738d8b3921c27063 = {}));\nvar $0b6dbf71c0c0eea1$export$38f58f6965412d86;\n(function(EndType) {\n    EndType[EndType[\"Polygon\"] = 0] = \"Polygon\";\n    EndType[EndType[\"Joined\"] = 1] = \"Joined\";\n    EndType[EndType[\"Butt\"] = 2] = \"Butt\";\n    EndType[EndType[\"Square\"] = 3] = \"Square\";\n    EndType[EndType[\"Round\"] = 4] = \"Round\";\n})($0b6dbf71c0c0eea1$export$38f58f6965412d86 || ($0b6dbf71c0c0eea1$export$38f58f6965412d86 = {}));\nclass $0b6dbf71c0c0eea1$var$Group {\n    constructor(paths, joinType, endType = $0b6dbf71c0c0eea1$export$38f58f6965412d86.Polygon){\n        this.inPaths = [\n            ...paths\n        ]; // creates a shallow copy of paths\n        this.joinType = joinType;\n        this.endType = endType;\n        this.outPath = [];\n        this.outPaths = [];\n        this.pathsReversed = false;\n    }\n}\nclass $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad {\n    constructor(xOrPt, yOrScale){\n        if (typeof xOrPt === \"number\" && typeof yOrScale === \"number\") {\n            this.x = xOrPt;\n            this.y = yOrScale;\n        } else if (xOrPt instanceof $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad) {\n            if (yOrScale !== undefined) {\n                this.x = xOrPt.x * yOrScale;\n                this.y = xOrPt.y * yOrScale;\n            } else {\n                this.x = xOrPt.x;\n                this.y = xOrPt.y;\n            }\n        } else {\n            this.x = xOrPt.x * (yOrScale || 1);\n            this.y = xOrPt.y * (yOrScale || 1);\n        }\n    }\n    toString(precision = 2) {\n        return `${this.x.toFixed(precision)},${this.y.toFixed(precision)}`;\n    }\n    static equals(lhs, rhs) {\n        return $0b6dbf71c0c0eea1$export$9bad362b29d84293.isAlmostZero(lhs.x - rhs.x) && $0b6dbf71c0c0eea1$export$9bad362b29d84293.isAlmostZero(lhs.y - rhs.y);\n    }\n    static notEquals(lhs, rhs) {\n        return !$0b6dbf71c0c0eea1$export$9bad362b29d84293.isAlmostZero(lhs.x - rhs.x) || !$0b6dbf71c0c0eea1$export$9bad362b29d84293.isAlmostZero(lhs.y - rhs.y);\n    }\n    equals(obj) {\n        if (obj instanceof $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad) return $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad.equals(this, obj);\n        return false;\n    }\n    negate() {\n        this.x = -this.x;\n        this.y = -this.y;\n    }\n}\nclass $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24 {\n    constructor(miterLimit = 2.0, arcTolerance = 0.0, preserveCollinear = false, reverseSolution = false){\n        this._groupList = [];\n        this._normals = [];\n        this._solution = [];\n        this.MiterLimit = miterLimit;\n        this.ArcTolerance = arcTolerance;\n        this.MergeGroups = true;\n        this.PreserveCollinear = preserveCollinear;\n        this.ReverseSolution = reverseSolution;\n    }\n    clear() {\n        this._groupList = [];\n    }\n    addPath(path, joinType, endType) {\n        if (path.length === 0) return;\n        const pp = [\n            path\n        ];\n        this.addPaths(pp, joinType, endType);\n    }\n    addPaths(paths, joinType, endType) {\n        if (paths.length === 0) return;\n        this._groupList.push(new $0b6dbf71c0c0eea1$var$Group(paths, joinType, endType));\n    }\n    executeInternal(delta) {\n        this._solution = [];\n        if (this._groupList.length === 0) return;\n        if (Math.abs(delta) < 0.5) {\n            for (const group of this._groupList)for (const path of group.inPaths)this._solution.push(path);\n        } else {\n            this._delta = delta;\n            this._mitLimSqr = this.MiterLimit <= 1 ? 2.0 : 2.0 / this.sqr(this.MiterLimit);\n            for (const group of this._groupList)this.doGroupOffset(group);\n        }\n    }\n    sqr(value) {\n        return value * value;\n    }\n    execute(delta, solution) {\n        solution.length = 0;\n        this.executeInternal(delta);\n        if (this._groupList.length === 0) return;\n        // clean up self-intersections ...\n        const c = new $0b6dbf71c0c0eea1$export$389255fe4ace408b();\n        c.preserveCollinear = this.PreserveCollinear;\n        // the solution should retain the orientation of the input\n        c.reverseSolution = this.ReverseSolution !== this._groupList[0].pathsReversed;\n        c.addSubjectPaths(this._solution);\n        if (this._groupList[0].pathsReversed) c.execute($0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Union, $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Negative, solution);\n        else c.execute($0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Union, $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Positive, solution);\n    }\n    executePolytree(delta, polytree) {\n        polytree.clear();\n        this.executeInternal(delta);\n        if (this._groupList.length === 0) return;\n        // clean up self-intersections ...\n        const c = new $0b6dbf71c0c0eea1$export$389255fe4ace408b();\n        c.preserveCollinear = this.PreserveCollinear;\n        // the solution should retain the orientation of the input\n        c.reverseSolution = this.ReverseSolution !== this._groupList[0].pathsReversed;\n        c.addSubjectPaths(this._solution);\n        if (this._groupList[0].pathsReversed) c.executePolyTree($0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Union, $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Negative, polytree);\n        else c.executePolyTree($0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Union, $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Positive, polytree);\n    }\n    static getUnitNormal(pt1, pt2) {\n        let dx = pt2.x - pt1.x;\n        let dy = pt2.y - pt1.y;\n        if (dx === 0 && dy === 0) return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(0, 0);\n        const f = 1.0 / Math.sqrt(dx * dx + dy * dy);\n        dx *= f;\n        dy *= f;\n        return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(dy, -dx);\n    }\n    executeCallback(deltaCallback, solution) {\n        this.DeltaCallback = deltaCallback;\n        this.execute(1.0, solution);\n    }\n    static getBoundsAndLowestPolyIdx(paths) {\n        const rec = new $0b6dbf71c0c0eea1$export$e7ab2e89a2fb5a6f(false); // ie invalid rect\n        let lpX = Number.MIN_SAFE_INTEGER;\n        let index = -1;\n        for(let i = 0; i < paths.length; i++)for (const pt of paths[i]){\n            if (pt.y >= rec.bottom) {\n                if (pt.y > rec.bottom || pt.x < lpX) {\n                    index = i;\n                    lpX = pt.x;\n                    rec.bottom = pt.y;\n                }\n            } else if (pt.y < rec.top) rec.top = pt.y;\n            if (pt.x > rec.right) rec.right = pt.x;\n            else if (pt.x < rec.left) rec.left = pt.x;\n        }\n        return {\n            index: index,\n            rec: rec\n        };\n    }\n    static translatePoint(pt, dx, dy) {\n        return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(pt.x + dx, pt.y + dy);\n    }\n    static reflectPoint(pt, pivot) {\n        return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(pivot.x + (pivot.x - pt.x), pivot.y + (pivot.y - pt.y));\n    }\n    static almostZero(value, epsilon = 0.001) {\n        return Math.abs(value) < epsilon;\n    }\n    static hypotenuse(x, y) {\n        return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n    }\n    static normalizeVector(vec) {\n        const h = this.hypotenuse(vec.x, vec.y);\n        if (this.almostZero(h)) return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(0, 0);\n        const inverseHypot = 1 / h;\n        return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(vec.x * inverseHypot, vec.y * inverseHypot);\n    }\n    static getAvgUnitVector(vec1, vec2) {\n        return this.normalizeVector(new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(vec1.x + vec2.x, vec1.y + vec2.y));\n    }\n    static intersectPoint(pt1a, pt1b, pt2a, pt2b) {\n        if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.isAlmostZero(pt1a.x - pt1b.x)) {\n            if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.isAlmostZero(pt2a.x - pt2b.x)) return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(0, 0);\n            const m2 = (pt2b.y - pt2a.y) / (pt2b.x - pt2a.x);\n            const b2 = pt2a.y - m2 * pt2a.x;\n            return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(pt1a.x, m2 * pt1a.x + b2);\n        }\n        if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.isAlmostZero(pt2a.x - pt2b.x)) {\n            const m1 = (pt1b.y - pt1a.y) / (pt1b.x - pt1a.x);\n            const b1 = pt1a.y - m1 * pt1a.x;\n            return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(pt2a.x, m1 * pt2a.x + b1);\n        } else {\n            const m1 = (pt1b.y - pt1a.y) / (pt1b.x - pt1a.x);\n            const b1 = pt1a.y - m1 * pt1a.x;\n            const m2 = (pt2b.y - pt2a.y) / (pt2b.x - pt2a.x);\n            const b2 = pt2a.y - m2 * pt2a.x;\n            if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.isAlmostZero(m1 - m2)) return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(0, 0);\n            const x = (b2 - b1) / (m1 - m2);\n            return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(x, m1 * x + b1);\n        }\n    }\n    getPerpendic(pt, norm) {\n        return new $0b6dbf71c0c0eea1$export$d379afd9763b528f(pt.x + norm.x * this._groupDelta, pt.y + norm.y * this._groupDelta);\n    }\n    getPerpendicD(pt, norm) {\n        return new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(pt.x + norm.x * this._groupDelta, pt.y + norm.y * this._groupDelta);\n    }\n    doSquare(group, path, j, k) {\n        let vec;\n        if (j === k) vec = new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(this._normals[j].y, -this._normals[j].x);\n        else vec = $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.getAvgUnitVector(new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(-this._normals[k].y, this._normals[k].x), new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(this._normals[j].y, -this._normals[j].x));\n        const absDelta = Math.abs(this._groupDelta);\n        // now offset the original vertex delta units along unit vector\n        let ptQ = new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(path[j].x, path[j].y);\n        ptQ = $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.translatePoint(ptQ, absDelta * vec.x, absDelta * vec.y);\n        // get perpendicular vertices\n        const pt1 = $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.translatePoint(ptQ, this._groupDelta * vec.y, this._groupDelta * -vec.x);\n        const pt2 = $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.translatePoint(ptQ, this._groupDelta * -vec.y, this._groupDelta * vec.x);\n        // get 2 vertices along one edge offset\n        const pt3 = this.getPerpendicD(path[k], this._normals[k]);\n        if (j === k) {\n            const pt4 = new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(pt3.x + vec.x * this._groupDelta, pt3.y + vec.y * this._groupDelta);\n            const pt = $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.intersectPoint(pt1, pt2, pt3, pt4);\n            //get the second intersect point through reflection\n            group.outPath.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f($0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.reflectPoint(pt, ptQ).x, $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.reflectPoint(pt, ptQ).y));\n            group.outPath.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(pt.x, pt.y));\n        } else {\n            const pt4 = this.getPerpendicD(path[j], this._normals[k]);\n            const pt = $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.intersectPoint(pt1, pt2, pt3, pt4);\n            group.outPath.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(pt.x, pt.y));\n            //get the second intersect point through reflection\n            group.outPath.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f($0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.reflectPoint(pt, ptQ).x, $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.reflectPoint(pt, ptQ).y));\n        }\n    }\n    doMiter(group, path, j, k, cosA) {\n        const q = this._groupDelta / (cosA + 1);\n        group.outPath.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(path[j].x + (this._normals[k].x + this._normals[j].x) * q, path[j].y + (this._normals[k].y + this._normals[j].y) * q));\n    }\n    doRound(group, path, j, k, angle) {\n        if (typeof this.DeltaCallback !== \"undefined\") {\n            const absDelta = Math.abs(this._groupDelta);\n            const arcTol = this.ArcTolerance > 0.01 ? this.ArcTolerance : Math.log10(2 + absDelta) * $0b6dbf71c0c0eea1$export$9bad362b29d84293.defaultArcTolerance;\n            const stepsPer360 = Math.PI / Math.acos(1 - arcTol / absDelta);\n            this._stepSin = Math.sin(2 * Math.PI / stepsPer360);\n            this._stepCos = Math.cos(2 * Math.PI / stepsPer360);\n            if (this._groupDelta < 0.0) this._stepSin = -this._stepSin;\n            this._stepsPerRad = stepsPer360 / (2 * Math.PI);\n        }\n        const pt = path[j];\n        let offsetVec = new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(this._normals[k].x * this._groupDelta, this._normals[k].y * this._groupDelta);\n        if (j === k) offsetVec.negate();\n        group.outPath.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(pt.x + offsetVec.x, pt.y + offsetVec.y));\n        if (angle > -Math.PI + 0.01) {\n            const steps = Math.ceil(this._stepsPerRad * Math.abs(angle));\n            for(let i = 1; i < steps; i++){\n                offsetVec = new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(offsetVec.x * this._stepCos - this._stepSin * offsetVec.y, offsetVec.x * this._stepSin + offsetVec.y * this._stepCos);\n                group.outPath.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(pt.x + offsetVec.x, pt.y + offsetVec.y));\n            }\n        }\n        group.outPath.push(this.getPerpendic(pt, this._normals[j]));\n    }\n    buildNormals(path) {\n        const cnt = path.length;\n        this._normals = [];\n        this._normals.length = cnt;\n        for(let i = 0; i < cnt - 1; i++)this._normals.push($0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.getUnitNormal(path[i], path[i + 1]));\n        this._normals.push($0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.getUnitNormal(path[cnt - 1], path[0]));\n    }\n    crossProduct(vec1, vec2) {\n        return vec1.y * vec2.x - vec2.y * vec1.x;\n    }\n    dotProduct(vec1, vec2) {\n        return vec1.x * vec2.x + vec1.y * vec2.y;\n    }\n    offsetPoint(group, path, j, k) {\n        const sinA = this.crossProduct(this._normals[j], this._normals[k]);\n        let cosA = this.dotProduct(this._normals[j], this._normals[k]);\n        if (sinA > 1.0) cosA = 1.0;\n        else if (sinA < -1) cosA = -1;\n        if (typeof this.DeltaCallback !== \"undefined\") {\n            this._groupDelta = this.DeltaCallback(path, this._normals, j, k);\n            if (group.pathsReversed) this._groupDelta = -this._groupDelta;\n        }\n        if (Math.abs(this._groupDelta) < $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.Tolerance) {\n            group.outPath.push(path[j]);\n            return;\n        }\n        if (cosA > 0.999) this.doMiter(group, path, j, k, cosA);\n        else if (cosA > -0.99 && sinA * this._groupDelta < 0) {\n            group.outPath.push(this.getPerpendic(path[j], this._normals[k]));\n            group.outPath.push(path[j]);\n            group.outPath.push(this.getPerpendic(path[j], this._normals[j]));\n        } else if (this._joinType === $0b6dbf71c0c0eea1$export$738d8b3921c27063.Miter) {\n            if (cosA > this._mitLimSqr - 1) this.doMiter(group, path, j, k, cosA);\n            else this.doSquare(group, path, j, k);\n        } else if (cosA > 0.99 || this._joinType === $0b6dbf71c0c0eea1$export$738d8b3921c27063.Square) this.doSquare(group, path, j, k);\n        else this.doRound(group, path, j, k, Math.atan2(sinA, cosA));\n        k = j;\n    }\n    offsetPolygon(group, path) {\n        const area = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.area(path);\n        if (area < 0 !== this._groupDelta < 0) {\n            const rect = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.getBounds(path);\n            if (Math.abs(this._groupDelta) * 2 > rect.width) return;\n        }\n        group.outPath = [];\n        const cnt = path.length;\n        const prev = cnt - 1;\n        for(let i = 0; i < cnt; i++)this.offsetPoint(group, path, i, prev);\n        group.outPaths.push(group.outPath);\n    }\n    offsetOpenJoined(group, path) {\n        this.offsetPolygon(group, path);\n        path = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.reversePath(path);\n        this.buildNormals(path);\n        this.offsetPolygon(group, path);\n    }\n    offsetOpenPath(group, path) {\n        group.outPath = [];\n        const highI = path.length - 1;\n        if (typeof this.DeltaCallback !== \"undefined\") this._groupDelta = this.DeltaCallback(path, this._normals, 0, 0);\n        if (Math.abs(this._groupDelta) < $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.Tolerance) group.outPath.push(path[0]);\n        else switch(this._endType){\n            case $0b6dbf71c0c0eea1$export$38f58f6965412d86.Butt:\n                group.outPath.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(path[0].x - this._normals[0].x * this._groupDelta, path[0].y - this._normals[0].y * this._groupDelta));\n                group.outPath.push(this.getPerpendic(path[0], this._normals[0]));\n                break;\n            case $0b6dbf71c0c0eea1$export$38f58f6965412d86.Round:\n                this.doRound(group, path, 0, 0, Math.PI);\n                break;\n            default:\n                this.doSquare(group, path, 0, 0);\n                break;\n        }\n        for(let i = 1, k = 0; i < highI; i++)this.offsetPoint(group, path, i, k);\n        for(let i = highI; i > 0; i--)this._normals[i] = new $0b6dbf71c0c0eea1$export$f7b22d527d83f4ad(-this._normals[i - 1].x, -this._normals[i - 1].y);\n        this._normals[0] = this._normals[highI];\n        if (typeof this.DeltaCallback !== \"undefined\") this._groupDelta = this.DeltaCallback(path, this._normals, highI, highI);\n        if (Math.abs(this._groupDelta) < $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.Tolerance) group.outPath.push(path[highI]);\n        else switch(this._endType){\n            case $0b6dbf71c0c0eea1$export$38f58f6965412d86.Butt:\n                group.outPath.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(path[highI].x - this._normals[highI].x * this._groupDelta, path[highI].y - this._normals[highI].y * this._groupDelta));\n                group.outPath.push(this.getPerpendic(path[highI], this._normals[highI]));\n                break;\n            case $0b6dbf71c0c0eea1$export$38f58f6965412d86.Round:\n                this.doRound(group, path, highI, highI, Math.PI);\n                break;\n            default:\n                this.doSquare(group, path, highI, highI);\n                break;\n        }\n        for(let i = highI, k = 0; i > 0; i--)this.offsetPoint(group, path, i, k);\n        group.outPaths.push(group.outPath);\n    }\n    doGroupOffset(group) {\n        if (group.endType == $0b6dbf71c0c0eea1$export$38f58f6965412d86.Polygon) {\n            const { index: index } = $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.getBoundsAndLowestPolyIdx(group.inPaths);\n            if (index < 0) return;\n            const area = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.area(group.inPaths[index]);\n            group.pathsReversed = area < 0;\n            if (group.pathsReversed) this._groupDelta = -this._delta;\n            else this._groupDelta = this._delta;\n        } else {\n            group.pathsReversed = false;\n            this._groupDelta = Math.abs(this._delta) * 0.5;\n        }\n        const absDelta = Math.abs(this._groupDelta);\n        this._joinType = group.joinType;\n        this._endType = group.endType;\n        if (!this.DeltaCallback && (group.joinType == $0b6dbf71c0c0eea1$export$738d8b3921c27063.Round || group.endType == $0b6dbf71c0c0eea1$export$38f58f6965412d86.Round)) {\n            const arcTol = this.ArcTolerance > 0.01 ? this.ArcTolerance : Math.log10(2 + absDelta) * $0b6dbf71c0c0eea1$export$9bad362b29d84293.defaultArcTolerance;\n            const stepsPer360 = Math.PI / Math.acos(1 - arcTol / absDelta);\n            this._stepSin = Math.sin(2 * Math.PI / stepsPer360);\n            this._stepCos = Math.cos(2 * Math.PI / stepsPer360);\n            if (this._groupDelta < 0.0) this._stepSin = -this._stepSin;\n            this._stepsPerRad = stepsPer360 / (2 * Math.PI);\n        }\n        const isJoined = group.endType == $0b6dbf71c0c0eea1$export$38f58f6965412d86.Joined || group.endType == $0b6dbf71c0c0eea1$export$38f58f6965412d86.Polygon;\n        for (const p of group.inPaths){\n            const path = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.stripDuplicates(p, isJoined);\n            const cnt = path.length;\n            if (cnt === 0 || cnt < 3 && this._endType == $0b6dbf71c0c0eea1$export$38f58f6965412d86.Polygon) continue;\n            if (cnt == 1) {\n                group.outPath = [];\n                if (group.endType == $0b6dbf71c0c0eea1$export$38f58f6965412d86.Round) {\n                    const r = absDelta;\n                    group.outPath = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.ellipse(path[0], r, r);\n                } else {\n                    const d = Math.ceil(this._groupDelta);\n                    const r = new $0b6dbf71c0c0eea1$export$e7ab2e89a2fb5a6f(path[0].x - d, path[0].y - d, path[0].x - d, path[0].y - d);\n                    group.outPath = r.asPath();\n                }\n                group.outPaths.push(group.outPath);\n            } else {\n                if (cnt == 2 && group.endType == $0b6dbf71c0c0eea1$export$38f58f6965412d86.Joined) {\n                    if (group.joinType == $0b6dbf71c0c0eea1$export$738d8b3921c27063.Round) this._endType = $0b6dbf71c0c0eea1$export$38f58f6965412d86.Round;\n                    else this._endType = $0b6dbf71c0c0eea1$export$38f58f6965412d86.Square;\n                }\n                this.buildNormals(path);\n                if (this._endType == $0b6dbf71c0c0eea1$export$38f58f6965412d86.Polygon) this.offsetPolygon(group, path);\n                else if (this._endType == $0b6dbf71c0c0eea1$export$38f58f6965412d86.Joined) this.offsetOpenJoined(group, path);\n                else this.offsetOpenPath(group, path);\n            }\n        }\n        this._solution.push(...group.outPaths);\n        group.outPaths = [];\n    }\n}\n$0b6dbf71c0c0eea1$export$8cbc02e4273c0b24.Tolerance = 1.0E-12;\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  6 August 2023                                                   *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  FAST rectangular clipping                                       *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/ //\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\n// Removed support for USINGZ\n//\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\n//\nclass $0b6dbf71c0c0eea1$export$a6dea2fac1e0b407 {\n    constructor(pt){\n        this.pt = pt;\n        this.ownerIdx = 0;\n    }\n}\nvar $0b6dbf71c0c0eea1$var$Location;\n(function(Location) {\n    Location[Location[\"left\"] = 0] = \"left\";\n    Location[Location[\"top\"] = 1] = \"top\";\n    Location[Location[\"right\"] = 2] = \"right\";\n    Location[Location[\"bottom\"] = 3] = \"bottom\";\n    Location[Location[\"inside\"] = 4] = \"inside\";\n})($0b6dbf71c0c0eea1$var$Location || ($0b6dbf71c0c0eea1$var$Location = {}));\nclass $0b6dbf71c0c0eea1$export$ada4127871f05d7b {\n    constructor(rect){\n        this.currIdx = -1;\n        this.rect = rect;\n        this.mp = rect.midPoint();\n        this.rectPath = rect.asPath();\n        this.results = [];\n        this.edges = Array(8).fill(undefined).map(()=>[]);\n    }\n    add(pt, startingNewPath = false) {\n        let currIdx = this.results.length;\n        let result;\n        if (currIdx === 0 || startingNewPath) {\n            result = new $0b6dbf71c0c0eea1$export$a6dea2fac1e0b407(pt);\n            this.results.push(result);\n            result.ownerIdx = currIdx;\n            result.prev = result;\n            result.next = result;\n        } else {\n            currIdx--;\n            const prevOp = this.results[currIdx];\n            if (prevOp.pt === pt) return prevOp;\n            result = new $0b6dbf71c0c0eea1$export$a6dea2fac1e0b407(pt);\n            result.ownerIdx = currIdx;\n            result.next = prevOp.next;\n            prevOp.next.prev = result;\n            prevOp.next = result;\n            result.prev = prevOp;\n            this.results[currIdx] = result;\n        }\n        return result;\n    }\n    static path1ContainsPath2(path1, path2) {\n        let ioCount = 0;\n        for (const pt of path2){\n            const pip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.pointInPolygon(pt, path1);\n            switch(pip){\n                case $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsInside:\n                    ioCount--;\n                    break;\n                case $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOutside:\n                    ioCount++;\n                    break;\n            }\n            if (Math.abs(ioCount) > 1) break;\n        }\n        return ioCount <= 0;\n    }\n    static isClockwise(prev, curr, prevPt, currPt, rectMidPoint) {\n        if (this.areOpposites(prev, curr)) return $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(prevPt, rectMidPoint, currPt) < 0;\n        else return this.headingClockwise(prev, curr);\n    }\n    static areOpposites(prev, curr) {\n        return Math.abs(prev - curr) === 2;\n    }\n    static headingClockwise(prev, curr) {\n        return (prev + 1) % 4 === curr;\n    }\n    static getAdjacentLocation(loc, isClockwise) {\n        const delta = isClockwise ? 1 : 3;\n        return (loc + delta) % 4;\n    }\n    static unlinkOp(op) {\n        if (op.next === op) return undefined;\n        op.prev.next = op.next;\n        op.next.prev = op.prev;\n        return op.next;\n    }\n    static unlinkOpBack(op) {\n        if (op.next === op) return undefined;\n        op.prev.next = op.next;\n        op.next.prev = op.prev;\n        return op.prev;\n    }\n    static getEdgesForPt(pt, rec) {\n        let result = 0;\n        if (pt.x === rec.left) result = 1;\n        else if (pt.x === rec.right) result = 4;\n        if (pt.y === rec.top) result += 2;\n        else if (pt.y === rec.bottom) result += 8;\n        return result;\n    }\n    static isHeadingClockwise(pt1, pt2, edgeIdx) {\n        switch(edgeIdx){\n            case 0:\n                return pt2.y < pt1.y;\n            case 1:\n                return pt2.x > pt1.x;\n            case 2:\n                return pt2.y > pt1.y;\n            default:\n                return pt2.x < pt1.x;\n        }\n    }\n    static hasHorzOverlap(left1, right1, left2, right2) {\n        return left1.x < right2.x && right1.x > left2.x;\n    }\n    static hasVertOverlap(top1, bottom1, top2, bottom2) {\n        return top1.y < bottom2.y && bottom1.y > top2.y;\n    }\n    static addToEdge(edge, op) {\n        if (op.edge) return;\n        op.edge = edge;\n        edge.push(op);\n    }\n    static uncoupleEdge(op) {\n        if (!op.edge) return;\n        for(let i = 0; i < op.edge.length; i++){\n            const op2 = op.edge[i];\n            if (op2 === op) {\n                op.edge[i] = undefined;\n                break;\n            }\n        }\n        op.edge = undefined;\n    }\n    static setNewOwner(op, newIdx) {\n        op.ownerIdx = newIdx;\n        let op2 = op.next;\n        while(op2 !== op){\n            op2.ownerIdx = newIdx;\n            op2 = op2.next;\n        }\n    }\n    addCorner(prev, curr) {\n        if ($0b6dbf71c0c0eea1$export$ada4127871f05d7b.headingClockwise(prev, curr)) this.add(this.rectPath[prev]);\n        else this.add(this.rectPath[curr]);\n    }\n    addCornerByRef(loc, isClockwise) {\n        if (isClockwise) {\n            this.add(this.rectPath[loc]);\n            loc = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.getAdjacentLocation(loc, true);\n        } else {\n            loc = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.getAdjacentLocation(loc, false);\n            this.add(this.rectPath[loc]);\n        }\n    }\n    static getLocation(rec, pt) {\n        let loc;\n        if (pt.x === rec.left && pt.y >= rec.top && pt.y <= rec.bottom) {\n            loc = $0b6dbf71c0c0eea1$var$Location.left; // pt on rec\n            return {\n                success: false,\n                loc: loc\n            };\n        }\n        if (pt.x === rec.right && pt.y >= rec.top && pt.y <= rec.bottom) {\n            loc = $0b6dbf71c0c0eea1$var$Location.right; // pt on rec\n            return {\n                success: false,\n                loc: loc\n            };\n        }\n        if (pt.y === rec.top && pt.x >= rec.left && pt.x <= rec.right) {\n            loc = $0b6dbf71c0c0eea1$var$Location.top; // pt on rec\n            return {\n                success: false,\n                loc: loc\n            };\n        }\n        if (pt.y === rec.bottom && pt.x >= rec.left && pt.x <= rec.right) {\n            loc = $0b6dbf71c0c0eea1$var$Location.bottom; // pt on rec\n            return {\n                success: false,\n                loc: loc\n            };\n        }\n        if (pt.x < rec.left) loc = $0b6dbf71c0c0eea1$var$Location.left;\n        else if (pt.x > rec.right) loc = $0b6dbf71c0c0eea1$var$Location.right;\n        else if (pt.y < rec.top) loc = $0b6dbf71c0c0eea1$var$Location.top;\n        else if (pt.y > rec.bottom) loc = $0b6dbf71c0c0eea1$var$Location.bottom;\n        else loc = $0b6dbf71c0c0eea1$var$Location.inside;\n        return {\n            success: true,\n            loc: loc\n        };\n    }\n    static getIntersection(rectPath, p, p2, loc) {\n        // gets the pt of intersection between rectPath and segment(p, p2) that's closest to 'p'\n        // when result == false, loc will remain unchanged\n        let ip = new $0b6dbf71c0c0eea1$export$d379afd9763b528f();\n        switch(loc){\n            case $0b6dbf71c0c0eea1$var$Location.left:\n                if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\n                else if (p.y < rectPath[0].y && $0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.top;\n                } else if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.bottom;\n                } else return {\n                    success: false,\n                    loc: loc,\n                    ip: ip\n                };\n                break;\n            case $0b6dbf71c0c0eea1$var$Location.right:\n                if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\n                else if (p.y < rectPath[0].y && $0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.top;\n                } else if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.bottom;\n                } else return {\n                    success: false,\n                    loc: loc,\n                    ip: ip\n                };\n                break;\n            case $0b6dbf71c0c0eea1$var$Location.top:\n                if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\n                else if (p.x < rectPath[0].x && $0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.left;\n                } else if (p.x > rectPath[1].x && $0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.right;\n                } else return {\n                    success: false,\n                    loc: loc,\n                    ip: ip\n                };\n                break;\n            case $0b6dbf71c0c0eea1$var$Location.bottom:\n                if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\n                else if (p.x < rectPath[3].x && $0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.left;\n                } else if (p.x > rectPath[2].x && $0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.right;\n                } else return {\n                    success: false,\n                    loc: loc,\n                    ip: ip\n                };\n                break;\n            case $0b6dbf71c0c0eea1$var$Location.inside:\n                if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.left;\n                } else if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.top;\n                } else if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.right;\n                } else if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\n                    ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\n                    loc = $0b6dbf71c0c0eea1$var$Location.bottom;\n                } else return {\n                    success: false,\n                    loc: loc,\n                    ip: ip\n                };\n                break;\n        }\n        return {\n            success: true,\n            loc: loc,\n            ip: ip\n        };\n    }\n    getNextLocation(path, context) {\n        switch(context.loc){\n            case $0b6dbf71c0c0eea1$var$Location.left:\n                while(context.i <= context.highI && path[context.i].x <= this.rect.left)context.i++;\n                if (context.i > context.highI) break;\n                if (path[context.i].x >= this.rect.right) context.loc = $0b6dbf71c0c0eea1$var$Location.right;\n                else if (path[context.i].y <= this.rect.top) context.loc = $0b6dbf71c0c0eea1$var$Location.top;\n                else if (path[context.i].y >= this.rect.bottom) context.loc = $0b6dbf71c0c0eea1$var$Location.bottom;\n                else context.loc = $0b6dbf71c0c0eea1$var$Location.inside;\n                break;\n            case $0b6dbf71c0c0eea1$var$Location.top:\n                while(context.i <= context.highI && path[context.i].y <= this.rect.top)context.i++;\n                if (context.i > context.highI) break;\n                if (path[context.i].y >= this.rect.bottom) context.loc = $0b6dbf71c0c0eea1$var$Location.bottom;\n                else if (path[context.i].x <= this.rect.left) context.loc = $0b6dbf71c0c0eea1$var$Location.left;\n                else if (path[context.i].x >= this.rect.right) context.loc = $0b6dbf71c0c0eea1$var$Location.right;\n                else context.loc = $0b6dbf71c0c0eea1$var$Location.inside;\n                break;\n            case $0b6dbf71c0c0eea1$var$Location.right:\n                while(context.i <= context.highI && path[context.i].x >= this.rect.right)context.i++;\n                if (context.i > context.highI) break;\n                if (path[context.i].x <= this.rect.left) context.loc = $0b6dbf71c0c0eea1$var$Location.left;\n                else if (path[context.i].y <= this.rect.top) context.loc = $0b6dbf71c0c0eea1$var$Location.top;\n                else if (path[context.i].y >= this.rect.bottom) context.loc = $0b6dbf71c0c0eea1$var$Location.bottom;\n                else context.loc = $0b6dbf71c0c0eea1$var$Location.inside;\n                break;\n            case $0b6dbf71c0c0eea1$var$Location.bottom:\n                while(context.i <= context.highI && path[context.i].y >= this.rect.bottom)context.i++;\n                if (context.i > context.highI) break;\n                if (path[context.i].y <= this.rect.top) context.loc = $0b6dbf71c0c0eea1$var$Location.top;\n                else if (path[context.i].x <= this.rect.left) context.loc = $0b6dbf71c0c0eea1$var$Location.left;\n                else if (path[context.i].x >= this.rect.right) context.loc = $0b6dbf71c0c0eea1$var$Location.right;\n                else context.loc = $0b6dbf71c0c0eea1$var$Location.inside;\n                break;\n            case $0b6dbf71c0c0eea1$var$Location.inside:\n                while(context.i <= context.highI){\n                    if (path[context.i].x < this.rect.left) context.loc = $0b6dbf71c0c0eea1$var$Location.left;\n                    else if (path[context.i].x > this.rect.right) context.loc = $0b6dbf71c0c0eea1$var$Location.right;\n                    else if (path[context.i].y > this.rect.bottom) context.loc = $0b6dbf71c0c0eea1$var$Location.bottom;\n                    else if (path[context.i].y < this.rect.top) context.loc = $0b6dbf71c0c0eea1$var$Location.top;\n                    else {\n                        this.add(path[context.i]);\n                        context.i++;\n                        continue;\n                    }\n                    break;\n                }\n                break;\n        }\n    }\n    executeInternal(path) {\n        if (path.length < 3 || this.rect.isEmpty()) return;\n        const startLocs = [];\n        let firstCross = $0b6dbf71c0c0eea1$var$Location.inside;\n        let crossingLoc = firstCross, prev = firstCross;\n        let i;\n        const highI = path.length - 1;\n        let result = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.getLocation(this.rect, path[highI]);\n        let loc = result.loc;\n        if (!result.success) {\n            i = highI - 1;\n            while(i >= 0 && !result.success){\n                i--;\n                result = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.getLocation(this.rect, path[i]);\n                prev = result.loc;\n            }\n            if (i < 0) {\n                for (const pt of path)this.add(pt);\n                return;\n            }\n            if (prev == $0b6dbf71c0c0eea1$var$Location.inside) loc = $0b6dbf71c0c0eea1$var$Location.inside;\n        }\n        const startingLoc = loc;\n        ///////////////////////////////////////////////////\n        i = 0;\n        while(i <= highI){\n            prev = loc;\n            const prevCrossLoc = crossingLoc;\n            this.getNextLocation(path, {\n                loc: loc,\n                i: i,\n                highI: highI\n            });\n            if (i > highI) break;\n            const prevPt = i == 0 ? path[highI] : path[i - 1];\n            crossingLoc = loc;\n            let result = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.getIntersection(this.rectPath, path[i], prevPt, crossingLoc);\n            const ip = result.ip;\n            if (!result.success) {\n                if (prevCrossLoc == $0b6dbf71c0c0eea1$var$Location.inside) {\n                    const isClockw = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.isClockwise(prev, loc, prevPt, path[i], this.mp);\n                    do {\n                        startLocs.push(prev);\n                        prev = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.getAdjacentLocation(prev, isClockw);\n                    }while (prev != loc);\n                    crossingLoc = prevCrossLoc;\n                } else if (prev != $0b6dbf71c0c0eea1$var$Location.inside && prev != loc) {\n                    const isClockw = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.isClockwise(prev, loc, prevPt, path[i], this.mp);\n                    do this.addCornerByRef(prev, isClockw);\n                    while (prev != loc);\n                }\n                ++i;\n                continue;\n            }\n            ////////////////////////////////////////////////////\n            // we must be crossing the rect boundary to get here\n            ////////////////////////////////////////////////////\n            if (loc == $0b6dbf71c0c0eea1$var$Location.inside) {\n                if (firstCross == $0b6dbf71c0c0eea1$var$Location.inside) {\n                    firstCross = crossingLoc;\n                    startLocs.push(prev);\n                } else if (prev != crossingLoc) {\n                    const isClockw = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.isClockwise(prev, crossingLoc, prevPt, path[i], this.mp);\n                    do this.addCornerByRef(prev, isClockw);\n                    while (prev != crossingLoc);\n                }\n            } else if (prev != $0b6dbf71c0c0eea1$var$Location.inside) {\n                // passing right through rect. 'ip' here will be the second\n                // intersect pt but we'll also need the first intersect pt (ip2)\n                loc = prev;\n                result = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.getIntersection(this.rectPath, prevPt, path[i], loc);\n                const ip2 = result.ip;\n                if (prevCrossLoc != $0b6dbf71c0c0eea1$var$Location.inside && prevCrossLoc != loc) this.addCorner(prevCrossLoc, loc);\n                if (firstCross == $0b6dbf71c0c0eea1$var$Location.inside) {\n                    firstCross = loc;\n                    startLocs.push(prev);\n                }\n                loc = crossingLoc;\n                this.add(ip2);\n                if (ip == ip2) {\n                    loc = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.getLocation(this.rect, path[i]).loc;\n                    this.addCorner(crossingLoc, loc);\n                    crossingLoc = loc;\n                    continue;\n                }\n            } else {\n                loc = crossingLoc;\n                if (firstCross == $0b6dbf71c0c0eea1$var$Location.inside) firstCross = crossingLoc;\n            }\n            this.add(ip);\n        } //while i <= highI\n        ///////////////////////////////////////////////////\n        if (firstCross == $0b6dbf71c0c0eea1$var$Location.inside) {\n            if (startingLoc != $0b6dbf71c0c0eea1$var$Location.inside) {\n                if (this.pathBounds.containsRect(this.rect) && $0b6dbf71c0c0eea1$export$ada4127871f05d7b.path1ContainsPath2(path, this.rectPath)) for(let j = 0; j < 4; j++){\n                    this.add(this.rectPath[j]);\n                    $0b6dbf71c0c0eea1$export$ada4127871f05d7b.addToEdge(this.edges[j * 2], this.results[0]);\n                }\n            }\n        } else if (loc != $0b6dbf71c0c0eea1$var$Location.inside && (loc != firstCross || startLocs.length > 2)) {\n            if (startLocs.length > 0) {\n                prev = loc;\n                for (const loc2 of startLocs){\n                    if (prev == loc2) continue;\n                    this.addCornerByRef(prev, $0b6dbf71c0c0eea1$export$ada4127871f05d7b.headingClockwise(prev, loc2));\n                    prev = loc2;\n                }\n                loc = prev;\n            }\n            if (loc != firstCross) this.addCornerByRef(loc, $0b6dbf71c0c0eea1$export$ada4127871f05d7b.headingClockwise(loc, firstCross));\n        }\n    }\n    execute(paths) {\n        const result = [];\n        if (this.rect.isEmpty()) return result;\n        for (const path of paths){\n            if (path.length < 3) continue;\n            this.pathBounds = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.getBounds(path);\n            if (!this.rect.intersects(this.pathBounds)) continue;\n            else if (this.rect.containsRect(this.pathBounds)) {\n                result.push(path);\n                continue;\n            }\n            this.executeInternal(path);\n            this.checkEdges();\n            for(let i = 0; i < 4; ++i)this.tidyEdgePair(i, this.edges[i * 2], this.edges[i * 2 + 1]);\n            for (const op of this.results){\n                const tmp = this.getPath(op);\n                if (tmp.length > 0) result.push(tmp);\n            }\n            this.results.length = 0;\n            for(let i = 0; i < 8; i++)this.edges[i].length = 0;\n        }\n        return result;\n    }\n    checkEdges() {\n        for(let i = 0; i < this.results.length; i++){\n            let op = this.results[i];\n            let op2 = op;\n            if (op === undefined) continue;\n            do if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(op2.prev.pt, op2.pt, op2.next.pt) === 0) {\n                if (op2 === op) {\n                    op2 = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.unlinkOpBack(op2);\n                    if (op2 === undefined) break;\n                    op = op2.prev;\n                } else {\n                    op2 = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.unlinkOpBack(op2);\n                    if (op2 === undefined) break;\n                }\n            } else op2 = op2.next;\n            while (op2 !== op);\n            if (op2 === undefined) {\n                this.results[i] = undefined;\n                continue;\n            }\n            this.results[i] = op2;\n            let edgeSet1 = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.getEdgesForPt(op.prev.pt, this.rect);\n            op2 = op;\n            do {\n                const edgeSet2 = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.getEdgesForPt(op2.pt, this.rect);\n                if (edgeSet2 !== 0 && op2.edge === undefined) {\n                    const combinedSet = edgeSet1 & edgeSet2;\n                    for(let j = 0; j < 4; ++j)if ((combinedSet & 1 << j) !== 0) {\n                        if ($0b6dbf71c0c0eea1$export$ada4127871f05d7b.isHeadingClockwise(op2.prev.pt, op2.pt, j)) $0b6dbf71c0c0eea1$export$ada4127871f05d7b.addToEdge(this.edges[j * 2], op2);\n                        else $0b6dbf71c0c0eea1$export$ada4127871f05d7b.addToEdge(this.edges[j * 2 + 1], op2);\n                    }\n                }\n                edgeSet1 = edgeSet2;\n                op2 = op2.next;\n            }while (op2 !== op);\n        }\n    }\n    tidyEdgePair(idx, cw, ccw) {\n        if (ccw.length === 0) return;\n        const isHorz = idx === 1 || idx === 3;\n        const cwIsTowardLarger = idx === 1 || idx === 2;\n        let i = 0, j = 0;\n        let p1, p2, p1a, p2a, op, op2;\n        while(i < cw.length){\n            p1 = cw[i];\n            if (!p1 || p1.next === p1.prev) {\n                cw[i++] = undefined;\n                j = 0;\n                continue;\n            }\n            const jLim = ccw.length;\n            while(j < jLim && (!ccw[j] || ccw[j].next === ccw[j].prev))++j;\n            if (j === jLim) {\n                ++i;\n                j = 0;\n                continue;\n            }\n            if (cwIsTowardLarger) {\n                p1 = cw[i].prev;\n                p1a = cw[i];\n                p2 = ccw[j];\n                p2a = ccw[j].prev;\n            } else {\n                p1 = cw[i];\n                p1a = cw[i].prev;\n                p2 = ccw[j].prev;\n                p2a = ccw[j];\n            }\n            if (isHorz && !$0b6dbf71c0c0eea1$export$ada4127871f05d7b.hasHorzOverlap(p1.pt, p1a.pt, p2.pt, p2a.pt) || !isHorz && !$0b6dbf71c0c0eea1$export$ada4127871f05d7b.hasVertOverlap(p1.pt, p1a.pt, p2.pt, p2a.pt)) {\n                ++j;\n                continue;\n            }\n            const isRejoining = cw[i].ownerIdx !== ccw[j].ownerIdx;\n            if (isRejoining) {\n                this.results[p2.ownerIdx] = undefined;\n                $0b6dbf71c0c0eea1$export$ada4127871f05d7b.setNewOwner(p2, p1.ownerIdx);\n            }\n            if (cwIsTowardLarger) {\n                // p1 >> | >> p1a;\n                // p2 << | << p2a;\n                p1.next = p2;\n                p2.prev = p1;\n                p1a.prev = p2a;\n                p2a.next = p1a;\n            } else {\n                // p1 << | << p1a;\n                // p2 >> | >> p2a;\n                p1.prev = p2;\n                p2.next = p1;\n                p1a.next = p2a;\n                p2a.prev = p1a;\n            }\n            if (!isRejoining) {\n                const new_idx = this.results.length;\n                this.results.push(p1a);\n                $0b6dbf71c0c0eea1$export$ada4127871f05d7b.setNewOwner(p1a, new_idx);\n            }\n            if (cwIsTowardLarger) {\n                op = p2;\n                op2 = p1a;\n            } else {\n                op = p1;\n                op2 = p2a;\n            }\n            this.results[op.ownerIdx] = op;\n            this.results[op2.ownerIdx] = op2;\n            // and now lots of work to get ready for the next loop\n            let opIsLarger, op2IsLarger;\n            if (isHorz) {\n                opIsLarger = op.pt.x > op.prev.pt.x;\n                op2IsLarger = op2.pt.x > op2.prev.pt.x;\n            } else {\n                opIsLarger = op.pt.y > op.prev.pt.y;\n                op2IsLarger = op2.pt.y > op2.prev.pt.y;\n            }\n            if (op.next === op.prev || op.pt === op.prev.pt) {\n                if (op2IsLarger === cwIsTowardLarger) {\n                    cw[i] = op2;\n                    ccw[j++] = undefined;\n                } else {\n                    ccw[j] = op2;\n                    cw[i++] = undefined;\n                }\n            } else if (op2.next === op2.prev || op2.pt === op2.prev.pt) {\n                if (opIsLarger === cwIsTowardLarger) {\n                    cw[i] = op;\n                    ccw[j++] = undefined;\n                } else {\n                    ccw[j] = op;\n                    cw[i++] = undefined;\n                }\n            } else if (opIsLarger === op2IsLarger) {\n                if (opIsLarger === cwIsTowardLarger) {\n                    cw[i] = op;\n                    $0b6dbf71c0c0eea1$export$ada4127871f05d7b.uncoupleEdge(op2);\n                    $0b6dbf71c0c0eea1$export$ada4127871f05d7b.addToEdge(cw, op2);\n                    ccw[j++] = undefined;\n                } else {\n                    cw[i++] = undefined;\n                    ccw[j] = op2;\n                    $0b6dbf71c0c0eea1$export$ada4127871f05d7b.uncoupleEdge(op);\n                    $0b6dbf71c0c0eea1$export$ada4127871f05d7b.addToEdge(ccw, op);\n                    j = 0;\n                }\n            } else {\n                if (opIsLarger === cwIsTowardLarger) cw[i] = op;\n                else ccw[j] = op;\n                if (op2IsLarger === cwIsTowardLarger) cw[i] = op2;\n                else ccw[j] = op2;\n            }\n        }\n    }\n    getPath(op) {\n        const result = new $0b6dbf71c0c0eea1$export$b12670b10302a8b7();\n        if (!op || op.prev === op.next) return result;\n        let op2 = op.next;\n        while(op2 && op2 !== op)if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(op2.prev.pt, op2.pt, op2.next.pt) === 0) {\n            op = op2.prev;\n            op2 = $0b6dbf71c0c0eea1$export$ada4127871f05d7b.unlinkOp(op2);\n        } else op2 = op2.next;\n        if (!op2) return new $0b6dbf71c0c0eea1$export$b12670b10302a8b7();\n        result.push(op.pt);\n        op2 = op.next;\n        while(op2 !== op){\n            result.push(op2.pt);\n            op2 = op2.next;\n        }\n        return result;\n    }\n}\nclass $0b6dbf71c0c0eea1$export$b1d67b8e0b9a10d2 extends $0b6dbf71c0c0eea1$export$ada4127871f05d7b {\n    constructor(rect){\n        super(rect);\n    }\n    execute(paths) {\n        const result = new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9();\n        if (this.rect.isEmpty()) return result;\n        for (const path of paths){\n            if (path.length < 2) continue;\n            this.pathBounds = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.getBounds(path);\n            if (!this.rect.intersects(this.pathBounds)) continue;\n            this.executeInternal(path);\n            for (const op of this.results){\n                const tmp = this.getPath(op);\n                if (tmp.length > 0) result.push(tmp);\n            }\n            // Clean up after every loop\n            this.results.length = 0; // Clear the array\n            for(let i = 0; i < 8; i++)this.edges[i].length = 0; // Clear each array\n        }\n        return result;\n    }\n    getPath(op) {\n        const result = new $0b6dbf71c0c0eea1$export$b12670b10302a8b7();\n        if (!op || op === op.next) return result;\n        op = op.next; // starting at path beginning \n        result.push(op.pt);\n        let op2 = op.next;\n        while(op2 !== op){\n            result.push(op2.pt);\n            op2 = op2.next;\n        }\n        return result;\n    }\n    executeInternal(path) {\n        this.results = [];\n        if (path.length < 2 || this.rect.isEmpty()) return;\n        let prev = $0b6dbf71c0c0eea1$var$Location.inside;\n        let i = 1;\n        const highI = path.length - 1;\n        let result = $0b6dbf71c0c0eea1$export$b1d67b8e0b9a10d2.getLocation(this.rect, path[0]);\n        let loc = result.loc;\n        if (!result.success) {\n            while(i <= highI && !result.success){\n                i++;\n                result = $0b6dbf71c0c0eea1$export$b1d67b8e0b9a10d2.getLocation(this.rect, path[i]);\n                prev = result.loc;\n            }\n            if (i > highI) for (const pt of path)this.add(pt);\n            if (prev == $0b6dbf71c0c0eea1$var$Location.inside) loc = $0b6dbf71c0c0eea1$var$Location.inside;\n            i = 1;\n        }\n        if (loc == $0b6dbf71c0c0eea1$var$Location.inside) this.add(path[0]);\n        while(i <= highI){\n            prev = loc;\n            this.getNextLocation(path, {\n                loc: loc,\n                i: i,\n                highI: highI\n            });\n            if (i > highI) break;\n            const prevPt = path[i - 1];\n            let crossingLoc = loc;\n            let result = $0b6dbf71c0c0eea1$export$b1d67b8e0b9a10d2.getIntersection(this.rectPath, path[i], prevPt, crossingLoc);\n            const ip = result.ip;\n            crossingLoc = result.loc;\n            if (!result.success) {\n                i++;\n                continue;\n            }\n            if (loc == $0b6dbf71c0c0eea1$var$Location.inside) this.add(ip, true);\n            else if (prev !== $0b6dbf71c0c0eea1$var$Location.inside) {\n                crossingLoc = prev;\n                result = $0b6dbf71c0c0eea1$export$b1d67b8e0b9a10d2.getIntersection(this.rectPath, prevPt, path[i], crossingLoc);\n                const ip2 = result.ip;\n                crossingLoc = result.loc;\n                this.add(ip2);\n                this.add(ip);\n            } else this.add(ip);\n        }\n    }\n}\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  16 July 2023                                                    *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  This module contains simple functions that will likely cover    *\r\n*              most polygon boolean and offsetting needs, while also avoiding  *\r\n*              the inherent complexities of the other modules.                 *\r\n* Thanks    :  Special thanks to Thong Nguyen, Guus Kuiper, Phil Stopford,     *\r\n*           :  and Daniel Gosnell for their invaluable assistance with C#.     *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/ //\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.cs\n// Removed support for USINGZ\n//\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\n//\nclass $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908 {\n    static get InvalidRect64() {\n        if (!$0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.invalidRect64) $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.invalidRect64 = new $0b6dbf71c0c0eea1$export$e7ab2e89a2fb5a6f(false);\n        return this.invalidRect64;\n    }\n    static Intersect(subject, clip, fillRule) {\n        return this.BooleanOp($0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Intersection, subject, clip, fillRule);\n    }\n    static Union(subject, clip, fillRule = $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.EvenOdd) {\n        return this.BooleanOp($0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Union, subject, clip, fillRule);\n    }\n    static Difference(subject, clip, fillRule) {\n        return this.BooleanOp($0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Difference, subject, clip, fillRule);\n    }\n    static Xor(subject, clip, fillRule) {\n        return this.BooleanOp($0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Xor, subject, clip, fillRule);\n    }\n    static BooleanOp(clipType, subject, clip, fillRule = $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.EvenOdd) {\n        const solution = new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9();\n        if (!subject) return solution;\n        const c = new $0b6dbf71c0c0eea1$export$389255fe4ace408b();\n        c.addPaths(subject, $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Subject);\n        if (clip) c.addPaths(clip, $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Clip);\n        c.execute(clipType, fillRule, solution);\n        return solution;\n    }\n    //public static BooleanOp(clipType: ClipType, subject: Paths64, clip: Paths64, polytree: PolyTree64, fillRule: FillRule): void {\n    //  if (!subject) return;\n    //  const c: Clipper64 = new Clipper64();\n    //  c.addPaths(subject, PathType.Subject);\n    //  if (clip)\n    //    c.addPaths(clip, PathType.Clip);\n    //  c.execute(clipType, fillRule, polytree);\n    //}\n    static InflatePaths(paths, delta, joinType, endType, miterLimit = 2.0) {\n        const co = new $0b6dbf71c0c0eea1$export$8cbc02e4273c0b24(miterLimit);\n        co.addPaths(paths, joinType, endType);\n        const solution = new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9();\n        co.execute(delta, solution);\n        return solution;\n    }\n    static RectClipPaths(rect, paths) {\n        if (rect.isEmpty() || paths.length === 0) return new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9();\n        const rc = new $0b6dbf71c0c0eea1$export$ada4127871f05d7b(rect);\n        return rc.execute(paths);\n    }\n    static RectClip(rect, path) {\n        if (rect.isEmpty() || path.length === 0) return new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9();\n        const tmp = new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9();\n        tmp.push(path);\n        return this.RectClipPaths(rect, tmp);\n    }\n    static RectClipLinesPaths(rect, paths) {\n        if (rect.isEmpty() || paths.length === 0) return new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9();\n        const rc = new $0b6dbf71c0c0eea1$export$b1d67b8e0b9a10d2(rect);\n        return rc.execute(paths);\n    }\n    static RectClipLines(rect, path) {\n        if (rect.isEmpty() || path.length === 0) return new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9();\n        const tmp = new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9();\n        tmp.push(path);\n        return this.RectClipLinesPaths(rect, tmp);\n    }\n    static MinkowskiSum(pattern, path, isClosed) {\n        return $0b6dbf71c0c0eea1$export$d7b4df78e16216b1.sum(pattern, path, isClosed);\n    }\n    static MinkowskiDiff(pattern, path, isClosed) {\n        return $0b6dbf71c0c0eea1$export$d7b4df78e16216b1.diff(pattern, path, isClosed);\n    }\n    static area(path) {\n        // https://en.wikipedia.org/wiki/Shoelace_formula\n        let a = 0.0;\n        const cnt = path.length;\n        if (cnt < 3) return 0.0;\n        let prevPt = path[cnt - 1];\n        for (const pt of path){\n            a += (prevPt.y + pt.y) * (prevPt.x - pt.x);\n            prevPt = pt;\n        }\n        return a * 0.5;\n    }\n    static areaPaths(paths) {\n        let a = 0.0;\n        for (const path of paths)a += this.area(path);\n        return a;\n    }\n    static isPositive(poly) {\n        return this.area(poly) >= 0;\n    }\n    static path64ToString(path) {\n        let result = \"\";\n        for (const pt of path)result += pt.toString();\n        return result + \"\\n\";\n    }\n    static paths64ToString(paths) {\n        let result = \"\";\n        for (const path of paths)result += this.path64ToString(path);\n        return result;\n    }\n    static offsetPath(path, dx, dy) {\n        const result = new $0b6dbf71c0c0eea1$export$b12670b10302a8b7();\n        for (const pt of path)result.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(pt.x + dx, pt.y + dy));\n        return result;\n    }\n    static scalePoint64(pt, scale) {\n        const result = new $0b6dbf71c0c0eea1$export$d379afd9763b528f(Math.round(pt.x * scale), Math.round(pt.y * scale));\n        return result;\n    }\n    static scalePath(path, scale) {\n        if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.isAlmostZero(scale - 1)) return path;\n        const result = [];\n        for (const pt of path)result.push({\n            x: pt.x * scale,\n            y: pt.y * scale\n        });\n        return result;\n    }\n    static scalePaths(paths, scale) {\n        if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.isAlmostZero(scale - 1)) return paths;\n        const result = [];\n        for (const path of paths)result.push(this.scalePath(path, scale));\n        return result;\n    }\n    static translatePath(path, dx, dy) {\n        const result = [];\n        for (const pt of path)result.push({\n            x: pt.x + dx,\n            y: pt.y + dy\n        });\n        return result;\n    }\n    static translatePaths(paths, dx, dy) {\n        const result = [];\n        for (const path of paths)result.push(this.translatePath(path, dx, dy));\n        return result;\n    }\n    static reversePath(path) {\n        return [\n            ...path\n        ].reverse();\n    }\n    static reversePaths(paths) {\n        const result = [];\n        for (const t of paths)result.push(this.reversePath(t));\n        return result;\n    }\n    static getBounds(path) {\n        const result = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.InvalidRect64;\n        for (const pt of path){\n            if (pt.x < result.left) result.left = pt.x;\n            if (pt.x > result.right) result.right = pt.x;\n            if (pt.y < result.top) result.top = pt.y;\n            if (pt.y > result.bottom) result.bottom = pt.y;\n        }\n        return result.left === Number.MAX_SAFE_INTEGER ? new $0b6dbf71c0c0eea1$export$e7ab2e89a2fb5a6f(0, 0, 0, 0) : result;\n    }\n    static getBoundsPaths(paths) {\n        const result = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.InvalidRect64;\n        for (const path of paths)for (const pt of path){\n            if (pt.x < result.left) result.left = pt.x;\n            if (pt.x > result.right) result.right = pt.x;\n            if (pt.y < result.top) result.top = pt.y;\n            if (pt.y > result.bottom) result.bottom = pt.y;\n        }\n        return result.left === Number.MAX_SAFE_INTEGER ? new $0b6dbf71c0c0eea1$export$e7ab2e89a2fb5a6f(0, 0, 0, 0) : result;\n    }\n    static makePath(arr) {\n        const len = arr.length / 2;\n        const p = new $0b6dbf71c0c0eea1$export$b12670b10302a8b7();\n        for(let i = 0; i < len; i++)p.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(arr[i * 2], arr[i * 2 + 1]));\n        return p;\n    }\n    static stripDuplicates(path, isClosedPath) {\n        const cnt = path.length;\n        const result = new $0b6dbf71c0c0eea1$export$b12670b10302a8b7();\n        if (cnt === 0) return result;\n        let lastPt = path[0];\n        result.push(lastPt);\n        for(let i = 1; i < cnt; i++)if (lastPt !== path[i]) {\n            lastPt = path[i];\n            result.push(lastPt);\n        }\n        if (isClosedPath && lastPt === result[0]) result.pop();\n        return result;\n    }\n    static addPolyNodeToPaths(polyPath, paths) {\n        if (polyPath.polygon && polyPath.polygon.length > 0) paths.push(polyPath.polygon);\n        for(let i = 0; i < polyPath.count; i++)this.addPolyNodeToPaths(polyPath.children[i], paths);\n    }\n    static polyTreeToPaths64(polyTree) {\n        const result = new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9();\n        for(let i = 0; i < polyTree.count; i++)$0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.addPolyNodeToPaths(polyTree.children[i], result);\n        return result;\n    }\n    static perpendicDistFromLineSqrd(pt, line1, line2) {\n        const a = pt.x - line1.x;\n        const b = pt.y - line1.y;\n        const c = line2.x - line1.x;\n        const d = line2.y - line1.y;\n        if (c === 0 && d === 0) return 0;\n        return $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.sqr(a * d - c * b) / (c * c + d * d);\n    }\n    static rdp(path, begin, end, epsSqrd, flags) {\n        let idx = 0;\n        let max_d = 0;\n        while(end > begin && path[begin] === path[end])flags[end--] = false;\n        for(let i = begin + 1; i < end; i++){\n            const d = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.perpendicDistFromLineSqrd(path[i], path[begin], path[end]);\n            if (d <= max_d) continue;\n            max_d = d;\n            idx = i;\n        }\n        if (max_d <= epsSqrd) return;\n        flags[idx] = true;\n        if (idx > begin + 1) $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.rdp(path, begin, idx, epsSqrd, flags);\n        if (idx < end - 1) $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.rdp(path, idx, end, epsSqrd, flags);\n    }\n    static ramerDouglasPeucker(path, epsilon) {\n        const len = path.length;\n        if (len < 5) return path;\n        const flags = new Array(len).fill(false);\n        flags[0] = true;\n        flags[len - 1] = true;\n        $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.rdp(path, 0, len - 1, $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.sqr(epsilon), flags);\n        const result = [];\n        for(let i = 0; i < len; i++)if (flags[i]) result.push(path[i]);\n        return result;\n    }\n    static ramerDouglasPeuckerPaths(paths, epsilon) {\n        const result = [];\n        for (const path of paths)result.push($0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.ramerDouglasPeucker(path, epsilon));\n        return result;\n    }\n    static getNext(current, high, flags) {\n        current++;\n        while(current <= high && flags[current])current++;\n        if (current <= high) return current;\n        current = 0;\n        while(flags[current])current++;\n        return current;\n    }\n    static getPrior(current, high, flags) {\n        if (current === 0) current = high;\n        else current--;\n        while(current > 0 && flags[current])current--;\n        if (!flags[current]) return current;\n        current = high;\n        while(flags[current])current--;\n        return current;\n    }\n    static sqr(value) {\n        return value * value;\n    }\n    static simplifyPath(path, epsilon, isClosedPath = false) {\n        const len = path.length;\n        const high = len - 1;\n        const epsSqr = this.sqr(epsilon);\n        if (len < 4) return path;\n        const flags = new Array(len).fill(false);\n        const dsq = new Array(len).fill(0);\n        let prev = high;\n        let curr = 0;\n        let start, next, prior2, next2;\n        if (isClosedPath) {\n            dsq[0] = this.perpendicDistFromLineSqrd(path[0], path[high], path[1]);\n            dsq[high] = this.perpendicDistFromLineSqrd(path[high], path[0], path[high - 1]);\n        } else {\n            dsq[0] = Number.MAX_VALUE;\n            dsq[high] = Number.MAX_VALUE;\n        }\n        for(let i = 1; i < high; i++)dsq[i] = this.perpendicDistFromLineSqrd(path[i], path[i - 1], path[i + 1]);\n        for(;;){\n            if (dsq[curr] > epsSqr) {\n                start = curr;\n                do curr = this.getNext(curr, high, flags);\n                while (curr !== start && dsq[curr] > epsSqr);\n                if (curr === start) break;\n            }\n            prev = this.getPrior(curr, high, flags);\n            next = this.getNext(curr, high, flags);\n            if (next === prev) break;\n            if (dsq[next] < dsq[curr]) {\n                flags[next] = true;\n                next = this.getNext(next, high, flags);\n                next2 = this.getNext(next, high, flags);\n                dsq[curr] = this.perpendicDistFromLineSqrd(path[curr], path[prev], path[next]);\n                if (next !== high || isClosedPath) dsq[next] = this.perpendicDistFromLineSqrd(path[next], path[curr], path[next2]);\n                curr = next;\n            } else {\n                flags[curr] = true;\n                curr = next;\n                next = this.getNext(next, high, flags);\n                prior2 = this.getPrior(prev, high, flags);\n                dsq[curr] = this.perpendicDistFromLineSqrd(path[curr], path[prev], path[next]);\n                if (prev !== 0 || isClosedPath) dsq[prev] = this.perpendicDistFromLineSqrd(path[prev], path[prior2], path[curr]);\n            }\n        }\n        const result = [];\n        for(let i = 0; i < len; i++)if (!flags[i]) result.push(path[i]);\n        return result;\n    }\n    static simplifyPaths(paths, epsilon, isClosedPaths = false) {\n        const result = [];\n        for (const path of paths)result.push(this.simplifyPath(path, epsilon, isClosedPaths));\n        return result;\n    }\n    //private static getNext(current: number, high: number, flags: boolean[]): number {\n    //  current++;\n    //  while (current <= high && flags[current]) current++;\n    //  return current;\n    //}\n    //private static getPrior(current: number, high: number, flags: boolean[]): number {\n    //  if (current === 0) return high;\n    //  current--;\n    //  while (current > 0 && flags[current]) current--;\n    //  return current;\n    //}\n    static trimCollinear(path, isOpen = false) {\n        let len = path.length;\n        let i = 0;\n        if (!isOpen) {\n            while(i < len - 1 && $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(path[len - 1], path[i], path[i + 1]) === 0)i++;\n            while(i < len - 1 && $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(path[len - 2], path[len - 1], path[i]) === 0)len--;\n        }\n        if (len - i < 3) {\n            if (!isOpen || len < 2 || path[0] === path[1]) return [];\n            return path;\n        }\n        const result = [];\n        let last = path[i];\n        result.push(last);\n        for(i++; i < len - 1; i++){\n            if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(last, path[i], path[i + 1]) === 0) continue;\n            last = path[i];\n            result.push(last);\n        }\n        if (isOpen) result.push(path[len - 1]);\n        else if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(last, path[len - 1], result[0]) !== 0) result.push(path[len - 1]);\n        else {\n            while(result.length > 2 && $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(result[result.length - 1], result[result.length - 2], result[0]) === 0)result.pop();\n            if (result.length < 3) result.splice(0, result.length);\n        }\n        return result;\n    }\n    static pointInPolygon(pt, polygon) {\n        return $0b6dbf71c0c0eea1$export$9bad362b29d84293.pointInPolygon(pt, polygon);\n    }\n    static ellipse(center, radiusX, radiusY = 0, steps = 0) {\n        if (radiusX <= 0) return [];\n        if (radiusY <= 0) radiusY = radiusX;\n        if (steps <= 2) steps = Math.ceil(Math.PI * Math.sqrt((radiusX + radiusY) / 2));\n        const si = Math.sin(2 * Math.PI / steps);\n        const co = Math.cos(2 * Math.PI / steps);\n        let dx = co, dy = si;\n        const result = [\n            {\n                x: center.x + radiusX,\n                y: center.y\n            }\n        ];\n        for(let i = 1; i < steps; ++i){\n            result.push({\n                x: center.x + radiusX * dx,\n                y: center.y + radiusY * dy\n            });\n            const x = dx * co - dy * si;\n            dy = dy * co + dx * si;\n            dx = x;\n        }\n        return result;\n    }\n    static showPolyPathStructure(pp, level) {\n        const spaces = \" \".repeat(level * 2);\n        const caption = pp.isHole ? \"Hole \" : \"Outer \";\n        if (pp.count === 0) console.log(spaces + caption);\n        else {\n            console.log(spaces + caption + `(${pp.count})`);\n            pp.forEach((child)=>this.showPolyPathStructure(child, level + 1));\n        }\n    }\n    static showPolyTreeStructure(polytree) {\n        console.log(\"Polytree Root\");\n        polytree.forEach((child)=>this.showPolyPathStructure(child, 1));\n    }\n}\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  27 August 2023                                                  *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  This is the main polygon clipping module                        *\r\n* Thanks    :  Special thanks to Thong Nguyen, Guus Kuiper, Phil Stopford,     *\r\n*           :  and Daniel Gosnell for their invaluable assistance with C#.     *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/ //\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Engine.cs\n// Removed support for USINGZ\n//\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\n//\nvar $0b6dbf71c0c0eea1$export$20896d302a4e5029;\n(function(PointInPolygonResult) {\n    PointInPolygonResult[PointInPolygonResult[\"IsOn\"] = 0] = \"IsOn\";\n    PointInPolygonResult[PointInPolygonResult[\"IsInside\"] = 1] = \"IsInside\";\n    PointInPolygonResult[PointInPolygonResult[\"IsOutside\"] = 2] = \"IsOutside\";\n})($0b6dbf71c0c0eea1$export$20896d302a4e5029 || ($0b6dbf71c0c0eea1$export$20896d302a4e5029 = {}));\nvar $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5;\n(function(VertexFlags) {\n    VertexFlags[VertexFlags[\"None\"] = 0] = \"None\";\n    VertexFlags[VertexFlags[\"OpenStart\"] = 1] = \"OpenStart\";\n    VertexFlags[VertexFlags[\"OpenEnd\"] = 2] = \"OpenEnd\";\n    VertexFlags[VertexFlags[\"LocalMax\"] = 4] = \"LocalMax\";\n    VertexFlags[VertexFlags[\"LocalMin\"] = 8] = \"LocalMin\";\n})($0b6dbf71c0c0eea1$export$6bbe4490a892c1c5 || ($0b6dbf71c0c0eea1$export$6bbe4490a892c1c5 = {}));\nclass $0b6dbf71c0c0eea1$var$Vertex {\n    constructor(pt, flags, prev){\n        this.pt = pt;\n        this.flags = flags;\n        this.next = undefined;\n        this.prev = prev;\n    }\n}\nclass $0b6dbf71c0c0eea1$var$LocalMinima {\n    constructor(vertex, polytype, isOpen = false){\n        this.vertex = vertex;\n        this.polytype = polytype;\n        this.isOpen = isOpen;\n    }\n    static equals(lm1, lm2) {\n        return lm1.vertex === lm2.vertex;\n    }\n    static notEquals(lm1, lm2) {\n        return lm1.vertex !== lm2.vertex;\n    }\n}\nclass $0b6dbf71c0c0eea1$var$IntersectNode {\n    constructor(pt, edge1, edge2){\n        this.pt = pt;\n        this.edge1 = edge1;\n        this.edge2 = edge2;\n    }\n}\nclass $0b6dbf71c0c0eea1$var$OutPt {\n    constructor(pt, outrec){\n        this.pt = pt;\n        this.outrec = outrec;\n        this.next = this;\n        this.prev = this;\n        this.horz = undefined;\n    }\n}\nvar $0b6dbf71c0c0eea1$export$290b84559c467a5c;\n(function(JoinWith) {\n    JoinWith[JoinWith[\"None\"] = 0] = \"None\";\n    JoinWith[JoinWith[\"Left\"] = 1] = \"Left\";\n    JoinWith[JoinWith[\"Right\"] = 2] = \"Right\";\n})($0b6dbf71c0c0eea1$export$290b84559c467a5c || ($0b6dbf71c0c0eea1$export$290b84559c467a5c = {}));\nvar $0b6dbf71c0c0eea1$export$c8278727b7a5228b;\n(function(HorzPosition) {\n    HorzPosition[HorzPosition[\"Bottom\"] = 0] = \"Bottom\";\n    HorzPosition[HorzPosition[\"Middle\"] = 1] = \"Middle\";\n    HorzPosition[HorzPosition[\"Top\"] = 2] = \"Top\";\n})($0b6dbf71c0c0eea1$export$c8278727b7a5228b || ($0b6dbf71c0c0eea1$export$c8278727b7a5228b = {}));\nclass $0b6dbf71c0c0eea1$export$1e0666df669b1ceb {\n    constructor(idx){\n        this.idx = idx;\n        this.isOpen = false;\n    }\n}\nclass $0b6dbf71c0c0eea1$var$HorzSegment {\n    constructor(op){\n        this.leftOp = op;\n        this.rightOp = undefined;\n        this.leftToRight = true;\n    }\n}\nclass $0b6dbf71c0c0eea1$var$HorzJoin {\n    constructor(ltor, rtol){\n        this.op1 = ltor;\n        this.op2 = rtol;\n    }\n}\n///////////////////////////////////////////////////////////////////\n// Important: UP and DOWN here are premised on Y-axis positive down\n// displays, which is the orientation used in Clipper's development.\n///////////////////////////////////////////////////////////////////\nclass $0b6dbf71c0c0eea1$export$c3c7cbf43a3f0561 {\n    constructor(){\n        this.dx = this.windCount = this.windCount2 = 0;\n        this.isLeftBound = false;\n        this.joinWith = $0b6dbf71c0c0eea1$export$290b84559c467a5c.None;\n    }\n}\nclass $0b6dbf71c0c0eea1$export$467e9e338ef38141 {\n    static addLocMin(vert, polytype, isOpen, minimaList) {\n        // make sure the vertex is added only once ...\n        if ((vert.flags & $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMin) !== $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.None) return;\n        vert.flags |= $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMin;\n        const lm = new $0b6dbf71c0c0eea1$var$LocalMinima(vert, polytype, isOpen);\n        minimaList.push(lm);\n    }\n    static addPathsToVertexList(paths, polytype, isOpen, minimaList, vertexList) {\n        let totalVertCnt = 0;\n        for (const path of paths)totalVertCnt += path.length;\n        for (const path of paths){\n            let v0 = undefined;\n            let prev_v = undefined;\n            let curr_v = undefined;\n            for (const pt of path){\n                if (!v0) {\n                    v0 = new $0b6dbf71c0c0eea1$var$Vertex(pt, $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.None, undefined);\n                    vertexList.push(v0);\n                    prev_v = v0;\n                } else if (prev_v.pt !== pt) {\n                    curr_v = new $0b6dbf71c0c0eea1$var$Vertex(pt, $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.None, prev_v);\n                    vertexList.push(curr_v);\n                    prev_v.next = curr_v;\n                    prev_v = curr_v;\n                }\n            }\n            if (!prev_v || !prev_v.prev) continue;\n            if (!isOpen && prev_v.pt === v0.pt) prev_v = prev_v.prev;\n            prev_v.next = v0;\n            v0.prev = prev_v;\n            if (!isOpen && prev_v.next === prev_v) continue;\n            // OK, we have a valid path\n            let going_up = false;\n            if (isOpen) {\n                curr_v = v0.next;\n                let count = 0;\n                while(curr_v !== v0 && curr_v.pt.y === v0.pt.y){\n                    curr_v = curr_v.next;\n                    if (count++ > totalVertCnt) {\n                        console.warn(\"infinite loop detected\");\n                        break;\n                    }\n                }\n                going_up = curr_v.pt.y <= v0.pt.y;\n                if (going_up) {\n                    v0.flags = $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.OpenStart;\n                    this.addLocMin(v0, polytype, true, minimaList);\n                } else v0.flags = $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.OpenStart | $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMax;\n            } else {\n                prev_v = v0.prev;\n                let count = 0;\n                while(prev_v !== v0 && prev_v.pt.y === v0.pt.y){\n                    prev_v = prev_v.prev;\n                    if (count++ > totalVertCnt) {\n                        console.warn(\"infinite loop detected\");\n                        break;\n                    }\n                }\n                if (prev_v === v0) continue; // only open paths can be completely flat\n                going_up = prev_v.pt.y > v0.pt.y;\n            }\n            const going_up0 = going_up;\n            prev_v = v0;\n            curr_v = v0.next;\n            let count = 0;\n            while(curr_v !== v0){\n                if (curr_v.pt.y > prev_v.pt.y && going_up) {\n                    prev_v.flags |= $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMax;\n                    going_up = false;\n                } else if (curr_v.pt.y < prev_v.pt.y && !going_up) {\n                    going_up = true;\n                    this.addLocMin(prev_v, polytype, isOpen, minimaList);\n                }\n                prev_v = curr_v;\n                curr_v = curr_v.next;\n                if (count++ > totalVertCnt) {\n                    console.warn(\"infinite loop detected\");\n                    break;\n                }\n            }\n            if (isOpen) {\n                prev_v.flags |= $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.OpenEnd;\n                if (going_up) prev_v.flags |= $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMax;\n                else this.addLocMin(prev_v, polytype, isOpen, minimaList);\n            } else if (going_up !== going_up0) {\n                if (going_up0) this.addLocMin(prev_v, polytype, false, minimaList);\n                else prev_v.flags |= $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMax;\n            }\n        }\n    }\n}\nclass $0b6dbf71c0c0eea1$export$c17ed8035d0de27b {\n    constructor(){\n        this._minimaList = [];\n        this._vertexList = [];\n    }\n    clear() {\n        this._minimaList.length = 0;\n        this._vertexList.length = 0;\n    }\n    addPaths(paths, pt, isOpen) {\n        $0b6dbf71c0c0eea1$export$467e9e338ef38141.addPathsToVertexList(paths, pt, isOpen, this._minimaList, this._vertexList);\n    }\n}\nclass $0b6dbf71c0c0eea1$var$SimpleNavigableSet {\n    constructor(){\n        this.items = [];\n        this.items = [];\n    }\n    clear() {\n        this.items.length = 0;\n    }\n    isEmpty() {\n        return this.items.length == 0;\n    }\n    pollLast() {\n        return this.items.pop();\n    }\n    add(item) {\n        if (!this.items.includes(item)) {\n            this.items.push(item);\n            this.items.sort((a, b)=>a - b);\n        }\n    }\n}\nclass $0b6dbf71c0c0eea1$export$33da2edff2b544f3 {\n    constructor(){\n        this._cliptype = $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.None;\n        this._fillrule = $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.EvenOdd;\n        this._currentLocMin = 0;\n        this._currentBotY = 0;\n        this._isSortedMinimaList = false;\n        this._hasOpenPaths = false;\n        this._using_polytree = false;\n        this._succeeded = false;\n        this.reverseSolution = false;\n        this._minimaList = [];\n        this._intersectList = [];\n        this._vertexList = [];\n        this._outrecList = [];\n        this._scanlineList = new $0b6dbf71c0c0eea1$var$SimpleNavigableSet();\n        this._horzSegList = [];\n        this._horzJoinList = [];\n        this.preserveCollinear = true;\n    }\n    static isOdd(val) {\n        return (val & 1) !== 0;\n    }\n    static isHotEdgeActive(ae) {\n        return ae.outrec !== undefined;\n    }\n    static isOpen(ae) {\n        return ae.localMin.isOpen;\n    }\n    static isOpenEndActive(ae) {\n        return ae.localMin.isOpen && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpenEnd(ae.vertexTop);\n    }\n    static isOpenEnd(v) {\n        return (v.flags & ($0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.OpenStart | $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.OpenEnd)) !== $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.None;\n    }\n    static getPrevHotEdge(ae) {\n        let prev = ae.prevInAEL;\n        while(prev && ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(prev) || !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(prev)))prev = prev.prevInAEL;\n        return prev;\n    }\n    static isFront(ae) {\n        return ae === ae.outrec.frontEdge;\n    }\n    /*******************************************************************************\r\n    *  Dx:                             0(90deg)                                    *\r\n    *                                  |                                           *\r\n    *               +inf (180deg) <--- o --. -inf (0deg)                          *\r\n    *******************************************************************************/ static getDx(pt1, pt2) {\n        const dy = pt2.y - pt1.y;\n        if (dy !== 0) return (pt2.x - pt1.x) / dy;\n        if (pt2.x > pt1.x) return Number.NEGATIVE_INFINITY;\n        return Number.POSITIVE_INFINITY;\n    }\n    static topX(ae, currentY) {\n        if (currentY === ae.top.y || ae.top.x === ae.bot.x) return ae.top.x;\n        if (currentY === ae.bot.y) return ae.bot.x;\n        return ae.bot.x + Math.round(ae.dx * (currentY - ae.bot.y));\n    }\n    static isHorizontal(ae) {\n        return ae.top.y === ae.bot.y;\n    }\n    static isHeadingRightHorz(ae) {\n        return Number.NEGATIVE_INFINITY === ae.dx;\n    }\n    static isHeadingLeftHorz(ae) {\n        return Number.POSITIVE_INFINITY === ae.dx;\n    }\n    static swapActives(ae1, ae2) {\n        [ae2, ae1] = [\n            ae1,\n            ae2\n        ];\n    }\n    static getPolyType(ae) {\n        return ae.localMin.polytype;\n    }\n    static isSamePolyType(ae1, ae2) {\n        return ae1.localMin.polytype === ae2.localMin.polytype;\n    }\n    static setDx(ae) {\n        ae.dx = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getDx(ae.bot, ae.top);\n    }\n    static nextVertex(ae) {\n        if (ae.windDx > 0) return ae.vertexTop.next;\n        return ae.vertexTop.prev;\n    }\n    static prevPrevVertex(ae) {\n        if (ae.windDx > 0) return ae.vertexTop.prev.prev;\n        return ae.vertexTop.next.next;\n    }\n    static isMaxima(vertex) {\n        return (vertex.flags & $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMax) !== $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.None;\n    }\n    static isMaximaActive(ae) {\n        return $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isMaxima(ae.vertexTop);\n    }\n    static getMaximaPair(ae) {\n        let ae2 = ae.nextInAEL;\n        while(ae2){\n            if (ae2.vertexTop === ae.vertexTop) return ae2; // Found!\n            ae2 = ae2.nextInAEL;\n        }\n        return undefined;\n    }\n    static getCurrYMaximaVertex_Open(ae) {\n        let result = ae.vertexTop;\n        if (ae.windDx > 0) while(result.next.pt.y === result.pt.y && (result.flags & ($0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.OpenEnd | $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMax)) === $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.None)result = result.next;\n        else while(result.prev.pt.y === result.pt.y && (result.flags & ($0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.OpenEnd | $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMax)) === $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.None)result = result.prev;\n        if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isMaxima(result)) result = undefined; // not a maxima\n        return result;\n    }\n    static getCurrYMaximaVertex(ae) {\n        let result = ae.vertexTop;\n        if (ae.windDx > 0) while(result.next.pt.y === result.pt.y)result = result.next;\n        else while(result.prev.pt.y === result.pt.y)result = result.prev;\n        if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isMaxima(result)) result = undefined; // not a maxima\n        return result;\n    }\n    static setSides(outrec, startEdge, endEdge) {\n        outrec.frontEdge = startEdge;\n        outrec.backEdge = endEdge;\n    }\n    static swapOutrecs(ae1, ae2) {\n        const or1 = ae1.outrec;\n        const or2 = ae2.outrec;\n        if (or1 === or2) {\n            const ae = or1.frontEdge;\n            or1.frontEdge = or1.backEdge;\n            or1.backEdge = ae;\n            return;\n        }\n        if (or1) {\n            if (ae1 === or1.frontEdge) or1.frontEdge = ae2;\n            else or1.backEdge = ae2;\n        }\n        if (or2) {\n            if (ae2 === or2.frontEdge) or2.frontEdge = ae1;\n            else or2.backEdge = ae1;\n        }\n        ae1.outrec = or2;\n        ae2.outrec = or1;\n    }\n    static setOwner(outrec, newOwner) {\n        while(newOwner.owner && !newOwner.owner.pts)newOwner.owner = newOwner.owner.owner;\n        //make sure that outrec isn't an owner of newOwner\n        let tmp = newOwner;\n        while(tmp && tmp !== outrec)tmp = tmp.owner;\n        if (tmp) newOwner.owner = outrec.owner;\n        outrec.owner = newOwner;\n    }\n    static area(op) {\n        // https://en.wikipedia.org/wiki/Shoelace_formula\n        let area = 0.0;\n        let op2 = op;\n        do {\n            area += (op2.prev.pt.y + op2.pt.y) * (op2.prev.pt.x - op2.pt.x);\n            op2 = op2.next;\n        }while (op2 !== op);\n        return area * 0.5;\n    }\n    static areaTriangle(pt1, pt2, pt3) {\n        return (pt3.y + pt1.y) * (pt3.x - pt1.x) + (pt1.y + pt2.y) * (pt1.x - pt2.x) + (pt2.y + pt3.y) * (pt2.x - pt3.x);\n    }\n    static getRealOutRec(outRec) {\n        while(outRec !== undefined && outRec.pts === undefined)outRec = outRec.owner;\n        return outRec;\n    }\n    static isValidOwner(outRec, testOwner) {\n        while(testOwner !== undefined && testOwner !== outRec)testOwner = testOwner.owner;\n        return testOwner === undefined;\n    }\n    static uncoupleOutRec(ae) {\n        const outrec = ae.outrec;\n        if (outrec === undefined) return;\n        outrec.frontEdge.outrec = undefined;\n        outrec.backEdge.outrec = undefined;\n        outrec.frontEdge = undefined;\n        outrec.backEdge = undefined;\n    }\n    static outrecIsAscending(hotEdge) {\n        return hotEdge === hotEdge.outrec.frontEdge;\n    }\n    static swapFrontBackSides(outrec) {\n        // while this proc. is needed for open paths\n        // it's almost never needed for closed paths\n        const ae2 = outrec.frontEdge;\n        outrec.frontEdge = outrec.backEdge;\n        outrec.backEdge = ae2;\n        outrec.pts = outrec.pts.next;\n    }\n    static edgesAdjacentInAEL(inode) {\n        return inode.edge1.nextInAEL === inode.edge2 || inode.edge1.prevInAEL === inode.edge2;\n    }\n    clearSolutionOnly() {\n        while(this._actives)this.deleteFromAEL(this._actives);\n        this._scanlineList.clear();\n        this.disposeIntersectNodes();\n        this._outrecList.length = 0;\n        this._horzSegList.length = 0;\n        this._horzJoinList.length = 0;\n    }\n    clear() {\n        this.clearSolutionOnly();\n        this._minimaList.length = 0;\n        this._vertexList.length = 0;\n        this._currentLocMin = 0;\n        this._isSortedMinimaList = false;\n        this._hasOpenPaths = false;\n    }\n    reset() {\n        if (!this._isSortedMinimaList) {\n            this._minimaList.sort((locMin1, locMin2)=>locMin2.vertex.pt.y - locMin1.vertex.pt.y);\n            this._isSortedMinimaList = true;\n        }\n        for(let i = this._minimaList.length - 1; i >= 0; i--)this._scanlineList.add(this._minimaList[i].vertex.pt.y);\n        this._currentBotY = 0;\n        this._currentLocMin = 0;\n        this._actives = undefined;\n        this._sel = undefined;\n        this._succeeded = true;\n    }\n    insertScanline(y) {\n        this._scanlineList.add(y);\n    }\n    popScanline() {\n        return this._scanlineList.pollLast();\n    }\n    hasLocMinAtY(y) {\n        return this._currentLocMin < this._minimaList.length && this._minimaList[this._currentLocMin].vertex.pt.y == y;\n    }\n    popLocalMinima() {\n        return this._minimaList[this._currentLocMin++];\n    }\n    addLocMin(vert, polytype, isOpen) {\n        // make sure the vertex is added only once ...\n        if ((vert.flags & $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMin) != $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.None) return;\n        vert.flags |= $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.LocalMin;\n        const lm = new $0b6dbf71c0c0eea1$var$LocalMinima(vert, polytype, isOpen);\n        this._minimaList.push(lm);\n    }\n    addSubject(path) {\n        this.addPath(path, $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Subject);\n    }\n    addOpenSubject(path) {\n        this.addPath(path, $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Subject, true);\n    }\n    addClip(path) {\n        this.addPath(path, $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Clip);\n    }\n    addPath(path, polytype, isOpen = false) {\n        const tmp = [\n            path\n        ];\n        this.addPaths(tmp, polytype, isOpen);\n    }\n    addPaths(paths, polytype, isOpen = false) {\n        if (isOpen) this._hasOpenPaths = true;\n        this._isSortedMinimaList = false;\n        $0b6dbf71c0c0eea1$export$467e9e338ef38141.addPathsToVertexList(paths, polytype, isOpen, this._minimaList, this._vertexList);\n    }\n    addReuseableData(reuseableData) {\n        if (reuseableData._minimaList.length === 0) return;\n        this._isSortedMinimaList = false;\n        for (const lm of reuseableData._minimaList){\n            this._minimaList.push(new $0b6dbf71c0c0eea1$var$LocalMinima(lm.vertex, lm.polytype, lm.isOpen));\n            if (lm.isOpen) this._hasOpenPaths = true;\n        }\n    }\n    isContributingClosed(ae) {\n        switch(this._fillrule){\n            case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Positive:\n                if (ae.windCount !== 1) return false;\n                break;\n            case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Negative:\n                if (ae.windCount !== -1) return false;\n                break;\n            case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.NonZero:\n                if (Math.abs(ae.windCount) !== 1) return false;\n                break;\n        }\n        switch(this._cliptype){\n            case $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Intersection:\n                switch(this._fillrule){\n                    case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Positive:\n                        return ae.windCount2 > 0;\n                    case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Negative:\n                        return ae.windCount2 < 0;\n                    default:\n                        return ae.windCount2 !== 0;\n                }\n            case $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Union:\n                switch(this._fillrule){\n                    case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Positive:\n                        return ae.windCount2 <= 0;\n                    case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Negative:\n                        return ae.windCount2 >= 0;\n                    default:\n                        return ae.windCount2 === 0;\n                }\n            case $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Difference:\n                const result = this._fillrule === $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Positive ? ae.windCount2 <= 0 : this._fillrule === $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Negative ? ae.windCount2 >= 0 : ae.windCount2 === 0;\n                return $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPolyType(ae) === $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Subject ? result : !result;\n            case $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Xor:\n                return true;\n            default:\n                return false;\n        }\n    }\n    isContributingOpen(ae) {\n        let isInClip, isInSubj;\n        switch(this._fillrule){\n            case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Positive:\n                isInSubj = ae.windCount > 0;\n                isInClip = ae.windCount2 > 0;\n                break;\n            case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Negative:\n                isInSubj = ae.windCount < 0;\n                isInClip = ae.windCount2 < 0;\n                break;\n            default:\n                isInSubj = ae.windCount !== 0;\n                isInClip = ae.windCount2 !== 0;\n                break;\n        }\n        switch(this._cliptype){\n            case $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Intersection:\n                return isInClip;\n            case $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Union:\n                return !isInSubj && !isInClip;\n            default:\n                return !isInClip;\n        }\n    }\n    setWindCountForClosedPathEdge(ae) {\n        let ae2 = ae.prevInAEL;\n        const pt = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPolyType(ae);\n        while(ae2 !== undefined && ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPolyType(ae2) !== pt || $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae2)))ae2 = ae2.prevInAEL;\n        if (ae2 === undefined) {\n            ae.windCount = ae.windDx;\n            ae2 = this._actives;\n        } else if (this._fillrule === $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.EvenOdd) {\n            ae.windCount = ae.windDx;\n            ae.windCount2 = ae2.windCount2;\n            ae2 = ae2.nextInAEL;\n        } else {\n            // NonZero, positive, or negative filling here ...\n            // when e2's WindCnt is in the SAME direction as its WindDx,\n            // then polygon will fill on the right of 'e2' (and 'e' will be inside)\n            // nb: neither e2.WindCnt nor e2.WindDx should ever be 0.\n            if (ae2.windCount * ae2.windDx < 0) {\n                // opposite directions so 'ae' is outside 'ae2' ...\n                if (Math.abs(ae2.windCount) > 1) {\n                    // outside prev poly but still inside another.\n                    if (ae2.windDx * ae.windDx < 0) // reversing direction so use the same WC\n                    ae.windCount = ae2.windCount;\n                    else // otherwise keep 'reducing' the WC by 1 (i.e. towards 0) ...\n                    ae.windCount = ae2.windCount + ae.windDx;\n                } else // now outside all polys of same polytype so set own WC ...\n                ae.windCount = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae) ? 1 : ae.windDx;\n            } else // 'ae' must be inside 'ae2'\n            if (ae2.windDx * ae.windDx < 0) // reversing direction so use the same WC\n            ae.windCount = ae2.windCount;\n            else // otherwise keep 'increasing' the WC by 1 (i.e. away from 0) ...\n            ae.windCount = ae2.windCount + ae.windDx;\n            ae.windCount2 = ae2.windCount2;\n            ae2 = ae2.nextInAEL; // i.e. get ready to calc WindCnt2\n        }\n        if (this._fillrule === $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.EvenOdd) while(ae2 !== ae){\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPolyType(ae2) !== pt && !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae2)) ae.windCount2 = ae.windCount2 === 0 ? 1 : 0;\n            ae2 = ae2.nextInAEL;\n        }\n        else while(ae2 !== ae){\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPolyType(ae2) !== pt && !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae2)) ae.windCount2 += ae2.windDx;\n            ae2 = ae2.nextInAEL;\n        }\n    }\n    setWindCountForOpenPathEdge(ae) {\n        let ae2 = this._actives;\n        if (this._fillrule === $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.EvenOdd) {\n            let cnt1 = 0, cnt2 = 0;\n            while(ae2 !== ae){\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPolyType(ae2) === $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Clip) cnt2++;\n                else if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae2)) cnt1++;\n                ae2 = ae2.nextInAEL;\n            }\n            ae.windCount = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOdd(cnt1) ? 1 : 0;\n            ae.windCount2 = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOdd(cnt2) ? 1 : 0;\n        } else while(ae2 !== ae){\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPolyType(ae2) === $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Clip) ae.windCount2 += ae2.windDx;\n            else if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae2)) ae.windCount += ae2.windDx;\n            ae2 = ae2.nextInAEL;\n        }\n    }\n    static isValidAelOrder(resident, newcomer) {\n        if (newcomer.curX !== resident.curX) return newcomer.curX > resident.curX;\n        // get the turning direction  a1.top, a2.bot, a2.top\n        const d = $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(resident.top, newcomer.bot, newcomer.top);\n        if (d !== 0.0) return d < 0;\n        // edges must be collinear to get here\n        // for starting open paths, place them according to\n        // the direction they're about to turn\n        if (!this.isMaximaActive(resident) && resident.top.y > newcomer.top.y) return $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(newcomer.bot, resident.top, this.nextVertex(resident).pt) <= 0;\n        if (!this.isMaximaActive(newcomer) && newcomer.top.y > resident.top.y) return $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(newcomer.bot, newcomer.top, this.nextVertex(newcomer).pt) >= 0;\n        const y = newcomer.bot.y;\n        const newcomerIsLeft = newcomer.isLeftBound;\n        if (resident.bot.y !== y || resident.localMin.vertex.pt.y !== y) return newcomer.isLeftBound;\n        // resident must also have just been inserted\n        if (resident.isLeftBound !== newcomerIsLeft) return newcomerIsLeft;\n        if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(this.prevPrevVertex(resident).pt, resident.bot, resident.top) === 0) return true;\n        // compare turning direction of the alternate bound\n        return $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(this.prevPrevVertex(resident).pt, newcomer.bot, this.prevPrevVertex(newcomer).pt) > 0 === newcomerIsLeft;\n    }\n    insertLeftEdge(ae) {\n        let ae2;\n        if (!this._actives) {\n            ae.prevInAEL = undefined;\n            ae.nextInAEL = undefined;\n            this._actives = ae;\n        } else if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isValidAelOrder(this._actives, ae)) {\n            ae.prevInAEL = undefined;\n            ae.nextInAEL = this._actives;\n            this._actives.prevInAEL = ae;\n            this._actives = ae;\n        } else {\n            ae2 = this._actives;\n            while(ae2.nextInAEL && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isValidAelOrder(ae2.nextInAEL, ae))ae2 = ae2.nextInAEL;\n            //don't separate joined edges\n            if (ae2.joinWith === $0b6dbf71c0c0eea1$export$290b84559c467a5c.Right) ae2 = ae2.nextInAEL;\n            ae.nextInAEL = ae2.nextInAEL;\n            if (ae2.nextInAEL) ae2.nextInAEL.prevInAEL = ae;\n            ae.prevInAEL = ae2;\n            ae2.nextInAEL = ae;\n        }\n    }\n    static insertRightEdge(ae, ae2) {\n        ae2.nextInAEL = ae.nextInAEL;\n        if (ae.nextInAEL) ae.nextInAEL.prevInAEL = ae2;\n        ae2.prevInAEL = ae;\n        ae.nextInAEL = ae2;\n    }\n    insertLocalMinimaIntoAEL(botY) {\n        let localMinima;\n        let leftBound;\n        let rightBound;\n        // Add any local minima (if any) at BotY ...\n        // NB horizontal local minima edges should contain locMin.vertex.prev\n        while(this.hasLocMinAtY(botY)){\n            localMinima = this.popLocalMinima();\n            if ((localMinima.vertex.flags & $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.OpenStart) !== $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.None) leftBound = undefined;\n            else {\n                leftBound = new $0b6dbf71c0c0eea1$export$c3c7cbf43a3f0561();\n                leftBound.bot = localMinima.vertex.pt;\n                leftBound.curX = localMinima.vertex.pt.x;\n                leftBound.windDx = -1;\n                leftBound.vertexTop = localMinima.vertex.prev;\n                leftBound.top = localMinima.vertex.prev.pt;\n                leftBound.outrec = undefined;\n                leftBound.localMin = localMinima;\n                $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setDx(leftBound);\n            }\n            if ((localMinima.vertex.flags & $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.OpenEnd) !== $0b6dbf71c0c0eea1$export$6bbe4490a892c1c5.None) rightBound = undefined;\n            else {\n                rightBound = new $0b6dbf71c0c0eea1$export$c3c7cbf43a3f0561();\n                rightBound.bot = localMinima.vertex.pt;\n                rightBound.curX = localMinima.vertex.pt.x;\n                rightBound.windDx = 1;\n                rightBound.vertexTop = localMinima.vertex.next;\n                rightBound.top = localMinima.vertex.next.pt;\n                rightBound.outrec = undefined;\n                rightBound.localMin = localMinima;\n                $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setDx(rightBound);\n            }\n            if (leftBound && rightBound) {\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(leftBound)) {\n                    if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHeadingRightHorz(leftBound)) [rightBound, leftBound] = [\n                        leftBound,\n                        rightBound\n                    ];\n                } else if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(rightBound)) {\n                    if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHeadingLeftHorz(rightBound)) [rightBound, leftBound] = [\n                        leftBound,\n                        rightBound\n                    ];\n                } else if (leftBound.dx < rightBound.dx) [rightBound, leftBound] = [\n                    leftBound,\n                    rightBound\n                ];\n            //so when leftBound has windDx == 1, the polygon will be oriented\n            //counter-clockwise in Cartesian coords (clockwise with inverted Y).\n            } else if (leftBound === undefined) {\n                leftBound = rightBound;\n                rightBound = undefined;\n            }\n            let contributing = false;\n            leftBound.isLeftBound = true;\n            this.insertLeftEdge(leftBound);\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(leftBound)) {\n                this.setWindCountForOpenPathEdge(leftBound);\n                contributing = this.isContributingOpen(leftBound);\n            } else {\n                this.setWindCountForClosedPathEdge(leftBound);\n                contributing = this.isContributingClosed(leftBound);\n            }\n            if (rightBound) {\n                rightBound.windCount = leftBound.windCount;\n                rightBound.windCount2 = leftBound.windCount2;\n                $0b6dbf71c0c0eea1$export$33da2edff2b544f3.insertRightEdge(leftBound, rightBound);\n                if (contributing) {\n                    this.addLocalMinPoly(leftBound, rightBound, leftBound.bot, true);\n                    if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(leftBound)) this.checkJoinLeft(leftBound, leftBound.bot);\n                }\n                while(rightBound.nextInAEL && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isValidAelOrder(rightBound.nextInAEL, rightBound)){\n                    this.intersectEdges(rightBound, rightBound.nextInAEL, rightBound.bot);\n                    this.swapPositionsInAEL(rightBound, rightBound.nextInAEL);\n                }\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(rightBound)) this.pushHorz(rightBound);\n                else {\n                    this.checkJoinRight(rightBound, rightBound.bot);\n                    this.insertScanline(rightBound.top.y);\n                }\n            } else if (contributing) this.startOpenPath(leftBound, leftBound.bot);\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(leftBound)) this.pushHorz(leftBound);\n            else this.insertScanline(leftBound.top.y);\n        }\n    }\n    pushHorz(ae) {\n        ae.nextInSEL = this._sel;\n        this._sel = ae;\n    }\n    popHorz() {\n        const ae = this._sel;\n        if (this._sel === undefined) return undefined;\n        this._sel = this._sel.nextInSEL;\n        return ae;\n    }\n    addLocalMinPoly(ae1, ae2, pt, isNew = false) {\n        const outrec = this.newOutRec();\n        ae1.outrec = outrec;\n        ae2.outrec = outrec;\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae1)) {\n            outrec.owner = undefined;\n            outrec.isOpen = true;\n            if (ae1.windDx > 0) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setSides(outrec, ae1, ae2);\n            else $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setSides(outrec, ae2, ae1);\n        } else {\n            outrec.isOpen = false;\n            const prevHotEdge = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPrevHotEdge(ae1);\n            // e.windDx is the winding direction of the **input** paths\n            // and unrelated to the winding direction of output polygons.\n            // Output orientation is determined by e.outrec.frontE which is\n            // the ascending edge (see AddLocalMinPoly).\n            if (prevHotEdge) {\n                if (this._using_polytree) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setOwner(outrec, prevHotEdge.outrec);\n                outrec.owner = prevHotEdge.outrec;\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.outrecIsAscending(prevHotEdge) === isNew) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setSides(outrec, ae2, ae1);\n                else $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setSides(outrec, ae1, ae2);\n            } else {\n                outrec.owner = undefined;\n                if (isNew) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setSides(outrec, ae1, ae2);\n                else $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setSides(outrec, ae2, ae1);\n            }\n        }\n        const op = new $0b6dbf71c0c0eea1$var$OutPt(pt, outrec);\n        outrec.pts = op;\n        return op;\n    }\n    addLocalMaxPoly(ae1, ae2, pt) {\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isJoined(ae1)) this.split(ae1, pt);\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isJoined(ae2)) this.split(ae2, pt);\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isFront(ae1) === $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isFront(ae2)) {\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpenEndActive(ae1)) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.swapFrontBackSides(ae1.outrec);\n            else if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpenEndActive(ae2)) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.swapFrontBackSides(ae2.outrec);\n            else {\n                this._succeeded = false;\n                return undefined;\n            }\n        }\n        const result = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(ae1, pt);\n        if (ae1.outrec === ae2.outrec) {\n            const outrec = ae1.outrec;\n            outrec.pts = result;\n            if (this._using_polytree) {\n                const e = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPrevHotEdge(ae1);\n                if (e === undefined) outrec.owner = undefined;\n                else $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setOwner(outrec, e.outrec);\n            }\n            $0b6dbf71c0c0eea1$export$33da2edff2b544f3.uncoupleOutRec(ae1);\n        } else if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae1)) {\n            if (ae1.windDx < 0) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.joinOutrecPaths(ae1, ae2);\n            else $0b6dbf71c0c0eea1$export$33da2edff2b544f3.joinOutrecPaths(ae2, ae1);\n        } else if (ae1.outrec.idx < ae2.outrec.idx) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.joinOutrecPaths(ae1, ae2);\n        else $0b6dbf71c0c0eea1$export$33da2edff2b544f3.joinOutrecPaths(ae2, ae1);\n        return result;\n    }\n    static joinOutrecPaths(ae1, ae2) {\n        // join ae2 outrec path onto ae1 outrec path and then delete ae2 outrec path\n        // pointers. (NB Only very rarely do the joining ends share the same coords.)\n        const p1Start = ae1.outrec.pts;\n        const p2Start = ae2.outrec.pts;\n        const p1End = p1Start.next;\n        const p2End = p2Start.next;\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isFront(ae1)) {\n            p2End.prev = p1Start;\n            p1Start.next = p2End;\n            p2Start.next = p1End;\n            p1End.prev = p2Start;\n            ae1.outrec.pts = p2Start;\n            // nb: if IsOpen(e1) then e1 & e2 must be a 'maximaPair'\n            ae1.outrec.frontEdge = ae2.outrec.frontEdge;\n            if (ae1.outrec.frontEdge) ae1.outrec.frontEdge.outrec = ae1.outrec;\n        } else {\n            p1End.prev = p2Start;\n            p2Start.next = p1End;\n            p1Start.next = p2End;\n            p2End.prev = p1Start;\n            ae1.outrec.backEdge = ae2.outrec.backEdge;\n            if (ae1.outrec.backEdge) ae1.outrec.backEdge.outrec = ae1.outrec;\n        }\n        // after joining, the ae2.OutRec must contains no vertices ...\n        ae2.outrec.frontEdge = undefined;\n        ae2.outrec.backEdge = undefined;\n        ae2.outrec.pts = undefined;\n        $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setOwner(ae2.outrec, ae1.outrec);\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpenEndActive(ae1)) {\n            ae2.outrec.pts = ae1.outrec.pts;\n            ae1.outrec.pts = undefined;\n        }\n        // and ae1 and ae2 are maxima and are about to be dropped from the Actives list.\n        ae1.outrec = undefined;\n        ae2.outrec = undefined;\n    }\n    static addOutPt(ae, pt) {\n        const outrec = ae.outrec;\n        const toFront = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isFront(ae);\n        const opFront = outrec.pts;\n        const opBack = opFront.next;\n        if (toFront && pt == opFront.pt) return opFront;\n        else if (!toFront && pt == opBack.pt) return opBack;\n        const newOp = new $0b6dbf71c0c0eea1$var$OutPt(pt, outrec);\n        opBack.prev = newOp;\n        newOp.prev = opFront;\n        newOp.next = opBack;\n        opFront.next = newOp;\n        if (toFront) outrec.pts = newOp;\n        return newOp;\n    }\n    newOutRec() {\n        const result = new $0b6dbf71c0c0eea1$export$1e0666df669b1ceb(this._outrecList.length);\n        this._outrecList.push(result);\n        return result;\n    }\n    startOpenPath(ae, pt) {\n        const outrec = this.newOutRec();\n        outrec.isOpen = true;\n        if (ae.windDx > 0) {\n            outrec.frontEdge = ae;\n            outrec.backEdge = undefined;\n        } else {\n            outrec.frontEdge = undefined;\n            outrec.backEdge = ae;\n        }\n        ae.outrec = outrec;\n        const op = new $0b6dbf71c0c0eea1$var$OutPt(pt, outrec);\n        outrec.pts = op;\n        return op;\n    }\n    updateEdgeIntoAEL(ae) {\n        ae.bot = ae.top;\n        ae.vertexTop = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.nextVertex(ae);\n        ae.top = ae.vertexTop.pt;\n        ae.curX = ae.bot.x;\n        $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setDx(ae);\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isJoined(ae)) this.split(ae, ae.bot);\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(ae)) return;\n        this.insertScanline(ae.top.y);\n        this.checkJoinLeft(ae, ae.bot);\n        this.checkJoinRight(ae, ae.bot, true);\n    }\n    static findEdgeWithMatchingLocMin(e) {\n        let result = e.nextInAEL;\n        while(result){\n            if (result.localMin === e.localMin) return result;\n            if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(result) && e.bot !== result.bot) result = undefined;\n            else result = result.nextInAEL;\n        }\n        result = e.prevInAEL;\n        while(result){\n            if (result.localMin === e.localMin) return result;\n            if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(result) && e.bot !== result.bot) return undefined;\n            result = result.prevInAEL;\n        }\n        return result;\n    }\n    intersectEdges(ae1, ae2, pt) {\n        let resultOp = undefined;\n        // MANAGE OPEN PATH INTERSECTIONS SEPARATELY ...\n        if (this._hasOpenPaths && ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae1) || $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae2))) {\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae1) && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae2)) return undefined;\n            // the following line avoids duplicating quite a bit of code\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae2)) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.swapActives(ae1, ae2);\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isJoined(ae2)) this.split(ae2, pt);\n            if (this._cliptype === $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Union) {\n                if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae2)) return undefined;\n            } else if (ae2.localMin.polytype === $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Subject) return undefined;\n            switch(this._fillrule){\n                case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Positive:\n                    if (ae2.windCount !== 1) return undefined;\n                    break;\n                case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Negative:\n                    if (ae2.windCount !== -1) return undefined;\n                    break;\n                default:\n                    if (Math.abs(ae2.windCount) !== 1) return undefined;\n                    break;\n            }\n            // toggle contribution ...\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae1)) {\n                resultOp = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(ae1, pt);\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isFront(ae1)) ae1.outrec.frontEdge = undefined;\n                else ae1.outrec.backEdge = undefined;\n                ae1.outrec = undefined;\n            // horizontal edges can pass under open paths at a LocMins\n            } else if (pt === ae1.localMin.vertex.pt && !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpenEnd(ae1.localMin.vertex)) {\n                // find the other side of the LocMin and\n                // if it's 'hot' join up with it ...\n                const ae3 = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.findEdgeWithMatchingLocMin(ae1);\n                if (ae3 && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae3)) {\n                    ae1.outrec = ae3.outrec;\n                    if (ae1.windDx > 0) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setSides(ae3.outrec, ae1, ae3);\n                    else $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setSides(ae3.outrec, ae3, ae1);\n                    return ae3.outrec.pts;\n                }\n                resultOp = this.startOpenPath(ae1, pt);\n            } else resultOp = this.startOpenPath(ae1, pt);\n            return resultOp;\n        }\n        // MANAGING CLOSED PATHS FROM HERE ON\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isJoined(ae1)) this.split(ae1, pt);\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isJoined(ae2)) this.split(ae2, pt);\n        // UPDATE WINDING COUNTS...\n        let oldE1WindCount;\n        let oldE2WindCount;\n        if (ae1.localMin.polytype === ae2.localMin.polytype) {\n            if (this._fillrule === $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.EvenOdd) {\n                oldE1WindCount = ae1.windCount;\n                ae1.windCount = ae2.windCount;\n                ae2.windCount = oldE1WindCount;\n            } else {\n                if (ae1.windCount + ae2.windDx === 0) ae1.windCount = -ae1.windCount;\n                else ae1.windCount += ae2.windDx;\n                if (ae2.windCount - ae1.windDx === 0) ae2.windCount = -ae2.windCount;\n                else ae2.windCount -= ae1.windDx;\n            }\n        } else {\n            if (this._fillrule !== $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.EvenOdd) ae1.windCount2 += ae2.windDx;\n            else ae1.windCount2 = ae1.windCount2 === 0 ? 1 : 0;\n            if (this._fillrule !== $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.EvenOdd) ae2.windCount2 -= ae1.windDx;\n            else ae2.windCount2 = ae2.windCount2 === 0 ? 1 : 0;\n        }\n        switch(this._fillrule){\n            case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Positive:\n                oldE1WindCount = ae1.windCount;\n                oldE2WindCount = ae2.windCount;\n                break;\n            case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Negative:\n                oldE1WindCount = -ae1.windCount;\n                oldE2WindCount = -ae2.windCount;\n                break;\n            default:\n                oldE1WindCount = Math.abs(ae1.windCount);\n                oldE2WindCount = Math.abs(ae2.windCount);\n                break;\n        }\n        const e1WindCountIs0or1 = oldE1WindCount === 0 || oldE1WindCount === 1;\n        const e2WindCountIs0or1 = oldE2WindCount === 0 || oldE2WindCount === 1;\n        if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae1) && !e1WindCountIs0or1 || !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae2) && !e2WindCountIs0or1) return undefined;\n        // NOW PROCESS THE INTERSECTION ...\n        // if both edges are 'hot' ...\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae1) && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae2)) {\n            if (oldE1WindCount !== 0 && oldE1WindCount !== 1 || oldE2WindCount !== 0 && oldE2WindCount !== 1 || ae1.localMin.polytype !== ae2.localMin.polytype && this._cliptype !== $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Xor) resultOp = this.addLocalMaxPoly(ae1, ae2, pt);\n            else if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isFront(ae1) || ae1.outrec === ae2.outrec) {\n                // this 'else if' condition isn't strictly needed but\n                // it's sensible to split polygons that only touch at\n                // a common vertex (not at common edges).\n                resultOp = this.addLocalMaxPoly(ae1, ae2, pt);\n                this.addLocalMinPoly(ae1, ae2, pt);\n            } else {\n                // can't treat as maxima & minima\n                resultOp = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(ae1, pt);\n                $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(ae2, pt);\n                $0b6dbf71c0c0eea1$export$33da2edff2b544f3.swapOutrecs(ae1, ae2);\n            }\n        } else if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae1)) {\n            resultOp = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(ae1, pt);\n            $0b6dbf71c0c0eea1$export$33da2edff2b544f3.swapOutrecs(ae1, ae2);\n        } else if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae2)) {\n            resultOp = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(ae2, pt);\n            $0b6dbf71c0c0eea1$export$33da2edff2b544f3.swapOutrecs(ae1, ae2);\n        } else {\n            let e1Wc2;\n            let e2Wc2;\n            switch(this._fillrule){\n                case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Positive:\n                    e1Wc2 = ae1.windCount2;\n                    e2Wc2 = ae2.windCount2;\n                    break;\n                case $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95.Negative:\n                    e1Wc2 = -ae1.windCount2;\n                    e2Wc2 = -ae2.windCount2;\n                    break;\n                default:\n                    e1Wc2 = Math.abs(ae1.windCount2);\n                    e2Wc2 = Math.abs(ae2.windCount2);\n                    break;\n            }\n            if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isSamePolyType(ae1, ae2)) resultOp = this.addLocalMinPoly(ae1, ae2, pt);\n            else if (oldE1WindCount === 1 && oldE2WindCount === 1) {\n                resultOp = undefined;\n                switch(this._cliptype){\n                    case $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Union:\n                        if (e1Wc2 > 0 && e2Wc2 > 0) return undefined;\n                        resultOp = this.addLocalMinPoly(ae1, ae2, pt);\n                        break;\n                    case $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Difference:\n                        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPolyType(ae1) === $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Clip && e1Wc2 > 0 && e2Wc2 > 0 || $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getPolyType(ae1) === $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Subject && e1Wc2 <= 0 && e2Wc2 <= 0) resultOp = this.addLocalMinPoly(ae1, ae2, pt);\n                        break;\n                    case $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.Xor:\n                        resultOp = this.addLocalMinPoly(ae1, ae2, pt);\n                        break;\n                    default:\n                        if (e1Wc2 <= 0 || e2Wc2 <= 0) return undefined;\n                        resultOp = this.addLocalMinPoly(ae1, ae2, pt);\n                        break;\n                }\n            }\n        }\n        return resultOp;\n    }\n    deleteFromAEL(ae) {\n        const prev = ae.prevInAEL;\n        const next = ae.nextInAEL;\n        if (!prev && !next && ae !== this._actives) return; // already deleted\n        if (prev) prev.nextInAEL = next;\n        else this._actives = next;\n        if (next) next.prevInAEL = prev;\n    }\n    adjustCurrXAndCopyToSEL(topY) {\n        let ae = this._actives;\n        this._sel = ae;\n        while(ae){\n            ae.prevInSEL = ae.prevInAEL;\n            ae.nextInSEL = ae.nextInAEL;\n            ae.jump = ae.nextInSEL;\n            if (ae.joinWith === $0b6dbf71c0c0eea1$export$290b84559c467a5c.Left) ae.curX = ae.prevInAEL.curX; // This also avoids complications\n            else ae.curX = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.topX(ae, topY);\n            // NB don't update ae.curr.Y yet (see AddNewIntersectNode)\n            ae = ae.nextInAEL;\n        }\n    }\n    executeInternal(ct, fillRule) {\n        if (ct === $0b6dbf71c0c0eea1$export$9e3ecdefb2438757.None) return;\n        this._fillrule = fillRule;\n        this._cliptype = ct;\n        this.reset();\n        let y = this.popScanline();\n        if (y === undefined) return;\n        while(this._succeeded){\n            this.insertLocalMinimaIntoAEL(y);\n            let ae = this.popHorz();\n            while(ae){\n                this.doHorizontal(ae);\n                ae = this.popHorz();\n            }\n            if (this._horzSegList.length > 0) {\n                this.convertHorzSegsToJoins();\n                this._horzSegList.length = 0;\n            }\n            this._currentBotY = y; // bottom of scanbeam\n            y = this.popScanline();\n            if (y === undefined) break; // y new top of scanbeam\n            this.doIntersections(y);\n            this.doTopOfScanbeam(y);\n            ae = this.popHorz();\n            while(ae){\n                this.doHorizontal(ae);\n                ae = this.popHorz();\n            }\n        }\n        if (this._succeeded) this.processHorzJoins();\n    }\n    doIntersections(topY) {\n        if (this.buildIntersectList(topY)) {\n            this.processIntersectList();\n            this.disposeIntersectNodes();\n        }\n    }\n    disposeIntersectNodes() {\n        this._intersectList.length = 0;\n    }\n    addNewIntersectNode(ae1, ae2, topY) {\n        const result = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPt(ae1.bot, ae1.top, ae2.bot, ae2.top);\n        let ip = result.ip;\n        if (!result.success) ip = new $0b6dbf71c0c0eea1$export$d379afd9763b528f(ae1.curX, topY);\n        if (ip.y > this._currentBotY || ip.y < topY) {\n            const absDx1 = Math.abs(ae1.dx);\n            const absDx2 = Math.abs(ae2.dx);\n            if (absDx1 > 100 && absDx2 > 100) {\n                if (absDx1 > absDx2) ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getClosestPtOnSegment(ip, ae1.bot, ae1.top);\n                else ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getClosestPtOnSegment(ip, ae2.bot, ae2.top);\n            } else if (absDx1 > 100) ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getClosestPtOnSegment(ip, ae1.bot, ae1.top);\n            else if (absDx2 > 100) ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getClosestPtOnSegment(ip, ae2.bot, ae2.top);\n            else {\n                if (ip.y < topY) ip.y = topY;\n                else ip.y = this._currentBotY;\n                if (absDx1 < absDx2) ip.x = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.topX(ae1, ip.y);\n                else ip.x = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.topX(ae2, ip.y);\n            }\n        }\n        const node = new $0b6dbf71c0c0eea1$var$IntersectNode(ip, ae1, ae2);\n        this._intersectList.push(node);\n    }\n    static extractFromSEL(ae) {\n        const res = ae.nextInSEL;\n        if (res) res.prevInSEL = ae.prevInSEL;\n        ae.prevInSEL.nextInSEL = res;\n        return res;\n    }\n    static insert1Before2InSEL(ae1, ae2) {\n        ae1.prevInSEL = ae2.prevInSEL;\n        if (ae1.prevInSEL) ae1.prevInSEL.nextInSEL = ae1;\n        ae1.nextInSEL = ae2;\n        ae2.prevInSEL = ae1;\n    }\n    buildIntersectList(topY) {\n        if (!this._actives || !this._actives.nextInAEL) return false;\n        // Calculate edge positions at the top of the current scanbeam, and from this\n        // we will determine the intersections required to reach these new positions.\n        this.adjustCurrXAndCopyToSEL(topY);\n        // Find all edge intersections in the current scanbeam using a stable merge\n        // sort that ensures only adjacent edges are intersecting. Intersect info is\n        // stored in FIntersectList ready to be processed in ProcessIntersectList.\n        // Re merge sorts see https://stackoverflow.com/a/46319131/359538\n        let left = this._sel, right, lEnd, rEnd, currBase, prevBase, tmp;\n        while(left.jump){\n            prevBase = undefined;\n            while(left && left.jump){\n                currBase = left;\n                right = left.jump;\n                lEnd = right;\n                rEnd = right.jump;\n                left.jump = rEnd;\n                while(left !== lEnd && right !== rEnd)if (right.curX < left.curX) {\n                    tmp = right.prevInSEL;\n                    for(;;){\n                        this.addNewIntersectNode(tmp, right, topY);\n                        if (tmp === left) break;\n                        tmp = tmp.prevInSEL;\n                    }\n                    tmp = right;\n                    right = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.extractFromSEL(tmp);\n                    lEnd = right;\n                    $0b6dbf71c0c0eea1$export$33da2edff2b544f3.insert1Before2InSEL(tmp, left);\n                    if (left === currBase) {\n                        currBase = tmp;\n                        currBase.jump = rEnd;\n                        if (prevBase === undefined) this._sel = currBase;\n                        else prevBase.jump = currBase;\n                    }\n                } else left = left.nextInSEL;\n                prevBase = currBase;\n                left = rEnd;\n            }\n            left = this._sel;\n        }\n        return this._intersectList.length > 0;\n    }\n    processIntersectList() {\n        // We now have a list of intersections required so that edges will be\n        // correctly positioned at the top of the scanbeam. However, it's important\n        // that edge intersections are processed from the bottom up, but it's also\n        // crucial that intersections only occur between adjacent edges.\n        // First we do a quicksort so intersections proceed in a bottom up order ...\n        this._intersectList.sort((a, b)=>{\n            if (a.pt.y === b.pt.y) {\n                if (a.pt.x === b.pt.x) return 0;\n                return a.pt.x < b.pt.x ? -1 : 1;\n            }\n            return a.pt.y > b.pt.y ? -1 : 1;\n        });\n        // Now as we process these intersections, we must sometimes adjust the order\n        // to ensure that intersecting edges are always adjacent ...\n        for(let i = 0; i < this._intersectList.length; ++i){\n            if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.edgesAdjacentInAEL(this._intersectList[i])) {\n                let j = i + 1;\n                while(!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.edgesAdjacentInAEL(this._intersectList[j]))j++;\n                // swap\n                [this._intersectList[j], this._intersectList[i]] = [\n                    this._intersectList[i],\n                    this._intersectList[j]\n                ];\n            }\n            const node = this._intersectList[i];\n            this.intersectEdges(node.edge1, node.edge2, node.pt);\n            this.swapPositionsInAEL(node.edge1, node.edge2);\n            node.edge1.curX = node.pt.x;\n            node.edge2.curX = node.pt.x;\n            this.checkJoinLeft(node.edge2, node.pt, true);\n            this.checkJoinRight(node.edge1, node.pt, true);\n        }\n    }\n    swapPositionsInAEL(ae1, ae2) {\n        // preconditon: ae1 must be immediately to the left of ae2\n        const next = ae2.nextInAEL;\n        if (next) next.prevInAEL = ae1;\n        const prev = ae1.prevInAEL;\n        if (prev) prev.nextInAEL = ae2;\n        ae2.prevInAEL = prev;\n        ae2.nextInAEL = ae1;\n        ae1.prevInAEL = ae2;\n        ae1.nextInAEL = next;\n        if (!ae2.prevInAEL) this._actives = ae2;\n    }\n    static resetHorzDirection(horz, vertexMax) {\n        let leftX, rightX;\n        if (horz.bot.x === horz.top.x) {\n            // the horizontal edge is going nowhere ...\n            leftX = horz.curX;\n            rightX = horz.curX;\n            let ae = horz.nextInAEL;\n            while(ae && ae.vertexTop !== vertexMax)ae = ae.nextInAEL;\n            return {\n                isLeftToRight: ae !== undefined,\n                leftX: leftX,\n                rightX: rightX\n            };\n        }\n        if (horz.curX < horz.top.x) {\n            leftX = horz.curX;\n            rightX = horz.top.x;\n            return {\n                isLeftToRight: true,\n                leftX: leftX,\n                rightX: rightX\n            };\n        }\n        leftX = horz.top.x;\n        rightX = horz.curX;\n        return {\n            isLeftToRight: false,\n            leftX: leftX,\n            rightX: rightX\n        }; // right to left\n    }\n    static horzIsSpike(horz) {\n        const nextPt = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.nextVertex(horz).pt;\n        return horz.bot.x < horz.top.x !== horz.top.x < nextPt.x;\n    }\n    static trimHorz(horzEdge, preserveCollinear) {\n        let wasTrimmed = false;\n        let pt = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.nextVertex(horzEdge).pt;\n        while(pt.y === horzEdge.top.y){\n            // always trim 180 deg. spikes (in closed paths)\n            // but otherwise break if preserveCollinear = true\n            if (preserveCollinear && pt.x < horzEdge.top.x !== horzEdge.bot.x < horzEdge.top.x) break;\n            horzEdge.vertexTop = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.nextVertex(horzEdge);\n            horzEdge.top = pt;\n            wasTrimmed = true;\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isMaximaActive(horzEdge)) break;\n            pt = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.nextVertex(horzEdge).pt;\n        }\n        if (wasTrimmed) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setDx(horzEdge); // +/-infinity\n    }\n    addToHorzSegList(op) {\n        if (op.outrec.isOpen) return;\n        this._horzSegList.push(new $0b6dbf71c0c0eea1$var$HorzSegment(op));\n    }\n    getLastOp(hotEdge) {\n        const outrec = hotEdge.outrec;\n        return hotEdge === outrec.frontEdge ? outrec.pts : outrec.pts.next;\n    }\n    /*******************************************************************************\r\n    * Notes: Horizontal edges (HEs) at scanline intersections (i.e. at the top or    *\r\n    * bottom of a scanbeam) are processed as if layered.The order in which HEs     *\r\n    * are processed doesn't matter. HEs intersect with the bottom vertices of      *\r\n    * other HEs[#] and with non-horizontal edges [*]. Once these intersections     *\r\n    * are completed, intermediate HEs are 'promoted' to the next edge in their     *\r\n    * bounds, and they in turn may be intersected[%] by other HEs.                 *\r\n    *                                                                              *\r\n    * eg: 3 horizontals at a scanline:    /   |                     /           /  *\r\n    *              |                     /    |     (HE3)o ========%========== o   *\r\n    *              o ======= o(HE2)     /     |         /         /                *\r\n    *          o ============#=========*======*========#=========o (HE1)           *\r\n    *         /              |        /       |       /                            *\r\n    *******************************************************************************/ doHorizontal(horz) {\n        let pt;\n        const horzIsOpen = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(horz);\n        const Y = horz.bot.y;\n        const vertex_max = horzIsOpen ? $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getCurrYMaximaVertex_Open(horz) : $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getCurrYMaximaVertex(horz);\n        // remove 180 deg.spikes and also simplify\n        // consecutive horizontals when PreserveCollinear = true\n        if (vertex_max && !horzIsOpen && vertex_max !== horz.vertexTop) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.trimHorz(horz, this.preserveCollinear);\n        let { isLeftToRight: isLeftToRight, leftX: leftX, rightX: rightX } = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.resetHorzDirection(horz, vertex_max);\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(horz)) {\n            const op = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(horz, new $0b6dbf71c0c0eea1$export$d379afd9763b528f(horz.curX, Y));\n            this.addToHorzSegList(op);\n        }\n        for(;;){\n            // loops through consec. horizontal edges (if open)\n            let ae = isLeftToRight ? horz.nextInAEL : horz.prevInAEL;\n            while(ae){\n                if (ae.vertexTop === vertex_max) {\n                    // do this first!!\n                    if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(horz) && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isJoined(ae)) this.split(ae, ae.top);\n                    if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(horz)) {\n                        while(horz.vertexTop !== vertex_max){\n                            $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(horz, horz.top);\n                            this.updateEdgeIntoAEL(horz);\n                        }\n                        if (isLeftToRight) this.addLocalMaxPoly(horz, ae, horz.top);\n                        else this.addLocalMaxPoly(ae, horz, horz.top);\n                    }\n                    this.deleteFromAEL(ae);\n                    this.deleteFromAEL(horz);\n                    return;\n                }\n                // if horzEdge is a maxima, keep going until we reach\n                // its maxima pair, otherwise check for break conditions\n                if (vertex_max !== horz.vertexTop || $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpenEndActive(horz)) {\n                    // otherwise stop when 'ae' is beyond the end of the horizontal line\n                    if (isLeftToRight && ae.curX > rightX || !isLeftToRight && ae.curX < leftX) break;\n                    if (ae.curX === horz.top.x && !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(ae)) {\n                        pt = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.nextVertex(horz).pt;\n                        // to maximize the possibility of putting open edges into\n                        // solutions, we'll only break if it's past HorzEdge's end\n                        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae) && !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isSamePolyType(ae, horz) && !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae)) {\n                            if (isLeftToRight && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.topX(ae, pt.y) > pt.x || !isLeftToRight && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.topX(ae, pt.y) < pt.x) break;\n                        } else if (isLeftToRight && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.topX(ae, pt.y) >= pt.x || !isLeftToRight && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.topX(ae, pt.y) <= pt.x) break;\n                    }\n                }\n                pt = new $0b6dbf71c0c0eea1$export$d379afd9763b528f(ae.curX, Y);\n                if (isLeftToRight) {\n                    this.intersectEdges(horz, ae, pt);\n                    this.swapPositionsInAEL(horz, ae);\n                    horz.curX = ae.curX;\n                    ae = horz.nextInAEL;\n                } else {\n                    this.intersectEdges(ae, horz, pt);\n                    this.swapPositionsInAEL(ae, horz);\n                    horz.curX = ae.curX;\n                    ae = horz.prevInAEL;\n                }\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(horz)) this.addToHorzSegList(this.getLastOp(horz));\n            } // we've reached the end of this horizontal\n            // check if we've finished looping\n            // through consecutive horizontals\n            if (horzIsOpen && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpenEndActive(horz)) {\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(horz)) {\n                    $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(horz, horz.top);\n                    if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isFront(horz)) horz.outrec.frontEdge = undefined;\n                    else horz.outrec.backEdge = undefined;\n                    horz.outrec = undefined;\n                }\n                this.deleteFromAEL(horz);\n                return;\n            } else if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.nextVertex(horz).pt.y !== horz.top.y) break;\n            // still more horizontals in bound to process ...\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(horz)) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(horz, horz.top);\n            this.updateEdgeIntoAEL(horz);\n            if (this.preserveCollinear && !horzIsOpen && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.horzIsSpike(horz)) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.trimHorz(horz, true);\n            const result = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.resetHorzDirection(horz, vertex_max);\n            isLeftToRight = result.isLeftToRight;\n            leftX = result.leftX;\n            rightX = result.rightX;\n        }\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(horz)) {\n            const op = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(horz, horz.top);\n            this.addToHorzSegList(op);\n        }\n        this.updateEdgeIntoAEL(horz);\n    }\n    doTopOfScanbeam(y) {\n        this._sel = undefined; // _sel is reused to flag horizontals (see pushHorz below)\n        let ae = this._actives;\n        while(ae){\n            // NB 'ae' will never be horizontal here\n            if (ae.top.y === y) {\n                ae.curX = ae.top.x;\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isMaximaActive(ae)) {\n                    ae = this.doMaxima(ae); // TOP OF BOUND (MAXIMA)\n                    continue;\n                }\n                // INTERMEDIATE VERTEX ...\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae)) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(ae, ae.top);\n                this.updateEdgeIntoAEL(ae);\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(ae)) this.pushHorz(ae); // horizontals are processed later\n            } else ae.curX = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.topX(ae, y);\n            ae = ae.nextInAEL;\n        }\n    }\n    doMaxima(ae) {\n        const prevE = ae.prevInAEL;\n        let nextE = ae.nextInAEL;\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpenEndActive(ae)) {\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae)) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.addOutPt(ae, ae.top);\n            if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHorizontal(ae)) {\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae)) {\n                    if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isFront(ae)) ae.outrec.frontEdge = undefined;\n                    else ae.outrec.backEdge = undefined;\n                    ae.outrec = undefined;\n                }\n                this.deleteFromAEL(ae);\n            }\n            return nextE;\n        }\n        const maxPair = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getMaximaPair(ae);\n        if (!maxPair) return nextE; // eMaxPair is horizontal\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isJoined(ae)) this.split(ae, ae.top);\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isJoined(maxPair)) this.split(maxPair, maxPair.top);\n        // only non-horizontal maxima here.\n        // process any edges between maxima pair ...\n        while(nextE !== maxPair){\n            this.intersectEdges(ae, nextE, ae.top);\n            this.swapPositionsInAEL(ae, nextE);\n            nextE = ae.nextInAEL;\n        }\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(ae)) {\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae)) this.addLocalMaxPoly(ae, maxPair, ae.top);\n            this.deleteFromAEL(maxPair);\n            this.deleteFromAEL(ae);\n            return prevE ? prevE.nextInAEL : this._actives;\n        }\n        // here ae.nextInAel == ENext == EMaxPair ...\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(ae)) this.addLocalMaxPoly(ae, maxPair, ae.top);\n        this.deleteFromAEL(ae);\n        this.deleteFromAEL(maxPair);\n        return prevE ? prevE.nextInAEL : this._actives;\n    }\n    static isJoined(e) {\n        return e.joinWith !== $0b6dbf71c0c0eea1$export$290b84559c467a5c.None;\n    }\n    split(e, currPt) {\n        if (e.joinWith === $0b6dbf71c0c0eea1$export$290b84559c467a5c.Right) {\n            e.joinWith = $0b6dbf71c0c0eea1$export$290b84559c467a5c.None;\n            e.nextInAEL.joinWith = $0b6dbf71c0c0eea1$export$290b84559c467a5c.None;\n            this.addLocalMinPoly(e, e.nextInAEL, currPt, true);\n        } else {\n            e.joinWith = $0b6dbf71c0c0eea1$export$290b84559c467a5c.None;\n            e.prevInAEL.joinWith = $0b6dbf71c0c0eea1$export$290b84559c467a5c.None;\n            this.addLocalMinPoly(e.prevInAEL, e, currPt, true);\n        }\n    }\n    checkJoinLeft(e, pt, checkCurrX = false) {\n        const prev = e.prevInAEL;\n        if (!prev || $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(e) || $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(prev) || !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(e) || !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(prev)) return;\n        if ((pt.y < e.top.y + 2 || pt.y < prev.top.y + 2) && // avoid trivial joins\n        (e.bot.y > pt.y || prev.bot.y > pt.y)) return; // (#490)\n        if (checkCurrX) {\n            if ($0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.perpendicDistFromLineSqrd(pt, prev.bot, prev.top) > 0.25) return;\n        } else if (e.curX !== prev.curX) return;\n        if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(e.top, pt, prev.top) !== 0) return;\n        if (e.outrec.idx === prev.outrec.idx) this.addLocalMaxPoly(prev, e, pt);\n        else if (e.outrec.idx < prev.outrec.idx) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.joinOutrecPaths(e, prev);\n        else $0b6dbf71c0c0eea1$export$33da2edff2b544f3.joinOutrecPaths(prev, e);\n        prev.joinWith = $0b6dbf71c0c0eea1$export$290b84559c467a5c.Right;\n        e.joinWith = $0b6dbf71c0c0eea1$export$290b84559c467a5c.Left;\n    }\n    checkJoinRight(e, pt, checkCurrX = false) {\n        const next = e.nextInAEL;\n        if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(e) || !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(e) || $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isJoined(e) || !next || $0b6dbf71c0c0eea1$export$33da2edff2b544f3.isOpen(next) || !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isHotEdgeActive(next)) return;\n        if ((pt.y < e.top.y + 2 || pt.y < next.top.y + 2) && // avoid trivial joins\n        (e.bot.y > pt.y || next.bot.y > pt.y)) return; // (#490)\n        if (checkCurrX) {\n            if ($0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.perpendicDistFromLineSqrd(pt, next.bot, next.top) > 0.25) return;\n        } else if (e.curX !== next.curX) return;\n        if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(e.top, pt, next.top) !== 0) return;\n        if (e.outrec.idx === next.outrec.idx) this.addLocalMaxPoly(e, next, pt);\n        else if (e.outrec.idx < next.outrec.idx) $0b6dbf71c0c0eea1$export$33da2edff2b544f3.joinOutrecPaths(e, next);\n        else $0b6dbf71c0c0eea1$export$33da2edff2b544f3.joinOutrecPaths(next, e);\n        e.joinWith = $0b6dbf71c0c0eea1$export$290b84559c467a5c.Right;\n        next.joinWith = $0b6dbf71c0c0eea1$export$290b84559c467a5c.Left;\n    }\n    static fixOutRecPts(outrec) {\n        let op = outrec.pts;\n        do {\n            op.outrec = outrec;\n            op = op.next;\n        }while (op !== outrec.pts);\n    }\n    static setHorzSegHeadingForward(hs, opP, opN) {\n        if (opP.pt.x === opN.pt.x) return false;\n        if (opP.pt.x < opN.pt.x) {\n            hs.leftOp = opP;\n            hs.rightOp = opN;\n            hs.leftToRight = true;\n        } else {\n            hs.leftOp = opN;\n            hs.rightOp = opP;\n            hs.leftToRight = false;\n        }\n        return true;\n    }\n    static updateHorzSegment(hs) {\n        const op = hs.leftOp;\n        const outrec = this.getRealOutRec(op.outrec);\n        const outrecHasEdges = outrec.frontEdge !== undefined;\n        const curr_y = op.pt.y;\n        let opP = op, opN = op;\n        if (outrecHasEdges) {\n            const opA = outrec.pts, opZ = opA.next;\n            while(opP !== opZ && opP.prev.pt.y === curr_y)opP = opP.prev;\n            while(opN !== opA && opN.next.pt.y === curr_y)opN = opN.next;\n        } else {\n            while(opP.prev !== opN && opP.prev.pt.y === curr_y)opP = opP.prev;\n            while(opN.next !== opP && opN.next.pt.y === curr_y)opN = opN.next;\n        }\n        const result = this.setHorzSegHeadingForward(hs, opP, opN) && hs.leftOp.horz === undefined;\n        if (result) hs.leftOp.horz = hs;\n        else hs.rightOp = undefined; // (for sorting)\n        return result;\n    }\n    static duplicateOp(op, insert_after) {\n        const result = new $0b6dbf71c0c0eea1$var$OutPt(op.pt, op.outrec);\n        if (insert_after) {\n            result.next = op.next;\n            result.next.prev = result;\n            result.prev = op;\n            op.next = result;\n        } else {\n            result.prev = op.prev;\n            result.prev.next = result;\n            result.next = op;\n            op.prev = result;\n        }\n        return result;\n    }\n    convertHorzSegsToJoins() {\n        let k = 0;\n        for (const hs of this._horzSegList)if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.updateHorzSegment(hs)) k++;\n        if (k < 2) return;\n        this._horzSegList.sort((hs1, hs2)=>{\n            if (!hs1 || !hs2) return 0;\n            if (!hs1.rightOp) return !hs2.rightOp ? 0 : 1;\n            else if (!hs2.rightOp) return -1;\n            else return hs1.leftOp.pt.x - hs2.leftOp.pt.x;\n        });\n        for(let i = 0; i < k - 1; i++){\n            const hs1 = this._horzSegList[i];\n            // for each HorzSegment, find others that overlap\n            for(let j = i + 1; j < k; j++){\n                const hs2 = this._horzSegList[j];\n                if (hs2.leftOp.pt.x >= hs1.rightOp.pt.x || hs2.leftToRight === hs1.leftToRight || hs2.rightOp.pt.x <= hs1.leftOp.pt.x) continue;\n                const curr_y = hs1.leftOp.pt.y;\n                if (hs1.leftToRight) {\n                    while(hs1.leftOp.next.pt.y === curr_y && hs1.leftOp.next.pt.x <= hs2.leftOp.pt.x)hs1.leftOp = hs1.leftOp.next;\n                    while(hs2.leftOp.prev.pt.y === curr_y && hs2.leftOp.prev.pt.x <= hs1.leftOp.pt.x)hs2.leftOp = hs2.leftOp.prev;\n                    const join = new $0b6dbf71c0c0eea1$var$HorzJoin($0b6dbf71c0c0eea1$export$33da2edff2b544f3.duplicateOp(hs1.leftOp, true), $0b6dbf71c0c0eea1$export$33da2edff2b544f3.duplicateOp(hs2.leftOp, false));\n                    this._horzJoinList.push(join);\n                } else {\n                    while(hs1.leftOp.prev.pt.y === curr_y && hs1.leftOp.prev.pt.x <= hs2.leftOp.pt.x)hs1.leftOp = hs1.leftOp.prev;\n                    while(hs2.leftOp.next.pt.y === curr_y && hs2.leftOp.next.pt.x <= hs1.leftOp.pt.x)hs2.leftOp = hs2.leftOp.next;\n                    const join = new $0b6dbf71c0c0eea1$var$HorzJoin($0b6dbf71c0c0eea1$export$33da2edff2b544f3.duplicateOp(hs2.leftOp, true), $0b6dbf71c0c0eea1$export$33da2edff2b544f3.duplicateOp(hs1.leftOp, false));\n                    this._horzJoinList.push(join);\n                }\n            }\n        }\n    }\n    static getCleanPath(op) {\n        const result = new $0b6dbf71c0c0eea1$export$b12670b10302a8b7();\n        let op2 = op;\n        while(op2.next !== op && (op2.pt.x === op2.next.pt.x && op2.pt.x === op2.prev.pt.x || op2.pt.y === op2.next.pt.y && op2.pt.y === op2.prev.pt.y))op2 = op2.next;\n        result.push(op2.pt);\n        let prevOp = op2;\n        op2 = op2.next;\n        while(op2 !== op){\n            if ((op2.pt.x !== op2.next.pt.x || op2.pt.x !== prevOp.pt.x) && (op2.pt.y !== op2.next.pt.y || op2.pt.y !== prevOp.pt.y)) {\n                result.push(op2.pt);\n                prevOp = op2;\n            }\n            op2 = op2.next;\n        }\n        return result;\n    }\n    static pointInOpPolygon(pt, op) {\n        if (op === op.next || op.prev === op.next) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOutside;\n        let op2 = op;\n        do {\n            if (op.pt.y !== pt.y) break;\n            op = op.next;\n        }while (op !== op2);\n        if (op.pt.y === pt.y) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOutside;\n        let isAbove = op.pt.y < pt.y;\n        const startingAbove = isAbove;\n        let val = 0;\n        op2 = op.next;\n        while(op2 !== op){\n            if (isAbove) while(op2 !== op && op2.pt.y < pt.y)op2 = op2.next;\n            else while(op2 !== op && op2.pt.y > pt.y)op2 = op2.next;\n            if (op2 === op) break;\n            if (op2.pt.y === pt.y) {\n                if (op2.pt.x === pt.x || op2.pt.y === op2.prev.pt.y && pt.x < op2.prev.pt.x !== pt.x < op2.pt.x) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOn;\n                op2 = op2.next;\n                if (op2 === op) break;\n                continue;\n            }\n            if (op2.pt.x <= pt.x || op2.prev.pt.x <= pt.x) {\n                if (op2.prev.pt.x < pt.x && op2.pt.x < pt.x) val = 1 - val;\n                else {\n                    const d = $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(op2.prev.pt, op2.pt, pt);\n                    if (d === 0) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOn;\n                    if (d < 0 === isAbove) val = 1 - val;\n                }\n            }\n            isAbove = !isAbove;\n            op2 = op2.next;\n        }\n        if (isAbove !== startingAbove) {\n            const d = $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(op2.prev.pt, op2.pt, pt);\n            if (d === 0) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOn;\n            if (d < 0 === isAbove) val = 1 - val;\n        }\n        if (val === 0) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOutside;\n        else return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsInside;\n    }\n    static path1InsidePath2(op1, op2) {\n        let result;\n        let outside_cnt = 0;\n        let op = op1;\n        do {\n            result = this.pointInOpPolygon(op.pt, op2);\n            if (result === $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOutside) ++outside_cnt;\n            else if (result === $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsInside) --outside_cnt;\n            op = op.next;\n        }while (op !== op1 && Math.abs(outside_cnt) < 2);\n        if (Math.abs(outside_cnt) > 1) return outside_cnt < 0;\n        const mp = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getBoundsPath(this.getCleanPath(op1)).midPoint();\n        const path2 = this.getCleanPath(op2);\n        return $0b6dbf71c0c0eea1$export$9bad362b29d84293.pointInPolygon(mp, path2) !== $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOutside;\n    }\n    moveSplits(fromOr, toOr) {\n        if (!fromOr.splits) return;\n        toOr.splits = toOr.splits || [];\n        for (const i of fromOr.splits)toOr.splits.push(i);\n        fromOr.splits = undefined;\n    }\n    processHorzJoins() {\n        for (const j of this._horzJoinList){\n            const or1 = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getRealOutRec(j.op1.outrec);\n            let or2 = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getRealOutRec(j.op2.outrec);\n            const op1b = j.op1.next;\n            const op2b = j.op2.prev;\n            j.op1.next = j.op2;\n            j.op2.prev = j.op1;\n            op1b.prev = op2b;\n            op2b.next = op1b;\n            if (or1 === or2) {\n                or2 = this.newOutRec();\n                or2.pts = op1b;\n                $0b6dbf71c0c0eea1$export$33da2edff2b544f3.fixOutRecPts(or2);\n                if (or1.pts.outrec === or2) {\n                    or1.pts = j.op1;\n                    or1.pts.outrec = or1;\n                }\n                if (this._using_polytree) {\n                    if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.path1InsidePath2(or1.pts, or2.pts)) {\n                        const tmp = or1.pts;\n                        or1.pts = or2.pts;\n                        or2.pts = tmp;\n                        $0b6dbf71c0c0eea1$export$33da2edff2b544f3.fixOutRecPts(or1);\n                        $0b6dbf71c0c0eea1$export$33da2edff2b544f3.fixOutRecPts(or2);\n                        or2.owner = or1.owner;\n                    } else if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.path1InsidePath2(or2.pts, or1.pts)) or2.owner = or1;\n                    else or2.owner = or1.owner;\n                    or1.splits = or1.splits || [];\n                    or1.splits.push(or2.idx);\n                } else or2.owner = or1;\n            } else {\n                or2.pts = undefined;\n                if (this._using_polytree) {\n                    $0b6dbf71c0c0eea1$export$33da2edff2b544f3.setOwner(or2, or1);\n                    this.moveSplits(or2, or1);\n                } else or2.owner = or1;\n            }\n        }\n    }\n    static ptsReallyClose(pt1, pt2) {\n        return Math.abs(pt1.x - pt2.x) < 2 && Math.abs(pt1.y - pt2.y) < 2;\n    }\n    static isVerySmallTriangle(op) {\n        return op.next.next === op.prev && (this.ptsReallyClose(op.prev.pt, op.next.pt) || this.ptsReallyClose(op.pt, op.next.pt) || this.ptsReallyClose(op.pt, op.prev.pt));\n    }\n    static isValidClosedPath(op) {\n        return op !== undefined && op.next !== op && (op.next !== op.prev || !this.isVerySmallTriangle(op));\n    }\n    static disposeOutPt(op) {\n        const result = op.next === op ? undefined : op.next;\n        op.prev.next = op.next;\n        op.next.prev = op.prev;\n        return result;\n    }\n    cleanCollinear(outrec) {\n        outrec = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getRealOutRec(outrec);\n        if (outrec === undefined || outrec.isOpen) return;\n        if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isValidClosedPath(outrec.pts)) {\n            outrec.pts = undefined;\n            return;\n        }\n        let startOp = outrec.pts;\n        let op2 = startOp;\n        for(;;){\n            // NB if preserveCollinear == true, then only remove 180 deg. spikes\n            if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(op2.prev.pt, op2.pt, op2.next.pt) === 0 && (op2.pt === op2.prev.pt || op2.pt === op2.next.pt || !this.preserveCollinear || $0b6dbf71c0c0eea1$export$9bad362b29d84293.dotProduct(op2.prev.pt, op2.pt, op2.next.pt) < 0)) {\n                if (op2 === outrec.pts) outrec.pts = op2.prev;\n                op2 = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.disposeOutPt(op2);\n                if (!$0b6dbf71c0c0eea1$export$33da2edff2b544f3.isValidClosedPath(op2)) {\n                    outrec.pts = undefined;\n                    return;\n                }\n                startOp = op2;\n                continue;\n            }\n            op2 = op2.next;\n            if (op2 === startOp) break;\n        }\n        this.fixSelfIntersects(outrec);\n    }\n    doSplitOp(outrec, splitOp) {\n        // splitOp.prev <=> splitOp &&\n        // splitOp.next <=> splitOp.next.next are intersecting\n        const prevOp = splitOp.prev;\n        const nextNextOp = splitOp.next.next;\n        outrec.pts = prevOp;\n        const ip = $0b6dbf71c0c0eea1$export$9bad362b29d84293.getIntersectPoint(prevOp.pt, splitOp.pt, splitOp.next.pt, nextNextOp.pt).ip;\n        const area1 = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.area(prevOp);\n        const absArea1 = Math.abs(area1);\n        if (absArea1 < 2) {\n            outrec.pts = undefined;\n            return;\n        }\n        const area2 = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.areaTriangle(ip, splitOp.pt, splitOp.next.pt);\n        const absArea2 = Math.abs(area2);\n        // de-link splitOp and splitOp.next from the path\n        // while inserting the intersection point\n        if (ip === prevOp.pt || ip === nextNextOp.pt) {\n            nextNextOp.prev = prevOp;\n            prevOp.next = nextNextOp;\n        } else {\n            const newOp2 = new $0b6dbf71c0c0eea1$var$OutPt(ip, outrec);\n            newOp2.prev = prevOp;\n            newOp2.next = nextNextOp;\n            nextNextOp.prev = newOp2;\n            prevOp.next = newOp2;\n        }\n        // nb: area1 is the path's area *before* splitting, whereas area2 is\n        // the area of the triangle containing splitOp & splitOp.next.\n        // So the only way for these areas to have the same sign is if\n        // the split triangle is larger than the path containing prevOp or\n        // if there's more than one self=intersection.\n        if (absArea2 > 1 && (absArea2 > absArea1 || area2 > 0 === area1 > 0)) {\n            const newOutRec = this.newOutRec();\n            newOutRec.owner = outrec.owner;\n            splitOp.outrec = newOutRec;\n            splitOp.next.outrec = newOutRec;\n            const newOp = new $0b6dbf71c0c0eea1$var$OutPt(ip, newOutRec);\n            newOp.prev = splitOp.next;\n            newOp.next = splitOp;\n            newOutRec.pts = newOp;\n            splitOp.prev = newOp;\n            splitOp.next.next = newOp;\n            if (this._using_polytree) {\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.path1InsidePath2(prevOp, newOp)) {\n                    newOutRec.splits = newOutRec.splits || [];\n                    newOutRec.splits.push(outrec.idx);\n                } else {\n                    outrec.splits = outrec.splits || [];\n                    outrec.splits.push(newOutRec.idx);\n                }\n            }\n        }\n    // else { splitOp = undefined; splitOp.next = undefined; }\n    }\n    fixSelfIntersects(outrec) {\n        let op2 = outrec.pts;\n        for(;;){\n            if (op2.prev === op2.next.next) break;\n            if ($0b6dbf71c0c0eea1$export$9bad362b29d84293.segsIntersect(op2.prev.pt, op2.pt, op2.next.pt, op2.next.next.pt)) {\n                this.doSplitOp(outrec, op2);\n                if (!outrec.pts) return;\n                op2 = outrec.pts;\n                continue;\n            } else op2 = op2.next;\n            if (op2 === outrec.pts) break;\n        }\n    }\n    static buildPath(op, reverse, isOpen, path) {\n        if (op === undefined || op.next === op || !isOpen && op.next === op.prev) return false;\n        path.length = 0;\n        let lastPt;\n        let op2;\n        if (reverse) {\n            lastPt = op.pt;\n            op2 = op.prev;\n        } else {\n            op = op.next;\n            lastPt = op.pt;\n            op2 = op.next;\n        }\n        path.push(lastPt);\n        while(op2 !== op){\n            if (op2.pt !== lastPt) {\n                lastPt = op2.pt;\n                path.push(lastPt);\n            }\n            if (reverse) op2 = op2.prev;\n            else op2 = op2.next;\n        }\n        if (path.length === 3 && this.isVerySmallTriangle(op2)) return false;\n        else return true;\n    }\n    buildPaths(solutionClosed, solutionOpen) {\n        solutionClosed.length = 0;\n        solutionOpen.length = 0;\n        let i = 0;\n        while(i < this._outrecList.length){\n            const outrec = this._outrecList[i++];\n            if (!outrec.pts) continue;\n            const path = new $0b6dbf71c0c0eea1$export$b12670b10302a8b7();\n            if (outrec.isOpen) {\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.buildPath(outrec.pts, this.reverseSolution, true, path)) solutionOpen.push(path);\n            } else {\n                this.cleanCollinear(outrec);\n                // closed paths should always return a Positive orientation\n                // except when reverseSolution == true\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.buildPath(outrec.pts, this.reverseSolution, false, path)) solutionClosed.push(path);\n            }\n        }\n        return true;\n    }\n    static getBoundsPath(path) {\n        if (path.length === 0) return new $0b6dbf71c0c0eea1$export$e7ab2e89a2fb5a6f();\n        const result = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.InvalidRect64;\n        for (const pt of path){\n            if (pt.x < result.left) result.left = pt.x;\n            if (pt.x > result.right) result.right = pt.x;\n            if (pt.y < result.top) result.top = pt.y;\n            if (pt.y > result.bottom) result.bottom = pt.y;\n        }\n        return result;\n    }\n    checkBounds(outrec) {\n        if (outrec.pts === undefined) return false;\n        if (!outrec.bounds.isEmpty()) return true;\n        this.cleanCollinear(outrec);\n        if (outrec.pts === undefined || !$0b6dbf71c0c0eea1$export$33da2edff2b544f3.buildPath(outrec.pts, this.reverseSolution, false, outrec.path)) return false;\n        outrec.bounds = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getBoundsPath(outrec.path);\n        return true;\n    }\n    checkSplitOwner(outrec, splits) {\n        for (const i of splits){\n            const split = $0b6dbf71c0c0eea1$export$33da2edff2b544f3.getRealOutRec(this._outrecList[i]);\n            if (split === undefined || split === outrec || split.recursiveSplit === outrec) continue;\n            split.recursiveSplit = outrec; //#599\n            if (split.splits !== undefined && this.checkSplitOwner(outrec, split.splits)) return true;\n            if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.isValidOwner(outrec, split) && this.checkBounds(split) && split.bounds.containsRect(outrec.bounds) && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.path1InsidePath2(outrec.pts, split.pts)) {\n                outrec.owner = split; //found in split\n                return true;\n            }\n        }\n        return false;\n    }\n    recursiveCheckOwners(outrec, polypath) {\n        // pre-condition: outrec will have valid bounds\n        // post-condition: if a valid path, outrec will have a polypath\n        if (outrec.polypath !== undefined || outrec.bounds.isEmpty()) return;\n        while(outrec.owner !== undefined){\n            if (outrec.owner.splits !== undefined && this.checkSplitOwner(outrec, outrec.owner.splits)) break;\n            else if (outrec.owner.pts !== undefined && this.checkBounds(outrec.owner) && $0b6dbf71c0c0eea1$export$33da2edff2b544f3.path1InsidePath2(outrec.pts, outrec.owner.pts)) break;\n            outrec.owner = outrec.owner.owner;\n        }\n        if (outrec.owner !== undefined) {\n            if (outrec.owner.polypath === undefined) this.recursiveCheckOwners(outrec.owner, polypath);\n            outrec.polypath = outrec.owner.polypath.addChild(outrec.path);\n        } else outrec.polypath = polypath.addChild(outrec.path);\n    }\n    buildTree(polytree, solutionOpen) {\n        polytree.clear();\n        solutionOpen.length = 0;\n        let i = 0;\n        while(i < this._outrecList.length){\n            const outrec = this._outrecList[i++];\n            if (outrec.pts === undefined) continue;\n            if (outrec.isOpen) {\n                const open_path = new $0b6dbf71c0c0eea1$export$b12670b10302a8b7();\n                if ($0b6dbf71c0c0eea1$export$33da2edff2b544f3.buildPath(outrec.pts, this.reverseSolution, true, open_path)) solutionOpen.push(open_path);\n                continue;\n            }\n            if (this.checkBounds(outrec)) this.recursiveCheckOwners(outrec, polytree);\n        }\n    }\n    getBounds() {\n        const bounds = $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.InvalidRect64;\n        for (const t of this._vertexList){\n            let v = t;\n            do {\n                if (v.pt.x < bounds.left) bounds.left = v.pt.x;\n                if (v.pt.x > bounds.right) bounds.right = v.pt.x;\n                if (v.pt.y < bounds.top) bounds.top = v.pt.y;\n                if (v.pt.y > bounds.bottom) bounds.bottom = v.pt.y;\n                v = v.next;\n            }while (v !== t);\n        }\n        return bounds.isEmpty() ? new $0b6dbf71c0c0eea1$export$e7ab2e89a2fb5a6f(0, 0, 0, 0) : bounds;\n    }\n}\nclass $0b6dbf71c0c0eea1$export$389255fe4ace408b extends $0b6dbf71c0c0eea1$export$33da2edff2b544f3 {\n    addPath(path, polytype, isOpen = false) {\n        super.addPath(path, polytype, isOpen);\n    }\n    addReusableData(reusableData) {\n        super.addReuseableData(reusableData);\n    }\n    addPaths(paths, polytype, isOpen = false) {\n        super.addPaths(paths, polytype, isOpen);\n    }\n    addSubjectPaths(paths) {\n        this.addPaths(paths, $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Subject);\n    }\n    addOpenSubjectPaths(paths) {\n        this.addPaths(paths, $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Subject, true);\n    }\n    addClipPaths(paths) {\n        this.addPaths(paths, $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19.Clip);\n    }\n    execute(clipType, fillRule, solutionClosed, solutionOpen = new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9()) {\n        solutionClosed.length = 0;\n        solutionOpen.length = 0;\n        try {\n            this.executeInternal(clipType, fillRule);\n            this.buildPaths(solutionClosed, solutionOpen);\n        } catch (error) {\n            this._succeeded = false;\n        }\n        this.clearSolutionOnly();\n        return this._succeeded;\n    }\n    executePolyTree(clipType, fillRule, polytree, openPaths = new $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9()) {\n        polytree.clear();\n        openPaths.length = 0;\n        this._using_polytree = true;\n        try {\n            this.executeInternal(clipType, fillRule);\n            this.buildTree(polytree, openPaths);\n        } catch (error) {\n            this._succeeded = false;\n        }\n        this.clearSolutionOnly();\n        return this._succeeded;\n    }\n}\nclass $0b6dbf71c0c0eea1$export$106ec032583e753f {\n    get isHole() {\n        return this.getIsHole();\n    }\n    constructor(parent){\n        this.children = [];\n        this.forEach = this.children.forEach;\n        this._parent = parent;\n    }\n    getLevel() {\n        let result = 0;\n        let pp = this._parent;\n        while(pp !== undefined){\n            ++result;\n            pp = pp._parent;\n        }\n        return result;\n    }\n    get level() {\n        return this.getLevel();\n    }\n    getIsHole() {\n        const lvl = this.getLevel();\n        return lvl !== 0 && (lvl & 1) === 0;\n    }\n    get count() {\n        return this.children.length;\n    }\n    clear() {\n        this.children.length = 0;\n    }\n} // end of PolyPathBase class\nclass $0b6dbf71c0c0eea1$export$da0488db9930c0ed extends $0b6dbf71c0c0eea1$export$106ec032583e753f {\n    constructor(parent){\n        super(parent);\n    }\n    addChild(p) {\n        const newChild = new $0b6dbf71c0c0eea1$export$da0488db9930c0ed(this);\n        newChild.polygon = p;\n        this.children.push(newChild);\n        return newChild;\n    }\n    get(index) {\n        if (index < 0 || index >= this.children.length) throw new Error(\"InvalidOperationException\");\n        return this.children[index];\n    }\n    child(index) {\n        if (index < 0 || index >= this.children.length) throw new Error(\"InvalidOperationException\");\n        return this.children[index];\n    }\n    area() {\n        let result = this.polygon ? $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908.area(this.polygon) : 0;\n        for (const polyPathBase of this.children){\n            const child = polyPathBase;\n            result += child.area();\n        }\n        return result;\n    }\n}\nclass $0b6dbf71c0c0eea1$export$a6691aab770c5bdb extends $0b6dbf71c0c0eea1$export$da0488db9930c0ed {\n}\nclass $0b6dbf71c0c0eea1$export$d4a89d8e4fb761df extends Error {\n    constructor(description){\n        super(description);\n    }\n}\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  26 July 2023                                                    *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  Core structures and functions for the Clipper Library           *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/ //\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\n// Removed support for USINGZ\n//\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\n//\n// Note: all clipping operations except for Difference are commutative.\nvar $0b6dbf71c0c0eea1$export$9e3ecdefb2438757;\n(function(ClipType) {\n    ClipType[ClipType[\"None\"] = 0] = \"None\";\n    ClipType[ClipType[\"Intersection\"] = 1] = \"Intersection\";\n    ClipType[ClipType[\"Union\"] = 2] = \"Union\";\n    ClipType[ClipType[\"Difference\"] = 3] = \"Difference\";\n    ClipType[ClipType[\"Xor\"] = 4] = \"Xor\";\n})($0b6dbf71c0c0eea1$export$9e3ecdefb2438757 || ($0b6dbf71c0c0eea1$export$9e3ecdefb2438757 = {}));\nvar $0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19;\n(function(PathType) {\n    PathType[PathType[\"Subject\"] = 0] = \"Subject\";\n    PathType[PathType[\"Clip\"] = 1] = \"Clip\";\n})($0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19 || ($0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19 = {}));\n// By far the most widely used filling rules for polygons are EvenOdd\n// and NonZero, sometimes called Alternate and Winding respectively.\n// https://en.wikipedia.org/wiki/Nonzero-rule\nvar $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95;\n(function(FillRule) {\n    FillRule[FillRule[\"EvenOdd\"] = 0] = \"EvenOdd\";\n    FillRule[FillRule[\"NonZero\"] = 1] = \"NonZero\";\n    FillRule[FillRule[\"Positive\"] = 2] = \"Positive\";\n    FillRule[FillRule[\"Negative\"] = 3] = \"Negative\";\n})($0b6dbf71c0c0eea1$export$f26b42c94e8a4f95 || ($0b6dbf71c0c0eea1$export$f26b42c94e8a4f95 = {}));\n// PointInPolygon\nvar $0b6dbf71c0c0eea1$export$6a3f4acf2fce52a0;\n(function(PipResult) {\n    PipResult[PipResult[\"Inside\"] = 0] = \"Inside\";\n    PipResult[PipResult[\"Outside\"] = 1] = \"Outside\";\n    PipResult[PipResult[\"OnEdge\"] = 2] = \"OnEdge\";\n})($0b6dbf71c0c0eea1$export$6a3f4acf2fce52a0 || ($0b6dbf71c0c0eea1$export$6a3f4acf2fce52a0 = {}));\nclass $0b6dbf71c0c0eea1$export$b12670b10302a8b7 extends Array {\n}\nclass $0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9 extends Array {\n}\nclass $0b6dbf71c0c0eea1$export$e7ab2e89a2fb5a6f {\n    constructor(lOrIsValidOrRec, t, r, b){\n        if (typeof lOrIsValidOrRec === \"boolean\") {\n            if (lOrIsValidOrRec) {\n                this.left = 0;\n                this.top = 0;\n                this.right = 0;\n                this.bottom = 0;\n            } else {\n                this.left = Number.MAX_SAFE_INTEGER;\n                this.top = Number.MAX_SAFE_INTEGER;\n                this.right = Number.MIN_SAFE_INTEGER;\n                this.bottom = Number.MIN_SAFE_INTEGER;\n            }\n        } else if (typeof lOrIsValidOrRec === \"number\") {\n            this.left = lOrIsValidOrRec;\n            this.top = t;\n            this.right = r;\n            this.bottom = b;\n        } else {\n            this.left = lOrIsValidOrRec.left;\n            this.top = lOrIsValidOrRec.top;\n            this.right = lOrIsValidOrRec.right;\n            this.bottom = lOrIsValidOrRec.bottom;\n        }\n    }\n    get width() {\n        return this.right - this.left;\n    }\n    set width(value) {\n        this.right = this.left + value;\n    }\n    get height() {\n        return this.bottom - this.top;\n    }\n    set height(value) {\n        this.bottom = this.top + value;\n    }\n    isEmpty() {\n        return this.bottom <= this.top || this.right <= this.left;\n    }\n    midPoint() {\n        return new $0b6dbf71c0c0eea1$export$d379afd9763b528f((this.left + this.right) / 2, (this.top + this.bottom) / 2);\n    }\n    contains(pt) {\n        return pt.x > this.left && pt.x < this.right && pt.y > this.top && pt.y < this.bottom;\n    }\n    containsRect(rec) {\n        return rec.left >= this.left && rec.right <= this.right && rec.top >= this.top && rec.bottom <= this.bottom;\n    }\n    intersects(rec) {\n        return Math.max(this.left, rec.left) <= Math.min(this.right, rec.right) && Math.max(this.top, rec.top) <= Math.min(this.bottom, rec.bottom);\n    }\n    asPath() {\n        const result = new $0b6dbf71c0c0eea1$export$b12670b10302a8b7();\n        result.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(this.left, this.top));\n        result.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(this.right, this.top));\n        result.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(this.right, this.bottom));\n        result.push(new $0b6dbf71c0c0eea1$export$d379afd9763b528f(this.left, this.bottom));\n        return result;\n    }\n}\nclass $0b6dbf71c0c0eea1$export$d379afd9763b528f {\n    constructor(xOrPt, yOrScale){\n        if (typeof xOrPt === \"number\" && typeof yOrScale === \"number\") {\n            this.x = Math.round(xOrPt);\n            this.y = Math.round(yOrScale);\n        } else {\n            const pt = xOrPt;\n            if (yOrScale !== undefined) {\n                this.x = Math.round(pt.x * yOrScale);\n                this.y = Math.round(pt.y * yOrScale);\n            } else {\n                this.x = pt.x;\n                this.y = pt.y;\n            }\n        //} else {\n        //  const pt = xOrPt as Point64\n        //  this.x = Math.round((<IPoint64>xOrPt).x * (yOrScale || 1));\n        //  this.y = Math.round((<IPoint64>xOrPt).y * (yOrScale || 1));\n        }\n    }\n    static equals(lhs, rhs) {\n        return lhs.x === rhs.x && lhs.y === rhs.y;\n    }\n    static notEquals(lhs, rhs) {\n        return lhs.x !== rhs.x || lhs.y !== rhs.y;\n    }\n    static add(lhs, rhs) {\n        return new $0b6dbf71c0c0eea1$export$d379afd9763b528f(lhs.x + rhs.x, lhs.y + rhs.y);\n    }\n    static subtract(lhs, rhs) {\n        return new $0b6dbf71c0c0eea1$export$d379afd9763b528f(lhs.x - rhs.x, lhs.y - rhs.y);\n    }\n    toString() {\n        return `${this.x},${this.y} `;\n    }\n    equals(obj) {\n        if (obj instanceof $0b6dbf71c0c0eea1$export$d379afd9763b528f) return $0b6dbf71c0c0eea1$export$d379afd9763b528f.equals(this, obj);\n        return false;\n    }\n}\nclass $0b6dbf71c0c0eea1$export$9bad362b29d84293 {\n    static checkPrecision(precision) {\n        if (precision < -8 || precision > 8) throw new Error(this.precision_range_error);\n    }\n    static isAlmostZero(value) {\n        return Math.abs(value) <= this.floatingPointTolerance;\n    }\n    static crossProduct(pt1, pt2, pt3) {\n        return (pt2.x - pt1.x) * (pt3.y - pt2.y) - (pt2.y - pt1.y) * (pt3.x - pt2.x);\n    }\n    static dotProduct(pt1, pt2, pt3) {\n        return (pt2.x - pt1.x) * (pt3.x - pt2.x) + (pt2.y - pt1.y) * (pt3.y - pt2.y);\n    }\n    static checkCastInt64(val) {\n        if (val >= this.max_coord || val <= this.min_coord) return this.Invalid64;\n        return Math.round(val);\n    }\n    static getIntersectPt(ln1a, ln1b, ln2a, ln2b) {\n        const dy1 = ln1b.y - ln1a.y;\n        const dx1 = ln1b.x - ln1a.x;\n        const dy2 = ln2b.y - ln2a.y;\n        const dx2 = ln2b.x - ln2a.x;\n        const det = dy1 * dx2 - dy2 * dx1;\n        let ip;\n        if (det === 0.0) {\n            ip = new $0b6dbf71c0c0eea1$export$d379afd9763b528f(0, 0);\n            return {\n                ip: ip,\n                success: false\n            };\n        }\n        const t = ((ln1a.x - ln2a.x) * dy2 - (ln1a.y - ln2a.y) * dx2) / det;\n        if (t <= 0.0) ip = ln1a;\n        else if (t >= 1.0) ip = ln1b;\n        else ip = new $0b6dbf71c0c0eea1$export$d379afd9763b528f(ln1a.x + t * dx1, ln1a.y + t * dy1);\n        return {\n            ip: ip,\n            success: true\n        };\n    }\n    static getIntersectPoint(ln1a, ln1b, ln2a, ln2b) {\n        const dy1 = ln1b.y - ln1a.y;\n        const dx1 = ln1b.x - ln1a.x;\n        const dy2 = ln2b.y - ln2a.y;\n        const dx2 = ln2b.x - ln2a.x;\n        const det = dy1 * dx2 - dy2 * dx1;\n        let ip;\n        if (det === 0.0) {\n            ip = new $0b6dbf71c0c0eea1$export$d379afd9763b528f(0, 0);\n            return {\n                ip: ip,\n                success: false\n            };\n        }\n        const t = ((ln1a.x - ln2a.x) * dy2 - (ln1a.y - ln2a.y) * dx2) / det;\n        if (t <= 0.0) ip = ln1a;\n        else if (t >= 1.0) ip = ln2a;\n        else ip = new $0b6dbf71c0c0eea1$export$d379afd9763b528f(ln1a.x + t * dx1, ln1a.y + t * dy1);\n        return {\n            ip: ip,\n            success: true\n        };\n    }\n    static segsIntersect(seg1a, seg1b, seg2a, seg2b, inclusive = false) {\n        if (inclusive) {\n            const res1 = $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(seg1a, seg2a, seg2b);\n            const res2 = $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(seg1b, seg2a, seg2b);\n            if (res1 * res2 > 0) return false;\n            const res3 = $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(seg2a, seg1a, seg1b);\n            const res4 = $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(seg2b, seg1a, seg1b);\n            if (res3 * res4 > 0) return false;\n            return res1 !== 0 || res2 !== 0 || res3 !== 0 || res4 !== 0;\n        } else return $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(seg1a, seg2a, seg2b) * $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(seg1b, seg2a, seg2b) < 0 && $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(seg2a, seg1a, seg1b) * $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(seg2b, seg1a, seg1b) < 0;\n    }\n    static getClosestPtOnSegment(offPt, seg1, seg2) {\n        if (seg1.x === seg2.x && seg1.y === seg2.y) return seg1;\n        const dx = seg2.x - seg1.x;\n        const dy = seg2.y - seg1.y;\n        let q = ((offPt.x - seg1.x) * dx + (offPt.y - seg1.y) * dy) / (dx * dx + dy * dy);\n        if (q < 0) q = 0;\n        else if (q > 1) q = 1;\n        return new $0b6dbf71c0c0eea1$export$d379afd9763b528f(seg1.x + Math.round(q * dx), seg1.y + Math.round(q * dy));\n    }\n    static pointInPolygon(pt, polygon) {\n        const len = polygon.length;\n        let start = 0;\n        if (len < 3) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOutside;\n        while(start < len && polygon[start].y === pt.y)start++;\n        if (start === len) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOutside;\n        let d = 0;\n        let isAbove = polygon[start].y < pt.y;\n        const startingAbove = isAbove;\n        let val = 0;\n        let i = start + 1;\n        let end = len;\n        for(;;){\n            if (i === end) {\n                if (end === 0 || start === 0) break;\n                end = start;\n                i = 0;\n            }\n            if (isAbove) {\n                while(i < end && polygon[i].y < pt.y)i++;\n                if (i === end) continue;\n            } else {\n                while(i < end && polygon[i].y > pt.y)i++;\n                if (i === end) continue;\n            }\n            const curr = polygon[i];\n            const prev = i > 0 ? polygon[i - 1] : polygon[len - 1];\n            if (curr.y === pt.y) {\n                if (curr.x === pt.x || curr.y === prev.y && pt.x < prev.x !== pt.x < curr.x) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOn;\n                i++;\n                if (i === start) break;\n                continue;\n            }\n            if (pt.x < curr.x && pt.x < prev.x) ;\n            else if (pt.x > prev.x && pt.x > curr.x) val = 1 - val; // toggle val\n            else {\n                d = $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(prev, curr, pt);\n                if (d === 0) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOn;\n                if (d < 0 === isAbove) val = 1 - val;\n            }\n            isAbove = !isAbove;\n            i++;\n        }\n        if (isAbove !== startingAbove) {\n            if (i === len) i = 0;\n            else d = $0b6dbf71c0c0eea1$export$9bad362b29d84293.crossProduct(polygon[i - 1], polygon[i], pt);\n            if (d === 0) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOn;\n            if (d < 0 === isAbove) val = 1 - val;\n        }\n        if (val === 0) return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsOutside;\n        return $0b6dbf71c0c0eea1$export$20896d302a4e5029.IsInside;\n    }\n}\n$0b6dbf71c0c0eea1$export$9bad362b29d84293.MaxInt64 = 9223372036854775807;\n$0b6dbf71c0c0eea1$export$9bad362b29d84293.MaxCoord = $0b6dbf71c0c0eea1$export$9bad362b29d84293.MaxInt64 / 4;\n$0b6dbf71c0c0eea1$export$9bad362b29d84293.max_coord = $0b6dbf71c0c0eea1$export$9bad362b29d84293.MaxCoord;\n$0b6dbf71c0c0eea1$export$9bad362b29d84293.min_coord = -$0b6dbf71c0c0eea1$export$9bad362b29d84293.MaxCoord;\n$0b6dbf71c0c0eea1$export$9bad362b29d84293.Invalid64 = $0b6dbf71c0c0eea1$export$9bad362b29d84293.MaxInt64;\n$0b6dbf71c0c0eea1$export$9bad362b29d84293.defaultArcTolerance = 0.25;\n$0b6dbf71c0c0eea1$export$9bad362b29d84293.floatingPointTolerance = 1E-12;\n$0b6dbf71c0c0eea1$export$9bad362b29d84293.defaultMinimumEdgeLength = 0.1;\n$0b6dbf71c0c0eea1$export$9bad362b29d84293.precision_range_error = \"Error: Precision is out of range.\";\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\nconst $00adfa846be5871c$var$DIRECTION_EPSILON = 1e-3;\nconst $00adfa846be5871c$var$DIST_EPSILON = 1e2;\nfunction $00adfa846be5871c$var$sameDirection(p0, p1, p2) {\n    const dx1 = p1.x - p0.x;\n    const dy1 = p1.y - p0.y;\n    const dx2 = p2.x - p1.x;\n    const dy2 = p2.y - p1.y;\n    const s1 = dx1 / dy1;\n    const s2 = dx2 / dy2;\n    return Math.abs(s1 - s2) < $00adfa846be5871c$var$DIRECTION_EPSILON;\n}\nfunction $00adfa846be5871c$var$areClose(p0, p1) {\n    const dx = p1.x - p0.x;\n    const dy = p1.y - p0.y;\n    return Math.sqrt(dx * dx + dy * dy) < $00adfa846be5871c$var$DIST_EPSILON;\n}\nfunction $00adfa846be5871c$var$areEqual(p0, p1) {\n    return p0.x === p1.x && p0.y === p1.y;\n}\nfunction $00adfa846be5871c$export$a1384fe5bb05e0aa(points) {\n    for(let k = 0; k < points.length; k++){\n        // remove points that are equal or very close to each other\n        const v = points[k];\n        while(true){\n            const k1 = k + 1;\n            if (points.length > k1 && ($00adfa846be5871c$var$areEqual(v, points[k1]) || $00adfa846be5871c$var$areClose(v, points[k1]))) points.splice(k1, 1);\n            else break;\n        }\n        // join lines that are almost the same direction\n        while(true){\n            const k1 = k + 1;\n            const k2 = k + 2;\n            if (points.length > k2 && $00adfa846be5871c$var$sameDirection(v, points[k1], points[k2])) points.splice(k + 1, 1);\n            else break;\n        }\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\nfunction $60fc547e70fa748b$var$xzToXzCopy(v, target) {\n    target.x = v.x;\n    target.y = v.z;\n}\nfunction $60fc547e70fa748b$var$epsEquals(a, b) {\n    return Math.abs(a - b) <= 500;\n}\nfunction $60fc547e70fa748b$var$vectorEpsEquals(v0, v1) {\n    return $60fc547e70fa748b$var$epsEquals(v0.x, v1.x) && $60fc547e70fa748b$var$epsEquals(v0.y, v1.y) && $60fc547e70fa748b$var$epsEquals(v0.z, v1.z);\n}\nfunction $60fc547e70fa748b$export$a4592ad7ee5e85f(tri, paths) {\n    const indices = [\n        \"a\",\n        \"b\",\n        \"c\"\n    ];\n    const edges = [\n        new (0, $e06gU.Line3)(),\n        new (0, $e06gU.Line3)(),\n        new (0, $e06gU.Line3)()\n    ];\n    const line = new (0, $e06gU.Line3)();\n    const ray = new (0, $e06gU.Line3)();\n    ray.start.set(0, 0, 0).addScaledVector(tri.a, 1 / 3).addScaledVector(tri.b, 1 / 3).addScaledVector(tri.c, 1 / 3);\n    $60fc547e70fa748b$var$xzToXzCopy(ray.start, ray.start);\n    ray.end.copy(ray.start);\n    ray.end.y += 1e10;\n    // get all triangle edges\n    for(let i = 0; i < 3; i++){\n        const i1 = (i + 1) % 3;\n        const p0 = tri[indices[i]];\n        const p1 = tri[indices[i1]];\n        const edge = edges[i];\n        $60fc547e70fa748b$var$xzToXzCopy(p0, edge.start);\n        $60fc547e70fa748b$var$xzToXzCopy(p1, edge.end);\n    }\n    let crossCount = 0;\n    for(let p = 0, pl = paths.length; p < pl; p++){\n        const points = paths[p];\n        for(let i = 0, l = points.length; i < l; i++){\n            const i1 = (i + 1) % l;\n            line.start.copy(points[i]);\n            line.start.z = 0;\n            line.end.copy(points[i1]);\n            line.end.z = 0;\n            if ($60fc547e70fa748b$var$lineCrossesLine(ray, line)) crossCount++;\n            for(let e = 0; e < 3; e++){\n                const edge = edges[e];\n                if ($60fc547e70fa748b$var$lineCrossesLine(edge, line) || $60fc547e70fa748b$var$vectorEpsEquals(edge.start, line.start) || $60fc547e70fa748b$var$vectorEpsEquals(edge.end, line.end) || $60fc547e70fa748b$var$vectorEpsEquals(edge.end, line.start) || $60fc547e70fa748b$var$vectorEpsEquals(edge.start, line.end)) return false;\n            }\n        }\n    }\n    return crossCount % 2 === 1;\n}\n// https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\nfunction $60fc547e70fa748b$var$lineCrossesLine(l1, l2) {\n    function ccw(A, B, C) {\n        return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);\n    }\n    const A = l1.start;\n    const B = l1.end;\n    const C = l2.start;\n    const D = l2.end;\n    return ccw(A, C, D) !== ccw(B, C, D) && ccw(A, B, C) !== ccw(A, B, D);\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\nfunction $2683a3650d27fd1c$export$c56c51fae37b2d63(geometry) {\n    const { index: index } = geometry;\n    const posAttr = geometry.attributes.position;\n    return index ? index.count / 3 : posAttr.count / 3;\n}\n\n\nconst $00d3e1a2b175655e$var$_tri = new (0, $e06gU.Triangle)();\nfunction $00d3e1a2b175655e$export$22df3f56fb458152(geometry) {\n    const index = geometry.index;\n    const posAttr = geometry.attributes.position;\n    const triCount = (0, $2683a3650d27fd1c$export$c56c51fae37b2d63)(geometry);\n    return new Array(triCount).fill().map((v, i)=>{\n        let i0 = i * 3 + 0;\n        let i1 = i * 3 + 1;\n        let i2 = i * 3 + 2;\n        if (index) {\n            i0 = index.getX(i0);\n            i1 = index.getX(i1);\n            i2 = index.getX(i2);\n        }\n        $00d3e1a2b175655e$var$_tri.a.fromBufferAttribute(posAttr, i0);\n        $00d3e1a2b175655e$var$_tri.b.fromBufferAttribute(posAttr, i1);\n        $00d3e1a2b175655e$var$_tri.c.fromBufferAttribute(posAttr, i2);\n        $00d3e1a2b175655e$var$_tri.a.y = 0;\n        $00d3e1a2b175655e$var$_tri.b.y = 0;\n        $00d3e1a2b175655e$var$_tri.c.y = 0;\n        // get the projected area of the triangle to sort largest triangles first\n        return {\n            area: $00d3e1a2b175655e$var$_tri.getArea(),\n            index: i\n        };\n    }).sort((a, b)=>{\n        // sort the triangles largest to smallest\n        return b.area - a.area;\n    }).map((o)=>{\n        // map to the triangle index\n        return o.index;\n    });\n}\n\n\n\nconst $b7cc2dc72cc279b6$var$AREA_EPSILON = 1e-8;\nconst $b7cc2dc72cc279b6$var$UP_VECTOR = /* @__PURE__ */ new (0, $e06gU.Vector3)(0, 1, 0);\nconst $b7cc2dc72cc279b6$var$_tri = /* @__PURE__ */ new (0, $e06gU.Triangle)();\nconst $b7cc2dc72cc279b6$var$_normal = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $b7cc2dc72cc279b6$var$_center = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $b7cc2dc72cc279b6$var$_vec = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nfunction $b7cc2dc72cc279b6$var$convertPathToGeometry(path, scale) {\n    const vector2s = path.map((points)=>{\n        return points.flatMap((v)=>new (0, $e06gU.Vector2)(v.x / scale, v.y / scale));\n    });\n    const holesShapes = vector2s.filter((p)=>(0, $e06gU.ShapeUtils).isClockWise(p)).map((p)=>new (0, $e06gU.Shape)(p));\n    const solidShapes = vector2s.filter((p)=>!(0, $e06gU.ShapeUtils).isClockWise(p)).map((p)=>{\n        const shape = new (0, $e06gU.Shape)(p);\n        shape.holes = holesShapes;\n        return shape;\n    });\n    // flip the triangles so they're facing in the right direction\n    const result = new (0, $e06gU.ShapeGeometry)(solidShapes).rotateX(Math.PI / 2);\n    result.index.array.reverse();\n    return result;\n}\nfunction $b7cc2dc72cc279b6$var$convertPathToLineSegments(path, scale) {\n    const arr = [];\n    path.forEach((points)=>{\n        for(let i = 0, l = points.length; i < l; i++){\n            const i1 = (i + 1) % points.length;\n            const p0 = points[i];\n            const p1 = points[i1];\n            arr.push(new (0, $e06gU.Vector3)(p0.x / scale, 0, p0.y / scale), new (0, $e06gU.Vector3)(p1.x / scale, 0, p1.y / scale));\n        }\n    });\n    const result = new (0, $e06gU.BufferGeometry)();\n    result.setFromPoints(arr);\n    return result;\n}\nconst $b7cc2dc72cc279b6$export$1d778cb9e99a63d0 = 0;\nconst $b7cc2dc72cc279b6$export$b1968b297e0facc4 = 1;\nconst $b7cc2dc72cc279b6$export$d2881bb52ea2a3ff = 2;\nclass $b7cc2dc72cc279b6$export$8f233aafe78e44af {\n    constructor(){\n        this.iterationTime = 30;\n        this.intScalar = 1e9;\n        this.doubleSided = false;\n        this.sortTriangles = false;\n        this.output = $b7cc2dc72cc279b6$export$1d778cb9e99a63d0;\n    }\n    generateAsync(geometry, options = {}) {\n        return new Promise((resolve, reject)=>{\n            const { signal: signal } = options;\n            const task = this.generate(geometry, options);\n            run();\n            function run() {\n                if (signal && signal.aborted) {\n                    reject(new Error(\"SilhouetteGenerator: Process aborted via AbortSignal.\"));\n                    return;\n                }\n                const result = task.next();\n                if (result.done) resolve(result.value);\n                else requestAnimationFrame(run);\n            }\n        });\n    }\n    *generate(geometry, options = {}) {\n        const { iterationTime: iterationTime, intScalar: intScalar, doubleSided: doubleSided, output: output, sortTriangles: sortTriangles } = this;\n        const { onProgress: onProgress } = options;\n        const power = Math.log10(intScalar);\n        const extendMultiplier = Math.pow(10, -(power - 2));\n        const index = geometry.index;\n        const posAttr = geometry.attributes.position;\n        const triCount = (0, $2683a3650d27fd1c$export$c56c51fae37b2d63)(geometry);\n        let overallPath = null;\n        const triList = sortTriangles ? (0, $00d3e1a2b175655e$export$22df3f56fb458152)(geometry) : new Array(triCount).fill().map((v, i)=>i);\n        const handle = {\n            getGeometry () {\n                if (output === $b7cc2dc72cc279b6$export$1d778cb9e99a63d0) return $b7cc2dc72cc279b6$var$convertPathToGeometry(overallPath, intScalar);\n                else if (output === $b7cc2dc72cc279b6$export$b1968b297e0facc4) return $b7cc2dc72cc279b6$var$convertPathToLineSegments(overallPath, intScalar);\n                else return [\n                    $b7cc2dc72cc279b6$var$convertPathToGeometry(overallPath, intScalar),\n                    $b7cc2dc72cc279b6$var$convertPathToLineSegments(overallPath, intScalar)\n                ];\n            }\n        };\n        let time = performance.now();\n        for(let ti = 0; ti < triCount; ti++){\n            const i = triList[ti] * 3;\n            let i0 = i + 0;\n            let i1 = i + 1;\n            let i2 = i + 2;\n            if (index) {\n                i0 = index.getX(i0);\n                i1 = index.getX(i1);\n                i2 = index.getX(i2);\n            }\n            // get the triangle\n            const { a: a, b: b, c: c } = $b7cc2dc72cc279b6$var$_tri;\n            a.fromBufferAttribute(posAttr, i0);\n            b.fromBufferAttribute(posAttr, i1);\n            c.fromBufferAttribute(posAttr, i2);\n            if (!doubleSided) {\n                $b7cc2dc72cc279b6$var$_tri.getNormal($b7cc2dc72cc279b6$var$_normal);\n                if ($b7cc2dc72cc279b6$var$_normal.dot($b7cc2dc72cc279b6$var$UP_VECTOR) < 0) continue;\n            }\n            // flatten the triangle\n            a.y = 0;\n            b.y = 0;\n            c.y = 0;\n            if ($b7cc2dc72cc279b6$var$_tri.getArea() < $b7cc2dc72cc279b6$var$AREA_EPSILON) continue;\n            // expand the triangle by a small degree to ensure overlap\n            $b7cc2dc72cc279b6$var$_center.copy(a).add(b).add(c).multiplyScalar(1 / 3);\n            $b7cc2dc72cc279b6$var$_vec.subVectors(a, $b7cc2dc72cc279b6$var$_center).normalize();\n            a.addScaledVector($b7cc2dc72cc279b6$var$_vec, extendMultiplier);\n            $b7cc2dc72cc279b6$var$_vec.subVectors(b, $b7cc2dc72cc279b6$var$_center).normalize();\n            b.addScaledVector($b7cc2dc72cc279b6$var$_vec, extendMultiplier);\n            $b7cc2dc72cc279b6$var$_vec.subVectors(c, $b7cc2dc72cc279b6$var$_center).normalize();\n            c.addScaledVector($b7cc2dc72cc279b6$var$_vec, extendMultiplier);\n            // create the path\n            const path = new (0, $0b6dbf71c0c0eea1$export$b12670b10302a8b7)();\n            path.push((0, $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908).makePath([\n                a.x * intScalar,\n                a.z * intScalar,\n                b.x * intScalar,\n                b.z * intScalar,\n                c.x * intScalar,\n                c.z * intScalar\n            ]));\n            a.multiplyScalar(intScalar);\n            b.multiplyScalar(intScalar);\n            c.multiplyScalar(intScalar);\n            if (overallPath && (0, $60fc547e70fa748b$export$a4592ad7ee5e85f)($b7cc2dc72cc279b6$var$_tri, overallPath)) continue;\n            // perform union\n            if (overallPath === null) overallPath = path;\n            else {\n                overallPath = (0, $0b6dbf71c0c0eea1$export$47d6d5d06ccbc908).Union(overallPath, path, (0, $0b6dbf71c0c0eea1$export$f26b42c94e8a4f95).NonZero);\n                overallPath.forEach((path)=>(0, $00adfa846be5871c$export$a1384fe5bb05e0aa)(path));\n            }\n            const delta = performance.now() - time;\n            if (delta > iterationTime) {\n                if (onProgress) {\n                    const progress = ti / triCount;\n                    onProgress(progress, handle);\n                }\n                yield;\n                time = performance.now();\n            }\n        }\n        return handle.getGeometry();\n    }\n}\n\n\nonmessage = function({ data: data }) {\n    let prevTime = performance.now();\n    function onProgressCallback(progress) {\n        const currTime = performance.now();\n        if (currTime - prevTime >= 10 || progress === 1.0) {\n            postMessage({\n                error: null,\n                progress: progress\n            });\n            prevTime = currTime;\n        }\n    }\n    try {\n        const { index: index, position: position, options: options } = data;\n        const geometry = new (0, $e06gU.BufferGeometry)();\n        geometry.setIndex(new (0, $e06gU.BufferAttribute)(index, 1, false));\n        geometry.setAttribute(\"position\", new (0, $e06gU.BufferAttribute)(position, 3, false));\n        const generator = new (0, $b7cc2dc72cc279b6$export$8f233aafe78e44af)();\n        generator.doubleSided = options.doubleSided ?? generator.doubleSided;\n        generator.output = options.output ?? generator.output;\n        generator.intScalar = options.intScalar ?? generator.intScalar;\n        generator.sortTriangles = options.sortTriangles ?? generator.sortTriangles;\n        const task = generator.generate(geometry, {\n            onProgress: onProgressCallback\n        });\n        let result = task.next();\n        while(!result.done)result = task.next();\n        let buffers, output;\n        if (generator.output === (0, $b7cc2dc72cc279b6$export$d2881bb52ea2a3ff)) {\n            buffers = [];\n            output = [];\n            result.value.forEach((g)=>{\n                console.log(g);\n                const posArr = g.attributes.position.array;\n                const indexArr = g.index?.array || null;\n                output.push({\n                    position: posArr,\n                    index: indexArr\n                });\n                buffers.push(posArr.buffer, indexArr?.buffer);\n            });\n        } else {\n            const posArr = result.value.attributes.position.array;\n            const indexArr = result.value.index.array;\n            output = {\n                position: posArr,\n                index: indexArr\n            };\n            buffers = [\n                posArr.buffer,\n                indexArr.buffer\n            ];\n        }\n        postMessage({\n            result: output,\n            error: null,\n            progress: 1\n        }, buffers.filter((b)=>!!b));\n    } catch (error) {\n        postMessage({\n            error: error,\n            progress: 1\n        });\n    }\n};\n\n})();\n//# sourceMappingURL=silhouetteAsync.worker.f555f2b4.js.map\n","import { BufferAttribute, BufferGeometry } from 'three';\nimport { OUTPUT_BOTH, SilhouetteGenerator } from '../SilhouetteGenerator.js';\n\nonmessage = function ( { data } ) {\n\n\tlet prevTime = performance.now();\n\tfunction onProgressCallback( progress ) {\n\n\t\tconst currTime = performance.now();\n\t\tif ( currTime - prevTime >= 10 || progress === 1.0 ) {\n\n\t\t\tpostMessage( {\n\n\t\t\t\terror: null,\n\t\t\t\tprogress,\n\n\t\t\t} );\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t}\n\n\ttry {\n\n\t\tconst { index, position, options } = data;\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( index, 1, false ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( position, 3, false ) );\n\n\t\tconst generator = new SilhouetteGenerator();\n\t\tgenerator.doubleSided = options.doubleSided ?? generator.doubleSided;\n\t\tgenerator.output = options.output ?? generator.output;\n\t\tgenerator.intScalar = options.intScalar ?? generator.intScalar;\n\t\tgenerator.sortTriangles = options.sortTriangles ?? generator.sortTriangles;\n\t\tconst task = generator.generate( geometry, {\n\t\t\tonProgress: onProgressCallback,\n\t\t} );\n\n\t\tlet result = task.next();\n\t\twhile ( ! result.done ) {\n\n\t\t\tresult = task.next();\n\n\t\t}\n\n\t\tlet buffers, output;\n\t\tif ( generator.output === OUTPUT_BOTH ) {\n\n\t\t\tbuffers = [];\n\t\t\toutput = [];\n\t\t\tresult.value.forEach( g => {\n\n\t\t\t\tconsole.log( g );\n\t\t\t\tconst posArr = g.attributes.position.array;\n\t\t\t\tconst indexArr = g.index?.array || null;\n\t\t\t\toutput.push( {\n\t\t\t\t\tposition: posArr,\n\t\t\t\t\tindex: indexArr,\n\t\t\t\t} );\n\t\t\t\tbuffers.push(\n\t\t\t\t\tposArr.buffer,\n\t\t\t\t\tindexArr?.buffer,\n\t\t\t\t);\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tconst posArr = result.value.attributes.position.array;\n\t\t\tconst indexArr = result.value.index.array;\n\t\t\toutput = {\n\t\t\t\tposition: posArr,\n\t\t\t\tindex: indexArr,\n\t\t\t};\n\t\t\tbuffers = [ posArr.buffer, indexArr.buffer ];\n\n\t\t}\n\n\t\tpostMessage( {\n\n\t\t\tresult: output,\n\t\t\terror: null,\n\t\t\tprogress: 1,\n\n\t\t}, buffers.filter( b => ! ! b ) );\n\n\t} catch ( error ) {\n\n\t\tpostMessage( {\n\n\t\t\terror,\n\t\t\tprogress: 1,\n\n\t\t} );\n\n\t}\n\n};\n","import { Path64, Clipper, FillRule } from 'clipper2-js';\nimport { ShapeGeometry, Vector3, Shape, Vector2, Triangle, ShapeUtils, BufferGeometry } from 'three';\nimport { compressPoints } from './utils/compressPoints.js';\nimport { triangleIsInsidePaths } from './utils/triangleIsInsidePaths.js';\nimport { getSizeSortedTriList } from './utils/getSizeSortedTriList.js';\nimport { getTriCount } from './utils/geometryUtils.js';\n\nconst AREA_EPSILON = 1e-8;\nconst UP_VECTOR = /* @__PURE__ */ new Vector3( 0, 1, 0 );\nconst _tri = /* @__PURE__ */ new Triangle();\nconst _normal = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\n\nfunction convertPathToGeometry( path, scale ) {\n\n\tconst vector2s = path.map( points => {\n\n\t\treturn points.flatMap( v => new Vector2( v.x / scale, v.y / scale ) );\n\n\t} );\n\n\tconst holesShapes = vector2s\n\t\t.filter( p => ShapeUtils.isClockWise( p ) )\n\t\t.map( p => new Shape( p ) );\n\n\tconst solidShapes = vector2s\n\t\t.filter( p => ! ShapeUtils.isClockWise( p ) )\n\t\t.map( p => {\n\n\t\t\tconst shape = new Shape( p );\n\t\t\tshape.holes = holesShapes;\n\t\t\treturn shape;\n\n\t\t} );\n\n\t// flip the triangles so they're facing in the right direction\n\tconst result = new ShapeGeometry( solidShapes ).rotateX( Math.PI / 2 );\n\tresult.index.array.reverse();\n\treturn result;\n\n}\n\nfunction convertPathToLineSegments( path, scale ) {\n\n\tconst arr = [];\n\tpath.forEach( points => {\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst i1 = ( i + 1 ) % points.length;\n\t\t\tconst p0 = points[ i ];\n\t\t\tconst p1 = points[ i1 ];\n\t\t\tarr.push(\n\t\t\t\tnew Vector3( p0.x / scale, 0, p0.y / scale ),\n\t\t\t\tnew Vector3( p1.x / scale, 0, p1.y / scale )\n\t\t\t);\n\n\t\t}\n\n\t} );\n\n\tconst result = new BufferGeometry();\n\tresult.setFromPoints( arr );\n\treturn result;\n\n}\n\nexport const OUTPUT_MESH = 0;\nexport const OUTPUT_LINE_SEGMENTS = 1;\nexport const OUTPUT_BOTH = 2;\nexport class SilhouetteGenerator {\n\n\tconstructor() {\n\n\t\tthis.iterationTime = 30;\n\t\tthis.intScalar = 1e9;\n\t\tthis.doubleSided = false;\n\t\tthis.sortTriangles = false;\n\t\tthis.output = OUTPUT_MESH;\n\n\t}\n\n\tgenerateAsync( geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tconst { signal } = options;\n\t\t\tconst task = this.generate( geometry, options );\n\t\t\trun();\n\n\t\t\tfunction run() {\n\n\t\t\t\tif ( signal && signal.aborted ) {\n\n\t\t\t\t\treject( new Error( 'SilhouetteGenerator: Process aborted via AbortSignal.' ) );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst result = task.next();\n\t\t\t\tif ( result.done ) {\n\n\t\t\t\t\tresolve( result.value );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trequestAnimationFrame( run );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} );\n\n\t}\n\n\t*generate( geometry, options = {} ) {\n\n\t\tconst { iterationTime, intScalar, doubleSided, output, sortTriangles } = this;\n\t\tconst { onProgress } = options;\n\t\tconst power = Math.log10( intScalar );\n\t\tconst extendMultiplier = Math.pow( 10, - ( power - 2 ) );\n\n\t\tconst index = geometry.index;\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst triCount = getTriCount( geometry );\n\t\tlet overallPath = null;\n\n\t\tconst triList = sortTriangles ?\n\t\t\tgetSizeSortedTriList( geometry ) :\n\t\t\tnew Array( triCount ).fill().map( ( v, i ) => i );\n\n\t\tconst handle = {\n\n\t\t\tgetGeometry() {\n\n\t\t\t\tif ( output === OUTPUT_MESH ) {\n\n\t\t\t\t\treturn convertPathToGeometry( overallPath, intScalar );\n\n\t\t\t\t} else if ( output === OUTPUT_LINE_SEGMENTS ) {\n\n\t\t\t\t\treturn convertPathToLineSegments( overallPath, intScalar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tconvertPathToGeometry( overallPath, intScalar ),\n\t\t\t\t\t\tconvertPathToLineSegments( overallPath, intScalar ),\n\t\t\t\t\t];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tlet time = performance.now();\n\t\tfor ( let ti = 0; ti < triCount; ti ++ ) {\n\n\t\t\tconst i = triList[ ti ] * 3;\n\t\t\tlet i0 = i + 0;\n\t\t\tlet i1 = i + 1;\n\t\t\tlet i2 = i + 2;\n\t\t\tif ( index ) {\n\n\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t}\n\n\t\t\t// get the triangle\n\t\t\tconst { a, b, c } = _tri;\n\t\t\ta.fromBufferAttribute( posAttr, i0 );\n\t\t\tb.fromBufferAttribute( posAttr, i1 );\n\t\t\tc.fromBufferAttribute( posAttr, i2 );\n\t\t\tif ( ! doubleSided ) {\n\n\t\t\t\t_tri.getNormal( _normal );\n\t\t\t\tif ( _normal.dot( UP_VECTOR ) < 0 ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// flatten the triangle\n\t\t\ta.y = 0;\n\t\t\tb.y = 0;\n\t\t\tc.y = 0;\n\n\t\t\tif ( _tri.getArea() < AREA_EPSILON ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// expand the triangle by a small degree to ensure overlap\n\t\t\t_center\n\t\t\t\t.copy( a )\n\t\t\t\t.add( b )\n\t\t\t\t.add( c )\n\t\t\t\t.multiplyScalar( 1 / 3 );\n\n\t\t\t_vec.subVectors( a, _center ).normalize();\n\t\t\ta.addScaledVector( _vec, extendMultiplier );\n\n\t\t\t_vec.subVectors( b, _center ).normalize();\n\t\t\tb.addScaledVector( _vec, extendMultiplier );\n\n\t\t\t_vec.subVectors( c, _center ).normalize();\n\t\t\tc.addScaledVector( _vec, extendMultiplier );\n\n\t\t\t// create the path\n\t\t\tconst path = new Path64();\n\t\t\tpath.push( Clipper.makePath( [\n\t\t\t\ta.x * intScalar, a.z * intScalar,\n\t\t\t\tb.x * intScalar, b.z * intScalar,\n\t\t\t\tc.x * intScalar, c.z * intScalar,\n\t\t\t] ) );\n\n\t\t\ta.multiplyScalar( intScalar );\n\t\t\tb.multiplyScalar( intScalar );\n\t\t\tc.multiplyScalar( intScalar );\n\t\t\tif ( overallPath && triangleIsInsidePaths( _tri, overallPath ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// perform union\n\t\t\tif ( overallPath === null ) {\n\n\t\t\t\toverallPath = path;\n\n\t\t\t} else {\n\n\t\t\t\toverallPath = Clipper.Union( overallPath, path, FillRule.NonZero );\n\t\t\t\toverallPath.forEach( path => compressPoints( path ) );\n\n\t\t\t}\n\n\t\t\tconst delta = performance.now() - time;\n\t\t\tif ( delta > iterationTime ) {\n\n\t\t\t\tif ( onProgress ) {\n\n\t\t\t\t\tconst progress = ti / triCount;\n\t\t\t\t\tonProgress( progress, handle );\n\n\t\t\t\t}\n\n\t\t\t\tyield;\n\t\t\t\ttime = performance.now();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn handle.getGeometry();\n\n\t}\n\n}\n","/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  15 October 2022                                                 *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2022                                         *\r\n* Purpose   :  Minkowski Sum and Difference                                    *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\nclass Minkowski {\r\n    static minkowskiInternal(pattern, path, isSum, isClosed) {\r\n        const delta = isClosed ? 0 : 1;\r\n        const patLen = pattern.length;\r\n        const pathLen = path.length;\r\n        const tmp = [];\r\n        for (const pathPt of path) {\r\n            const path2 = [];\r\n            if (isSum) {\r\n                for (const basePt of pattern)\r\n                    path2.push({ x: pathPt.x + basePt.x, y: pathPt.y + basePt.y });\r\n            }\r\n            else {\r\n                for (const basePt of pattern)\r\n                    path2.push({ x: pathPt.x - basePt.x, y: pathPt.y - basePt.y });\r\n            }\r\n            tmp.push(path2);\r\n        }\r\n        const result = [];\r\n        let g = isClosed ? pathLen - 1 : 0;\r\n        let h = patLen - 1;\r\n        for (let i = delta; i < pathLen; i++) {\r\n            for (let j = 0; j < patLen; j++) {\r\n                const quad = [tmp[g][h], tmp[i][h], tmp[i][j], tmp[g][j]];\r\n                if (!Clipper.isPositive(quad))\r\n                    result.push(Clipper.reversePath(quad));\r\n                else\r\n                    result.push(quad);\r\n                h = j;\r\n            }\r\n            g = i;\r\n        }\r\n        return result;\r\n    }\r\n    static sum(pattern, path, isClosed) {\r\n        return Clipper.Union(this.minkowskiInternal(pattern, path, true, isClosed), undefined, FillRule.NonZero);\r\n    }\r\n    static diff(pattern, path, isClosed) {\r\n        return Clipper.Union(this.minkowskiInternal(pattern, path, false, isClosed), undefined, FillRule.NonZero);\r\n    }\r\n}\n\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  7 August 2023                                                   *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  Path Offset (Inflate/Shrink)                                    *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\nvar JoinType;\r\n(function (JoinType) {\r\n    JoinType[JoinType[\"Square\"] = 0] = \"Square\";\r\n    JoinType[JoinType[\"Round\"] = 1] = \"Round\";\r\n    JoinType[JoinType[\"Miter\"] = 2] = \"Miter\";\r\n})(JoinType || (JoinType = {}));\r\nvar EndType;\r\n(function (EndType) {\r\n    EndType[EndType[\"Polygon\"] = 0] = \"Polygon\";\r\n    EndType[EndType[\"Joined\"] = 1] = \"Joined\";\r\n    EndType[EndType[\"Butt\"] = 2] = \"Butt\";\r\n    EndType[EndType[\"Square\"] = 3] = \"Square\";\r\n    EndType[EndType[\"Round\"] = 4] = \"Round\";\r\n})(EndType || (EndType = {}));\r\nclass Group {\r\n    constructor(paths, joinType, endType = EndType.Polygon) {\r\n        this.inPaths = [...paths]; // creates a shallow copy of paths\r\n        this.joinType = joinType;\r\n        this.endType = endType;\r\n        this.outPath = [];\r\n        this.outPaths = [];\r\n        this.pathsReversed = false;\r\n    }\r\n}\r\nclass PointD {\r\n    constructor(xOrPt, yOrScale) {\r\n        if (typeof xOrPt === 'number' && typeof yOrScale === 'number') {\r\n            this.x = xOrPt;\r\n            this.y = yOrScale;\r\n        }\r\n        else if (xOrPt instanceof PointD) {\r\n            if (yOrScale !== undefined) {\r\n                this.x = xOrPt.x * yOrScale;\r\n                this.y = xOrPt.y * yOrScale;\r\n            }\r\n            else {\r\n                this.x = xOrPt.x;\r\n                this.y = xOrPt.y;\r\n            }\r\n        }\r\n        else {\r\n            this.x = xOrPt.x * (yOrScale || 1);\r\n            this.y = xOrPt.y * (yOrScale || 1);\r\n        }\r\n    }\r\n    toString(precision = 2) {\r\n        return `${this.x.toFixed(precision)},${this.y.toFixed(precision)}`;\r\n    }\r\n    static equals(lhs, rhs) {\r\n        return InternalClipper.isAlmostZero(lhs.x - rhs.x) &&\r\n            InternalClipper.isAlmostZero(lhs.y - rhs.y);\r\n    }\r\n    static notEquals(lhs, rhs) {\r\n        return !InternalClipper.isAlmostZero(lhs.x - rhs.x) ||\r\n            !InternalClipper.isAlmostZero(lhs.y - rhs.y);\r\n    }\r\n    equals(obj) {\r\n        if (obj instanceof PointD) {\r\n            return PointD.equals(this, obj);\r\n        }\r\n        return false;\r\n    }\r\n    negate() {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n    }\r\n}\r\nclass ClipperOffset {\r\n    constructor(miterLimit = 2.0, arcTolerance = 0.0, preserveCollinear = false, reverseSolution = false) {\r\n        this._groupList = [];\r\n        this._normals = [];\r\n        this._solution = [];\r\n        this.MiterLimit = miterLimit;\r\n        this.ArcTolerance = arcTolerance;\r\n        this.MergeGroups = true;\r\n        this.PreserveCollinear = preserveCollinear;\r\n        this.ReverseSolution = reverseSolution;\r\n    }\r\n    clear() {\r\n        this._groupList = [];\r\n    }\r\n    addPath(path, joinType, endType) {\r\n        if (path.length === 0)\r\n            return;\r\n        const pp = [path];\r\n        this.addPaths(pp, joinType, endType);\r\n    }\r\n    addPaths(paths, joinType, endType) {\r\n        if (paths.length === 0)\r\n            return;\r\n        this._groupList.push(new Group(paths, joinType, endType));\r\n    }\r\n    executeInternal(delta) {\r\n        this._solution = [];\r\n        if (this._groupList.length === 0)\r\n            return;\r\n        if (Math.abs(delta) < 0.5) {\r\n            for (const group of this._groupList) {\r\n                for (const path of group.inPaths) {\r\n                    this._solution.push(path);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._delta = delta;\r\n            this._mitLimSqr = (this.MiterLimit <= 1 ? 2.0 : 2.0 / this.sqr(this.MiterLimit));\r\n            for (const group of this._groupList) {\r\n                this.doGroupOffset(group);\r\n            }\r\n        }\r\n    }\r\n    sqr(value) {\r\n        return value * value;\r\n    }\r\n    execute(delta, solution) {\r\n        solution.length = 0;\r\n        this.executeInternal(delta);\r\n        if (this._groupList.length === 0)\r\n            return;\r\n        // clean up self-intersections ...\r\n        const c = new Clipper64();\r\n        c.preserveCollinear = this.PreserveCollinear;\r\n        // the solution should retain the orientation of the input\r\n        c.reverseSolution = this.ReverseSolution !== this._groupList[0].pathsReversed;\r\n        c.addSubjectPaths(this._solution);\r\n        if (this._groupList[0].pathsReversed)\r\n            c.execute(ClipType.Union, FillRule.Negative, solution);\r\n        else\r\n            c.execute(ClipType.Union, FillRule.Positive, solution);\r\n    }\r\n    executePolytree(delta, polytree) {\r\n        polytree.clear();\r\n        this.executeInternal(delta);\r\n        if (this._groupList.length === 0)\r\n            return;\r\n        // clean up self-intersections ...\r\n        const c = new Clipper64();\r\n        c.preserveCollinear = this.PreserveCollinear;\r\n        // the solution should retain the orientation of the input\r\n        c.reverseSolution = this.ReverseSolution !== this._groupList[0].pathsReversed;\r\n        c.addSubjectPaths(this._solution);\r\n        if (this._groupList[0].pathsReversed)\r\n            c.executePolyTree(ClipType.Union, FillRule.Negative, polytree);\r\n        else\r\n            c.executePolyTree(ClipType.Union, FillRule.Positive, polytree);\r\n    }\r\n    static getUnitNormal(pt1, pt2) {\r\n        let dx = pt2.x - pt1.x;\r\n        let dy = pt2.y - pt1.y;\r\n        if (dx === 0 && dy === 0)\r\n            return new PointD(0, 0);\r\n        const f = 1.0 / Math.sqrt(dx * dx + dy * dy);\r\n        dx *= f;\r\n        dy *= f;\r\n        return new PointD(dy, -dx);\r\n    }\r\n    executeCallback(deltaCallback, solution) {\r\n        this.DeltaCallback = deltaCallback;\r\n        this.execute(1.0, solution);\r\n    }\r\n    static getBoundsAndLowestPolyIdx(paths) {\r\n        const rec = new Rect64(false); // ie invalid rect\r\n        let lpX = Number.MIN_SAFE_INTEGER;\r\n        let index = -1;\r\n        for (let i = 0; i < paths.length; i++) {\r\n            for (const pt of paths[i]) {\r\n                if (pt.y >= rec.bottom) {\r\n                    if (pt.y > rec.bottom || pt.x < lpX) {\r\n                        index = i;\r\n                        lpX = pt.x;\r\n                        rec.bottom = pt.y;\r\n                    }\r\n                }\r\n                else if (pt.y < rec.top)\r\n                    rec.top = pt.y;\r\n                if (pt.x > rec.right)\r\n                    rec.right = pt.x;\r\n                else if (pt.x < rec.left)\r\n                    rec.left = pt.x;\r\n            }\r\n        }\r\n        return { index, rec };\r\n    }\r\n    static translatePoint(pt, dx, dy) {\r\n        return new PointD(pt.x + dx, pt.y + dy);\r\n    }\r\n    static reflectPoint(pt, pivot) {\r\n        return new PointD(pivot.x + (pivot.x - pt.x), pivot.y + (pivot.y - pt.y));\r\n    }\r\n    static almostZero(value, epsilon = 0.001) {\r\n        return Math.abs(value) < epsilon;\r\n    }\r\n    static hypotenuse(x, y) {\r\n        return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n    }\r\n    static normalizeVector(vec) {\r\n        const h = this.hypotenuse(vec.x, vec.y);\r\n        if (this.almostZero(h))\r\n            return new PointD(0, 0);\r\n        const inverseHypot = 1 / h;\r\n        return new PointD(vec.x * inverseHypot, vec.y * inverseHypot);\r\n    }\r\n    static getAvgUnitVector(vec1, vec2) {\r\n        return this.normalizeVector(new PointD(vec1.x + vec2.x, vec1.y + vec2.y));\r\n    }\r\n    static intersectPoint(pt1a, pt1b, pt2a, pt2b) {\r\n        if (InternalClipper.isAlmostZero(pt1a.x - pt1b.x)) { //vertical\r\n            if (InternalClipper.isAlmostZero(pt2a.x - pt2b.x))\r\n                return new PointD(0, 0);\r\n            const m2 = (pt2b.y - pt2a.y) / (pt2b.x - pt2a.x);\r\n            const b2 = pt2a.y - m2 * pt2a.x;\r\n            return new PointD(pt1a.x, m2 * pt1a.x + b2);\r\n        }\r\n        if (InternalClipper.isAlmostZero(pt2a.x - pt2b.x)) { //vertical\r\n            const m1 = (pt1b.y - pt1a.y) / (pt1b.x - pt1a.x);\r\n            const b1 = pt1a.y - m1 * pt1a.x;\r\n            return new PointD(pt2a.x, m1 * pt2a.x + b1);\r\n        }\r\n        else {\r\n            const m1 = (pt1b.y - pt1a.y) / (pt1b.x - pt1a.x);\r\n            const b1 = pt1a.y - m1 * pt1a.x;\r\n            const m2 = (pt2b.y - pt2a.y) / (pt2b.x - pt2a.x);\r\n            const b2 = pt2a.y - m2 * pt2a.x;\r\n            if (InternalClipper.isAlmostZero(m1 - m2))\r\n                return new PointD(0, 0);\r\n            const x = (b2 - b1) / (m1 - m2);\r\n            return new PointD(x, m1 * x + b1);\r\n        }\r\n    }\r\n    getPerpendic(pt, norm) {\r\n        return new Point64(pt.x + norm.x * this._groupDelta, pt.y + norm.y * this._groupDelta);\r\n    }\r\n    getPerpendicD(pt, norm) {\r\n        return new PointD(pt.x + norm.x * this._groupDelta, pt.y + norm.y * this._groupDelta);\r\n    }\r\n    doSquare(group, path, j, k) {\r\n        let vec;\r\n        if (j === k) {\r\n            vec = new PointD(this._normals[j].y, -this._normals[j].x);\r\n        }\r\n        else {\r\n            vec = ClipperOffset.getAvgUnitVector(new PointD(-this._normals[k].y, this._normals[k].x), new PointD(this._normals[j].y, -this._normals[j].x));\r\n        }\r\n        const absDelta = Math.abs(this._groupDelta);\r\n        // now offset the original vertex delta units along unit vector\r\n        let ptQ = new PointD(path[j].x, path[j].y);\r\n        ptQ = ClipperOffset.translatePoint(ptQ, absDelta * vec.x, absDelta * vec.y);\r\n        // get perpendicular vertices\r\n        const pt1 = ClipperOffset.translatePoint(ptQ, this._groupDelta * vec.y, this._groupDelta * -vec.x);\r\n        const pt2 = ClipperOffset.translatePoint(ptQ, this._groupDelta * -vec.y, this._groupDelta * vec.x);\r\n        // get 2 vertices along one edge offset\r\n        const pt3 = this.getPerpendicD(path[k], this._normals[k]);\r\n        if (j === k) {\r\n            const pt4 = new PointD(pt3.x + vec.x * this._groupDelta, pt3.y + vec.y * this._groupDelta);\r\n            const pt = ClipperOffset.intersectPoint(pt1, pt2, pt3, pt4);\r\n            //get the second intersect point through reflection\r\n            group.outPath.push(new Point64(ClipperOffset.reflectPoint(pt, ptQ).x, ClipperOffset.reflectPoint(pt, ptQ).y));\r\n            group.outPath.push(new Point64(pt.x, pt.y));\r\n        }\r\n        else {\r\n            const pt4 = this.getPerpendicD(path[j], this._normals[k]);\r\n            const pt = ClipperOffset.intersectPoint(pt1, pt2, pt3, pt4);\r\n            group.outPath.push(new Point64(pt.x, pt.y));\r\n            //get the second intersect point through reflection\r\n            group.outPath.push(new Point64(ClipperOffset.reflectPoint(pt, ptQ).x, ClipperOffset.reflectPoint(pt, ptQ).y));\r\n        }\r\n    }\r\n    doMiter(group, path, j, k, cosA) {\r\n        const q = this._groupDelta / (cosA + 1);\r\n        group.outPath.push(new Point64(path[j].x + (this._normals[k].x + this._normals[j].x) * q, path[j].y + (this._normals[k].y + this._normals[j].y) * q));\r\n    }\r\n    doRound(group, path, j, k, angle) {\r\n        if (typeof this.DeltaCallback !== \"undefined\") {\r\n            const absDelta = Math.abs(this._groupDelta);\r\n            const arcTol = this.ArcTolerance > 0.01\r\n                ? this.ArcTolerance\r\n                : Math.log10(2 + absDelta) * InternalClipper.defaultArcTolerance;\r\n            const stepsPer360 = Math.PI / Math.acos(1 - arcTol / absDelta);\r\n            this._stepSin = Math.sin((2 * Math.PI) / stepsPer360);\r\n            this._stepCos = Math.cos((2 * Math.PI) / stepsPer360);\r\n            if (this._groupDelta < 0.0)\r\n                this._stepSin = -this._stepSin;\r\n            this._stepsPerRad = stepsPer360 / (2 * Math.PI);\r\n        }\r\n        const pt = path[j];\r\n        let offsetVec = new PointD(this._normals[k].x * this._groupDelta, this._normals[k].y * this._groupDelta);\r\n        if (j === k)\r\n            offsetVec.negate();\r\n        group.outPath.push(new Point64(pt.x + offsetVec.x, pt.y + offsetVec.y));\r\n        if (angle > -Math.PI + 0.01) {\r\n            const steps = Math.ceil(this._stepsPerRad * Math.abs(angle));\r\n            for (let i = 1; i < steps; i++) {\r\n                offsetVec = new PointD(offsetVec.x * this._stepCos - this._stepSin * offsetVec.y, offsetVec.x * this._stepSin + offsetVec.y * this._stepCos);\r\n                group.outPath.push(new Point64(pt.x + offsetVec.x, pt.y + offsetVec.y));\r\n            }\r\n        }\r\n        group.outPath.push(this.getPerpendic(pt, this._normals[j]));\r\n    }\r\n    buildNormals(path) {\r\n        const cnt = path.length;\r\n        this._normals = [];\r\n        this._normals.length = cnt;\r\n        for (let i = 0; i < cnt - 1; i++) {\r\n            this._normals.push(ClipperOffset.getUnitNormal(path[i], path[i + 1]));\r\n        }\r\n        this._normals.push(ClipperOffset.getUnitNormal(path[cnt - 1], path[0]));\r\n    }\r\n    crossProduct(vec1, vec2) {\r\n        return (vec1.y * vec2.x - vec2.y * vec1.x);\r\n    }\r\n    dotProduct(vec1, vec2) {\r\n        return (vec1.x * vec2.x + vec1.y * vec2.y);\r\n    }\r\n    offsetPoint(group, path, j, k) {\r\n        const sinA = this.crossProduct(this._normals[j], this._normals[k]);\r\n        let cosA = this.dotProduct(this._normals[j], this._normals[k]);\r\n        if (sinA > 1.0)\r\n            cosA = 1.0;\r\n        else if (sinA < -1.0)\r\n            cosA = -1.0;\r\n        if (typeof this.DeltaCallback !== \"undefined\") {\r\n            this._groupDelta = this.DeltaCallback(path, this._normals, j, k);\r\n            if (group.pathsReversed)\r\n                this._groupDelta = -this._groupDelta;\r\n        }\r\n        if (Math.abs(this._groupDelta) < ClipperOffset.Tolerance) {\r\n            group.outPath.push(path[j]);\r\n            return;\r\n        }\r\n        if (cosA > 0.999) {\r\n            this.doMiter(group, path, j, k, cosA);\r\n        }\r\n        else if (cosA > -0.99 && (sinA * this._groupDelta < 0)) {\r\n            group.outPath.push(this.getPerpendic(path[j], this._normals[k]));\r\n            group.outPath.push(path[j]);\r\n            group.outPath.push(this.getPerpendic(path[j], this._normals[j]));\r\n        }\r\n        else if (this._joinType === JoinType.Miter) {\r\n            if (cosA > this._mitLimSqr - 1) {\r\n                this.doMiter(group, path, j, k, cosA);\r\n            }\r\n            else {\r\n                this.doSquare(group, path, j, k);\r\n            }\r\n        }\r\n        else if (cosA > 0.99 || this._joinType === JoinType.Square) {\r\n            this.doSquare(group, path, j, k);\r\n        }\r\n        else {\r\n            this.doRound(group, path, j, k, Math.atan2(sinA, cosA));\r\n        }\r\n        k = j;\r\n    }\r\n    offsetPolygon(group, path) {\r\n        const area = Clipper.area(path);\r\n        if ((area < 0) !== (this._groupDelta < 0)) {\r\n            const rect = Clipper.getBounds(path);\r\n            if (Math.abs(this._groupDelta) * 2 > rect.width)\r\n                return;\r\n        }\r\n        group.outPath = [];\r\n        const cnt = path.length;\r\n        const prev = cnt - 1;\r\n        for (let i = 0; i < cnt; i++) {\r\n            this.offsetPoint(group, path, i, prev);\r\n        }\r\n        group.outPaths.push(group.outPath);\r\n    }\r\n    offsetOpenJoined(group, path) {\r\n        this.offsetPolygon(group, path);\r\n        path = Clipper.reversePath(path);\r\n        this.buildNormals(path);\r\n        this.offsetPolygon(group, path);\r\n    }\r\n    offsetOpenPath(group, path) {\r\n        group.outPath = [];\r\n        const highI = path.length - 1;\r\n        if (typeof this.DeltaCallback !== \"undefined\") {\r\n            this._groupDelta = this.DeltaCallback(path, this._normals, 0, 0);\r\n        }\r\n        if (Math.abs(this._groupDelta) < ClipperOffset.Tolerance) {\r\n            group.outPath.push(path[0]);\r\n        }\r\n        else {\r\n            switch (this._endType) {\r\n                case EndType.Butt:\r\n                    group.outPath.push(new Point64(path[0].x - this._normals[0].x * this._groupDelta, path[0].y - this._normals[0].y * this._groupDelta));\r\n                    group.outPath.push(this.getPerpendic(path[0], this._normals[0]));\r\n                    break;\r\n                case EndType.Round:\r\n                    this.doRound(group, path, 0, 0, Math.PI);\r\n                    break;\r\n                default:\r\n                    this.doSquare(group, path, 0, 0);\r\n                    break;\r\n            }\r\n        }\r\n        for (let i = 1, k = 0; i < highI; i++) {\r\n            this.offsetPoint(group, path, i, k);\r\n        }\r\n        for (let i = highI; i > 0; i--) {\r\n            this._normals[i] = new PointD(-this._normals[i - 1].x, -this._normals[i - 1].y);\r\n        }\r\n        this._normals[0] = this._normals[highI];\r\n        if (typeof this.DeltaCallback !== \"undefined\") {\r\n            this._groupDelta = this.DeltaCallback(path, this._normals, highI, highI);\r\n        }\r\n        if (Math.abs(this._groupDelta) < ClipperOffset.Tolerance) {\r\n            group.outPath.push(path[highI]);\r\n        }\r\n        else {\r\n            switch (this._endType) {\r\n                case EndType.Butt:\r\n                    group.outPath.push(new Point64(path[highI].x - this._normals[highI].x * this._groupDelta, path[highI].y - this._normals[highI].y * this._groupDelta));\r\n                    group.outPath.push(this.getPerpendic(path[highI], this._normals[highI]));\r\n                    break;\r\n                case EndType.Round:\r\n                    this.doRound(group, path, highI, highI, Math.PI);\r\n                    break;\r\n                default:\r\n                    this.doSquare(group, path, highI, highI);\r\n                    break;\r\n            }\r\n        }\r\n        for (let i = highI, k = 0; i > 0; i--) {\r\n            this.offsetPoint(group, path, i, k);\r\n        }\r\n        group.outPaths.push(group.outPath);\r\n    }\r\n    doGroupOffset(group) {\r\n        if (group.endType == EndType.Polygon) {\r\n            const { index } = ClipperOffset.getBoundsAndLowestPolyIdx(group.inPaths);\r\n            if (index < 0)\r\n                return;\r\n            const area = Clipper.area(group.inPaths[index]);\r\n            group.pathsReversed = area < 0;\r\n            if (group.pathsReversed) {\r\n                this._groupDelta = -this._delta;\r\n            }\r\n            else {\r\n                this._groupDelta = this._delta;\r\n            }\r\n        }\r\n        else {\r\n            group.pathsReversed = false;\r\n            this._groupDelta = Math.abs(this._delta) * 0.5;\r\n        }\r\n        const absDelta = Math.abs(this._groupDelta);\r\n        this._joinType = group.joinType;\r\n        this._endType = group.endType;\r\n        if (!this.DeltaCallback &&\r\n            (group.joinType == JoinType.Round || group.endType == EndType.Round)) {\r\n            const arcTol = this.ArcTolerance > 0.01\r\n                ? this.ArcTolerance\r\n                : Math.log10(2 + absDelta) * InternalClipper.defaultArcTolerance;\r\n            const stepsPer360 = Math.PI / Math.acos(1 - arcTol / absDelta);\r\n            this._stepSin = Math.sin((2 * Math.PI) / stepsPer360);\r\n            this._stepCos = Math.cos((2 * Math.PI) / stepsPer360);\r\n            if (this._groupDelta < 0.0) {\r\n                this._stepSin = -this._stepSin;\r\n            }\r\n            this._stepsPerRad = stepsPer360 / (2 * Math.PI);\r\n        }\r\n        const isJoined = group.endType == EndType.Joined || group.endType == EndType.Polygon;\r\n        for (const p of group.inPaths) {\r\n            const path = Clipper.stripDuplicates(p, isJoined);\r\n            const cnt = path.length;\r\n            if (cnt === 0 || (cnt < 3 && this._endType == EndType.Polygon)) {\r\n                continue;\r\n            }\r\n            if (cnt == 1) {\r\n                group.outPath = [];\r\n                if (group.endType == EndType.Round) {\r\n                    const r = absDelta;\r\n                    group.outPath = Clipper.ellipse(path[0], r, r);\r\n                }\r\n                else {\r\n                    const d = Math.ceil(this._groupDelta);\r\n                    const r = new Rect64(path[0].x - d, path[0].y - d, path[0].x - d, path[0].y - d);\r\n                    group.outPath = r.asPath();\r\n                }\r\n                group.outPaths.push(group.outPath);\r\n            }\r\n            else {\r\n                if (cnt == 2 && group.endType == EndType.Joined) {\r\n                    if (group.joinType == JoinType.Round) {\r\n                        this._endType = EndType.Round;\r\n                    }\r\n                    else {\r\n                        this._endType = EndType.Square;\r\n                    }\r\n                }\r\n                this.buildNormals(path);\r\n                if (this._endType == EndType.Polygon) {\r\n                    this.offsetPolygon(group, path);\r\n                }\r\n                else if (this._endType == EndType.Joined) {\r\n                    this.offsetOpenJoined(group, path);\r\n                }\r\n                else {\r\n                    this.offsetOpenPath(group, path);\r\n                }\r\n            }\r\n        }\r\n        this._solution.push(...group.outPaths);\r\n        group.outPaths = [];\r\n    }\r\n}\r\nClipperOffset.Tolerance = 1.0E-12;\n\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  6 August 2023                                                   *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  FAST rectangular clipping                                       *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\nclass OutPt2 {\r\n    constructor(pt) {\r\n        this.pt = pt;\r\n        this.ownerIdx = 0;\r\n    }\r\n}\r\nvar Location;\r\n(function (Location) {\r\n    Location[Location[\"left\"] = 0] = \"left\";\r\n    Location[Location[\"top\"] = 1] = \"top\";\r\n    Location[Location[\"right\"] = 2] = \"right\";\r\n    Location[Location[\"bottom\"] = 3] = \"bottom\";\r\n    Location[Location[\"inside\"] = 4] = \"inside\";\r\n})(Location || (Location = {}));\r\nclass RectClip64 {\r\n    constructor(rect) {\r\n        this.currIdx = -1;\r\n        this.rect = rect;\r\n        this.mp = rect.midPoint();\r\n        this.rectPath = rect.asPath();\r\n        this.results = [];\r\n        this.edges = Array(8).fill(undefined).map(() => []);\r\n    }\r\n    add(pt, startingNewPath = false) {\r\n        let currIdx = this.results.length;\r\n        let result;\r\n        if (currIdx === 0 || startingNewPath) {\r\n            result = new OutPt2(pt);\r\n            this.results.push(result);\r\n            result.ownerIdx = currIdx;\r\n            result.prev = result;\r\n            result.next = result;\r\n        }\r\n        else {\r\n            currIdx--;\r\n            const prevOp = this.results[currIdx];\r\n            if (prevOp.pt === pt)\r\n                return prevOp;\r\n            result = new OutPt2(pt);\r\n            result.ownerIdx = currIdx;\r\n            result.next = prevOp.next;\r\n            prevOp.next.prev = result;\r\n            prevOp.next = result;\r\n            result.prev = prevOp;\r\n            this.results[currIdx] = result;\r\n        }\r\n        return result;\r\n    }\r\n    static path1ContainsPath2(path1, path2) {\r\n        let ioCount = 0;\r\n        for (const pt of path2) {\r\n            const pip = InternalClipper.pointInPolygon(pt, path1);\r\n            switch (pip) {\r\n                case PointInPolygonResult.IsInside:\r\n                    ioCount--;\r\n                    break;\r\n                case PointInPolygonResult.IsOutside:\r\n                    ioCount++;\r\n                    break;\r\n            }\r\n            if (Math.abs(ioCount) > 1)\r\n                break;\r\n        }\r\n        return ioCount <= 0;\r\n    }\r\n    static isClockwise(prev, curr, prevPt, currPt, rectMidPoint) {\r\n        if (this.areOpposites(prev, curr))\r\n            return InternalClipper.crossProduct(prevPt, rectMidPoint, currPt) < 0;\r\n        else\r\n            return this.headingClockwise(prev, curr);\r\n    }\r\n    static areOpposites(prev, curr) {\r\n        return Math.abs(prev - curr) === 2;\r\n    }\r\n    static headingClockwise(prev, curr) {\r\n        return (prev + 1) % 4 === curr;\r\n    }\r\n    static getAdjacentLocation(loc, isClockwise) {\r\n        const delta = isClockwise ? 1 : 3;\r\n        return (loc + delta) % 4;\r\n    }\r\n    static unlinkOp(op) {\r\n        if (op.next === op)\r\n            return undefined;\r\n        op.prev.next = op.next;\r\n        op.next.prev = op.prev;\r\n        return op.next;\r\n    }\r\n    static unlinkOpBack(op) {\r\n        if (op.next === op)\r\n            return undefined;\r\n        op.prev.next = op.next;\r\n        op.next.prev = op.prev;\r\n        return op.prev;\r\n    }\r\n    static getEdgesForPt(pt, rec) {\r\n        let result = 0;\r\n        if (pt.x === rec.left)\r\n            result = 1;\r\n        else if (pt.x === rec.right)\r\n            result = 4;\r\n        if (pt.y === rec.top)\r\n            result += 2;\r\n        else if (pt.y === rec.bottom)\r\n            result += 8;\r\n        return result;\r\n    }\r\n    static isHeadingClockwise(pt1, pt2, edgeIdx) {\r\n        switch (edgeIdx) {\r\n            case 0: return pt2.y < pt1.y;\r\n            case 1: return pt2.x > pt1.x;\r\n            case 2: return pt2.y > pt1.y;\r\n            default: return pt2.x < pt1.x;\r\n        }\r\n    }\r\n    static hasHorzOverlap(left1, right1, left2, right2) {\r\n        return (left1.x < right2.x) && (right1.x > left2.x);\r\n    }\r\n    static hasVertOverlap(top1, bottom1, top2, bottom2) {\r\n        return (top1.y < bottom2.y) && (bottom1.y > top2.y);\r\n    }\r\n    static addToEdge(edge, op) {\r\n        if (op.edge)\r\n            return;\r\n        op.edge = edge;\r\n        edge.push(op);\r\n    }\r\n    static uncoupleEdge(op) {\r\n        if (!op.edge)\r\n            return;\r\n        for (let i = 0; i < op.edge.length; i++) {\r\n            const op2 = op.edge[i];\r\n            if (op2 === op) {\r\n                op.edge[i] = undefined;\r\n                break;\r\n            }\r\n        }\r\n        op.edge = undefined;\r\n    }\r\n    static setNewOwner(op, newIdx) {\r\n        op.ownerIdx = newIdx;\r\n        let op2 = op.next;\r\n        while (op2 !== op) {\r\n            op2.ownerIdx = newIdx;\r\n            op2 = op2.next;\r\n        }\r\n    }\r\n    addCorner(prev, curr) {\r\n        if (RectClip64.headingClockwise(prev, curr))\r\n            this.add(this.rectPath[prev]);\r\n        else\r\n            this.add(this.rectPath[curr]);\r\n    }\r\n    addCornerByRef(loc, isClockwise) {\r\n        if (isClockwise) {\r\n            this.add(this.rectPath[loc]);\r\n            loc = RectClip64.getAdjacentLocation(loc, true);\r\n        }\r\n        else {\r\n            loc = RectClip64.getAdjacentLocation(loc, false);\r\n            this.add(this.rectPath[loc]);\r\n        }\r\n    }\r\n    static getLocation(rec, pt) {\r\n        let loc;\r\n        if (pt.x === rec.left && pt.y >= rec.top && pt.y <= rec.bottom) {\r\n            loc = Location.left; // pt on rec\r\n            return { success: false, loc };\r\n        }\r\n        if (pt.x === rec.right && pt.y >= rec.top && pt.y <= rec.bottom) {\r\n            loc = Location.right; // pt on rec\r\n            return { success: false, loc };\r\n        }\r\n        if (pt.y === rec.top && pt.x >= rec.left && pt.x <= rec.right) {\r\n            loc = Location.top; // pt on rec\r\n            return { success: false, loc };\r\n        }\r\n        if (pt.y === rec.bottom && pt.x >= rec.left && pt.x <= rec.right) {\r\n            loc = Location.bottom; // pt on rec\r\n            return { success: false, loc };\r\n        }\r\n        if (pt.x < rec.left)\r\n            loc = Location.left;\r\n        else if (pt.x > rec.right)\r\n            loc = Location.right;\r\n        else if (pt.y < rec.top)\r\n            loc = Location.top;\r\n        else if (pt.y > rec.bottom)\r\n            loc = Location.bottom;\r\n        else\r\n            loc = Location.inside;\r\n        return { success: true, loc };\r\n    }\r\n    static getIntersection(rectPath, p, p2, loc) {\r\n        // gets the pt of intersection between rectPath and segment(p, p2) that's closest to 'p'\r\n        // when result == false, loc will remain unchanged\r\n        let ip = new Point64();\r\n        switch (loc) {\r\n            case Location.left:\r\n                if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n                }\r\n                else if (p.y < rectPath[0].y && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n                    loc = Location.top;\r\n                }\r\n                else if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n                    loc = Location.bottom;\r\n                }\r\n                else {\r\n                    return { success: false, loc, ip };\r\n                }\r\n                break;\r\n            case Location.right:\r\n                if (InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n                }\r\n                else if (p.y < rectPath[0].y && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n                    loc = Location.top;\r\n                }\r\n                else if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n                    loc = Location.bottom;\r\n                }\r\n                else {\r\n                    return { success: false, loc, ip };\r\n                }\r\n                break;\r\n            case Location.top:\r\n                if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n                }\r\n                else if (p.x < rectPath[0].x && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n                    loc = Location.left;\r\n                }\r\n                else if (p.x > rectPath[1].x && InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n                    loc = Location.right;\r\n                }\r\n                else {\r\n                    return { success: false, loc, ip };\r\n                }\r\n                break;\r\n            case Location.bottom:\r\n                if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n                }\r\n                else if (p.x < rectPath[3].x && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n                    loc = Location.left;\r\n                }\r\n                else if (p.x > rectPath[2].x && InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n                    loc = Location.right;\r\n                }\r\n                else {\r\n                    return { success: false, loc, ip };\r\n                }\r\n                break;\r\n            case Location.inside:\r\n                if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n                    loc = Location.left;\r\n                }\r\n                else if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n                    loc = Location.top;\r\n                }\r\n                else if (InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n                    loc = Location.right;\r\n                }\r\n                else if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n                    loc = Location.bottom;\r\n                }\r\n                else {\r\n                    return { success: false, loc, ip };\r\n                }\r\n                break;\r\n        }\r\n        return { success: true, loc, ip };\r\n    }\r\n    getNextLocation(path, context) {\r\n        switch (context.loc) {\r\n            case Location.left:\r\n                while (context.i <= context.highI && path[context.i].x <= this.rect.left)\r\n                    context.i++;\r\n                if (context.i > context.highI)\r\n                    break;\r\n                if (path[context.i].x >= this.rect.right)\r\n                    context.loc = Location.right;\r\n                else if (path[context.i].y <= this.rect.top)\r\n                    context.loc = Location.top;\r\n                else if (path[context.i].y >= this.rect.bottom)\r\n                    context.loc = Location.bottom;\r\n                else\r\n                    context.loc = Location.inside;\r\n                break;\r\n            case Location.top:\r\n                while (context.i <= context.highI && path[context.i].y <= this.rect.top)\r\n                    context.i++;\r\n                if (context.i > context.highI)\r\n                    break;\r\n                if (path[context.i].y >= this.rect.bottom)\r\n                    context.loc = Location.bottom;\r\n                else if (path[context.i].x <= this.rect.left)\r\n                    context.loc = Location.left;\r\n                else if (path[context.i].x >= this.rect.right)\r\n                    context.loc = Location.right;\r\n                else\r\n                    context.loc = Location.inside;\r\n                break;\r\n            case Location.right:\r\n                while (context.i <= context.highI && path[context.i].x >= this.rect.right)\r\n                    context.i++;\r\n                if (context.i > context.highI)\r\n                    break;\r\n                if (path[context.i].x <= this.rect.left)\r\n                    context.loc = Location.left;\r\n                else if (path[context.i].y <= this.rect.top)\r\n                    context.loc = Location.top;\r\n                else if (path[context.i].y >= this.rect.bottom)\r\n                    context.loc = Location.bottom;\r\n                else\r\n                    context.loc = Location.inside;\r\n                break;\r\n            case Location.bottom:\r\n                while (context.i <= context.highI && path[context.i].y >= this.rect.bottom)\r\n                    context.i++;\r\n                if (context.i > context.highI)\r\n                    break;\r\n                if (path[context.i].y <= this.rect.top)\r\n                    context.loc = Location.top;\r\n                else if (path[context.i].x <= this.rect.left)\r\n                    context.loc = Location.left;\r\n                else if (path[context.i].x >= this.rect.right)\r\n                    context.loc = Location.right;\r\n                else\r\n                    context.loc = Location.inside;\r\n                break;\r\n            case Location.inside:\r\n                while (context.i <= context.highI) {\r\n                    if (path[context.i].x < this.rect.left)\r\n                        context.loc = Location.left;\r\n                    else if (path[context.i].x > this.rect.right)\r\n                        context.loc = Location.right;\r\n                    else if (path[context.i].y > this.rect.bottom)\r\n                        context.loc = Location.bottom;\r\n                    else if (path[context.i].y < this.rect.top)\r\n                        context.loc = Location.top;\r\n                    else {\r\n                        this.add(path[context.i]);\r\n                        context.i++;\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    executeInternal(path) {\r\n        if (path.length < 3 || this.rect.isEmpty())\r\n            return;\r\n        const startLocs = [];\r\n        let firstCross = Location.inside;\r\n        let crossingLoc = firstCross, prev = firstCross;\r\n        let i;\r\n        const highI = path.length - 1;\r\n        let result = RectClip64.getLocation(this.rect, path[highI]);\r\n        let loc = result.loc;\r\n        if (!result.success) {\r\n            i = highI - 1;\r\n            while (i >= 0 && !result.success) {\r\n                i--;\r\n                result = RectClip64.getLocation(this.rect, path[i]);\r\n                prev = result.loc;\r\n            }\r\n            if (i < 0) {\r\n                for (const pt of path) {\r\n                    this.add(pt);\r\n                }\r\n                return;\r\n            }\r\n            if (prev == Location.inside)\r\n                loc = Location.inside;\r\n        }\r\n        const startingLoc = loc;\r\n        ///////////////////////////////////////////////////\r\n        i = 0;\r\n        while (i <= highI) {\r\n            prev = loc;\r\n            const prevCrossLoc = crossingLoc;\r\n            this.getNextLocation(path, { loc, i, highI });\r\n            if (i > highI)\r\n                break;\r\n            const prevPt = (i == 0) ? path[highI] : path[i - 1];\r\n            crossingLoc = loc;\r\n            let result = RectClip64.getIntersection(this.rectPath, path[i], prevPt, crossingLoc);\r\n            const ip = result.ip;\r\n            if (!result.success) {\r\n                if (prevCrossLoc == Location.inside) {\r\n                    const isClockw = RectClip64.isClockwise(prev, loc, prevPt, path[i], this.mp);\r\n                    do {\r\n                        startLocs.push(prev);\r\n                        prev = RectClip64.getAdjacentLocation(prev, isClockw);\r\n                    } while (prev != loc);\r\n                    crossingLoc = prevCrossLoc;\r\n                }\r\n                else if (prev != Location.inside && prev != loc) {\r\n                    const isClockw = RectClip64.isClockwise(prev, loc, prevPt, path[i], this.mp);\r\n                    do {\r\n                        this.addCornerByRef(prev, isClockw);\r\n                    } while (prev != loc);\r\n                }\r\n                ++i;\r\n                continue;\r\n            }\r\n            ////////////////////////////////////////////////////\r\n            // we must be crossing the rect boundary to get here\r\n            ////////////////////////////////////////////////////\r\n            if (loc == Location.inside) {\r\n                if (firstCross == Location.inside) {\r\n                    firstCross = crossingLoc;\r\n                    startLocs.push(prev);\r\n                }\r\n                else if (prev != crossingLoc) {\r\n                    const isClockw = RectClip64.isClockwise(prev, crossingLoc, prevPt, path[i], this.mp);\r\n                    do {\r\n                        this.addCornerByRef(prev, isClockw);\r\n                    } while (prev != crossingLoc);\r\n                }\r\n            }\r\n            else if (prev != Location.inside) {\r\n                // passing right through rect. 'ip' here will be the second\r\n                // intersect pt but we'll also need the first intersect pt (ip2)\r\n                loc = prev;\r\n                result = RectClip64.getIntersection(this.rectPath, prevPt, path[i], loc);\r\n                const ip2 = result.ip;\r\n                if (prevCrossLoc != Location.inside && prevCrossLoc != loc)\r\n                    this.addCorner(prevCrossLoc, loc);\r\n                if (firstCross == Location.inside) {\r\n                    firstCross = loc;\r\n                    startLocs.push(prev);\r\n                }\r\n                loc = crossingLoc;\r\n                this.add(ip2);\r\n                if (ip == ip2) {\r\n                    loc = RectClip64.getLocation(this.rect, path[i]).loc;\r\n                    this.addCorner(crossingLoc, loc);\r\n                    crossingLoc = loc;\r\n                    continue;\r\n                }\r\n            }\r\n            else {\r\n                loc = crossingLoc;\r\n                if (firstCross == Location.inside)\r\n                    firstCross = crossingLoc;\r\n            }\r\n            this.add(ip);\r\n        } //while i <= highI\r\n        ///////////////////////////////////////////////////\r\n        if (firstCross == Location.inside) {\r\n            if (startingLoc != Location.inside) {\r\n                if (this.pathBounds.containsRect(this.rect) && RectClip64.path1ContainsPath2(path, this.rectPath)) {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        this.add(this.rectPath[j]);\r\n                        RectClip64.addToEdge(this.edges[j * 2], this.results[0]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (loc != Location.inside && (loc != firstCross || startLocs.length > 2)) {\r\n            if (startLocs.length > 0) {\r\n                prev = loc;\r\n                for (const loc2 of startLocs) {\r\n                    if (prev == loc2)\r\n                        continue;\r\n                    this.addCornerByRef(prev, RectClip64.headingClockwise(prev, loc2));\r\n                    prev = loc2;\r\n                }\r\n                loc = prev;\r\n            }\r\n            if (loc != firstCross)\r\n                this.addCornerByRef(loc, RectClip64.headingClockwise(loc, firstCross));\r\n        }\r\n    }\r\n    execute(paths) {\r\n        const result = [];\r\n        if (this.rect.isEmpty())\r\n            return result;\r\n        for (const path of paths) {\r\n            if (path.length < 3)\r\n                continue;\r\n            this.pathBounds = Clipper.getBounds(path);\r\n            if (!this.rect.intersects(this.pathBounds))\r\n                continue;\r\n            else if (this.rect.containsRect(this.pathBounds)) {\r\n                result.push(path);\r\n                continue;\r\n            }\r\n            this.executeInternal(path);\r\n            this.checkEdges();\r\n            for (let i = 0; i < 4; ++i)\r\n                this.tidyEdgePair(i, this.edges[i * 2], this.edges[i * 2 + 1]);\r\n            for (const op of this.results) {\r\n                const tmp = this.getPath(op);\r\n                if (tmp.length > 0)\r\n                    result.push(tmp);\r\n            }\r\n            this.results.length = 0;\r\n            for (let i = 0; i < 8; i++)\r\n                this.edges[i].length = 0;\r\n        }\r\n        return result;\r\n    }\r\n    checkEdges() {\r\n        for (let i = 0; i < this.results.length; i++) {\r\n            let op = this.results[i];\r\n            let op2 = op;\r\n            if (op === undefined)\r\n                continue;\r\n            do {\r\n                if (InternalClipper.crossProduct(op2.prev.pt, op2.pt, op2.next.pt) === 0) {\r\n                    if (op2 === op) {\r\n                        op2 = RectClip64.unlinkOpBack(op2);\r\n                        if (op2 === undefined)\r\n                            break;\r\n                        op = op2.prev;\r\n                    }\r\n                    else {\r\n                        op2 = RectClip64.unlinkOpBack(op2);\r\n                        if (op2 === undefined)\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    op2 = op2.next;\r\n                }\r\n            } while (op2 !== op);\r\n            if (op2 === undefined) {\r\n                this.results[i] = undefined;\r\n                continue;\r\n            }\r\n            this.results[i] = op2;\r\n            let edgeSet1 = RectClip64.getEdgesForPt(op.prev.pt, this.rect);\r\n            op2 = op;\r\n            do {\r\n                const edgeSet2 = RectClip64.getEdgesForPt(op2.pt, this.rect);\r\n                if (edgeSet2 !== 0 && op2.edge === undefined) {\r\n                    const combinedSet = (edgeSet1 & edgeSet2);\r\n                    for (let j = 0; j < 4; ++j) {\r\n                        if ((combinedSet & (1 << j)) !== 0) {\r\n                            if (RectClip64.isHeadingClockwise(op2.prev.pt, op2.pt, j))\r\n                                RectClip64.addToEdge(this.edges[j * 2], op2);\r\n                            else\r\n                                RectClip64.addToEdge(this.edges[j * 2 + 1], op2);\r\n                        }\r\n                    }\r\n                }\r\n                edgeSet1 = edgeSet2;\r\n                op2 = op2.next;\r\n            } while (op2 !== op);\r\n        }\r\n    }\r\n    tidyEdgePair(idx, cw, ccw) {\r\n        if (ccw.length === 0)\r\n            return;\r\n        const isHorz = (idx === 1 || idx === 3);\r\n        const cwIsTowardLarger = (idx === 1 || idx === 2);\r\n        let i = 0, j = 0;\r\n        let p1, p2, p1a, p2a, op, op2;\r\n        while (i < cw.length) {\r\n            p1 = cw[i];\r\n            if (!p1 || p1.next === p1.prev) {\r\n                cw[i++] = undefined;\r\n                j = 0;\r\n                continue;\r\n            }\r\n            const jLim = ccw.length;\r\n            while (j < jLim && (!ccw[j] || ccw[j].next === ccw[j].prev))\r\n                ++j;\r\n            if (j === jLim) {\r\n                ++i;\r\n                j = 0;\r\n                continue;\r\n            }\r\n            if (cwIsTowardLarger) {\r\n                p1 = cw[i].prev;\r\n                p1a = cw[i];\r\n                p2 = ccw[j];\r\n                p2a = ccw[j].prev;\r\n            }\r\n            else {\r\n                p1 = cw[i];\r\n                p1a = cw[i].prev;\r\n                p2 = ccw[j].prev;\r\n                p2a = ccw[j];\r\n            }\r\n            if ((isHorz && !RectClip64.hasHorzOverlap(p1.pt, p1a.pt, p2.pt, p2a.pt)) ||\r\n                (!isHorz && !RectClip64.hasVertOverlap(p1.pt, p1a.pt, p2.pt, p2a.pt))) {\r\n                ++j;\r\n                continue;\r\n            }\r\n            const isRejoining = cw[i].ownerIdx !== ccw[j].ownerIdx;\r\n            if (isRejoining) {\r\n                this.results[p2.ownerIdx] = undefined;\r\n                RectClip64.setNewOwner(p2, p1.ownerIdx);\r\n            }\r\n            if (cwIsTowardLarger) {\r\n                // p1 >> | >> p1a;\r\n                // p2 << | << p2a;\r\n                p1.next = p2;\r\n                p2.prev = p1;\r\n                p1a.prev = p2a;\r\n                p2a.next = p1a;\r\n            }\r\n            else {\r\n                // p1 << | << p1a;\r\n                // p2 >> | >> p2a;\r\n                p1.prev = p2;\r\n                p2.next = p1;\r\n                p1a.next = p2a;\r\n                p2a.prev = p1a;\r\n            }\r\n            if (!isRejoining) {\r\n                const new_idx = this.results.length;\r\n                this.results.push(p1a);\r\n                RectClip64.setNewOwner(p1a, new_idx);\r\n            }\r\n            if (cwIsTowardLarger) {\r\n                op = p2;\r\n                op2 = p1a;\r\n            }\r\n            else {\r\n                op = p1;\r\n                op2 = p2a;\r\n            }\r\n            this.results[op.ownerIdx] = op;\r\n            this.results[op2.ownerIdx] = op2;\r\n            // and now lots of work to get ready for the next loop\r\n            let opIsLarger, op2IsLarger;\r\n            if (isHorz) { // X\r\n                opIsLarger = op.pt.x > op.prev.pt.x;\r\n                op2IsLarger = op2.pt.x > op2.prev.pt.x;\r\n            }\r\n            else { // Y\r\n                opIsLarger = op.pt.y > op.prev.pt.y;\r\n                op2IsLarger = op2.pt.y > op2.prev.pt.y;\r\n            }\r\n            if ((op.next === op.prev) || (op.pt === op.prev.pt)) {\r\n                if (op2IsLarger === cwIsTowardLarger) {\r\n                    cw[i] = op2;\r\n                    ccw[j++] = undefined;\r\n                }\r\n                else {\r\n                    ccw[j] = op2;\r\n                    cw[i++] = undefined;\r\n                }\r\n            }\r\n            else if ((op2.next === op2.prev) || (op2.pt === op2.prev.pt)) {\r\n                if (opIsLarger === cwIsTowardLarger) {\r\n                    cw[i] = op;\r\n                    ccw[j++] = undefined;\r\n                }\r\n                else {\r\n                    ccw[j] = op;\r\n                    cw[i++] = undefined;\r\n                }\r\n            }\r\n            else if (opIsLarger === op2IsLarger) {\r\n                if (opIsLarger === cwIsTowardLarger) {\r\n                    cw[i] = op;\r\n                    RectClip64.uncoupleEdge(op2);\r\n                    RectClip64.addToEdge(cw, op2);\r\n                    ccw[j++] = undefined;\r\n                }\r\n                else {\r\n                    cw[i++] = undefined;\r\n                    ccw[j] = op2;\r\n                    RectClip64.uncoupleEdge(op);\r\n                    RectClip64.addToEdge(ccw, op);\r\n                    j = 0;\r\n                }\r\n            }\r\n            else {\r\n                if (opIsLarger === cwIsTowardLarger)\r\n                    cw[i] = op;\r\n                else\r\n                    ccw[j] = op;\r\n                if (op2IsLarger === cwIsTowardLarger)\r\n                    cw[i] = op2;\r\n                else\r\n                    ccw[j] = op2;\r\n            }\r\n        }\r\n    }\r\n    getPath(op) {\r\n        const result = new Path64();\r\n        if (!op || op.prev === op.next)\r\n            return result;\r\n        let op2 = op.next;\r\n        while (op2 && op2 !== op) {\r\n            if (InternalClipper.crossProduct(op2.prev.pt, op2.pt, op2.next.pt) === 0) {\r\n                op = op2.prev;\r\n                op2 = RectClip64.unlinkOp(op2);\r\n            }\r\n            else {\r\n                op2 = op2.next;\r\n            }\r\n        }\r\n        if (!op2)\r\n            return new Path64();\r\n        result.push(op.pt);\r\n        op2 = op.next;\r\n        while (op2 !== op) {\r\n            result.push(op2.pt);\r\n            op2 = op2.next;\r\n        }\r\n        return result;\r\n    }\r\n}\r\nclass RectClipLines64 extends RectClip64 {\r\n    constructor(rect) {\r\n        super(rect);\r\n    }\r\n    execute(paths) {\r\n        const result = new Paths64();\r\n        if (this.rect.isEmpty())\r\n            return result;\r\n        for (const path of paths) {\r\n            if (path.length < 2)\r\n                continue;\r\n            this.pathBounds = Clipper.getBounds(path);\r\n            if (!this.rect.intersects(this.pathBounds))\r\n                continue;\r\n            this.executeInternal(path);\r\n            for (const op of this.results) {\r\n                const tmp = this.getPath(op);\r\n                if (tmp.length > 0)\r\n                    result.push(tmp);\r\n            }\r\n            // Clean up after every loop\r\n            this.results.length = 0; // Clear the array\r\n            for (let i = 0; i < 8; i++) {\r\n                this.edges[i].length = 0; // Clear each array\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getPath(op) {\r\n        const result = new Path64();\r\n        if (!op || op === op.next)\r\n            return result;\r\n        op = op.next; // starting at path beginning \r\n        result.push(op.pt);\r\n        let op2 = op.next;\r\n        while (op2 !== op) {\r\n            result.push(op2.pt);\r\n            op2 = op2.next;\r\n        }\r\n        return result;\r\n    }\r\n    executeInternal(path) {\r\n        this.results = [];\r\n        if (path.length < 2 || this.rect.isEmpty())\r\n            return;\r\n        let prev = Location.inside;\r\n        let i = 1;\r\n        const highI = path.length - 1;\r\n        let result = RectClipLines64.getLocation(this.rect, path[0]);\r\n        let loc = result.loc;\r\n        if (!result.success) {\r\n            while (i <= highI && !result.success) {\r\n                i++;\r\n                result = RectClipLines64.getLocation(this.rect, path[i]);\r\n                prev = result.loc;\r\n            }\r\n            if (i > highI) {\r\n                for (const pt of path)\r\n                    this.add(pt);\r\n            }\r\n            if (prev == Location.inside)\r\n                loc = Location.inside;\r\n            i = 1;\r\n        }\r\n        if (loc == Location.inside)\r\n            this.add(path[0]);\r\n        while (i <= highI) {\r\n            prev = loc;\r\n            this.getNextLocation(path, { loc, i, highI });\r\n            if (i > highI)\r\n                break;\r\n            const prevPt = path[i - 1];\r\n            let crossingLoc = loc;\r\n            let result = RectClipLines64.getIntersection(this.rectPath, path[i], prevPt, crossingLoc);\r\n            const ip = result.ip;\r\n            crossingLoc = result.loc;\r\n            if (!result.success) {\r\n                i++;\r\n                continue;\r\n            }\r\n            if (loc == Location.inside) {\r\n                this.add(ip, true);\r\n            }\r\n            else if (prev !== Location.inside) {\r\n                crossingLoc = prev;\r\n                result = RectClipLines64.getIntersection(this.rectPath, prevPt, path[i], crossingLoc);\r\n                const ip2 = result.ip;\r\n                crossingLoc = result.loc;\r\n                this.add(ip2);\r\n                this.add(ip);\r\n            }\r\n            else {\r\n                this.add(ip);\r\n            }\r\n        }\r\n    }\r\n}\n\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  16 July 2023                                                    *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  This module contains simple functions that will likely cover    *\r\n*              most polygon boolean and offsetting needs, while also avoiding  *\r\n*              the inherent complexities of the other modules.                 *\r\n* Thanks    :  Special thanks to Thong Nguyen, Guus Kuiper, Phil Stopford,     *\r\n*           :  and Daniel Gosnell for their invaluable assistance with C#.     *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\nclass Clipper {\r\n    static get InvalidRect64() {\r\n        if (!Clipper.invalidRect64)\r\n            Clipper.invalidRect64 = new Rect64(false);\r\n        return this.invalidRect64;\r\n    }\r\n    static Intersect(subject, clip, fillRule) {\r\n        return this.BooleanOp(ClipType.Intersection, subject, clip, fillRule);\r\n    }\r\n    static Union(subject, clip, fillRule = FillRule.EvenOdd) {\r\n        return this.BooleanOp(ClipType.Union, subject, clip, fillRule);\r\n    }\r\n    static Difference(subject, clip, fillRule) {\r\n        return this.BooleanOp(ClipType.Difference, subject, clip, fillRule);\r\n    }\r\n    static Xor(subject, clip, fillRule) {\r\n        return this.BooleanOp(ClipType.Xor, subject, clip, fillRule);\r\n    }\r\n    static BooleanOp(clipType, subject, clip, fillRule = FillRule.EvenOdd) {\r\n        const solution = new Paths64();\r\n        if (!subject)\r\n            return solution;\r\n        const c = new Clipper64();\r\n        c.addPaths(subject, PathType.Subject);\r\n        if (clip)\r\n            c.addPaths(clip, PathType.Clip);\r\n        c.execute(clipType, fillRule, solution);\r\n        return solution;\r\n    }\r\n    //public static BooleanOp(clipType: ClipType, subject: Paths64, clip: Paths64, polytree: PolyTree64, fillRule: FillRule): void {\r\n    //  if (!subject) return;\r\n    //  const c: Clipper64 = new Clipper64();\r\n    //  c.addPaths(subject, PathType.Subject);\r\n    //  if (clip)\r\n    //    c.addPaths(clip, PathType.Clip);\r\n    //  c.execute(clipType, fillRule, polytree);\r\n    //}\r\n    static InflatePaths(paths, delta, joinType, endType, miterLimit = 2.0) {\r\n        const co = new ClipperOffset(miterLimit);\r\n        co.addPaths(paths, joinType, endType);\r\n        const solution = new Paths64();\r\n        co.execute(delta, solution);\r\n        return solution;\r\n    }\r\n    static RectClipPaths(rect, paths) {\r\n        if (rect.isEmpty() || paths.length === 0)\r\n            return new Paths64();\r\n        const rc = new RectClip64(rect);\r\n        return rc.execute(paths);\r\n    }\r\n    static RectClip(rect, path) {\r\n        if (rect.isEmpty() || path.length === 0)\r\n            return new Paths64();\r\n        const tmp = new Paths64();\r\n        tmp.push(path);\r\n        return this.RectClipPaths(rect, tmp);\r\n    }\r\n    static RectClipLinesPaths(rect, paths) {\r\n        if (rect.isEmpty() || paths.length === 0)\r\n            return new Paths64();\r\n        const rc = new RectClipLines64(rect);\r\n        return rc.execute(paths);\r\n    }\r\n    static RectClipLines(rect, path) {\r\n        if (rect.isEmpty() || path.length === 0)\r\n            return new Paths64();\r\n        const tmp = new Paths64();\r\n        tmp.push(path);\r\n        return this.RectClipLinesPaths(rect, tmp);\r\n    }\r\n    static MinkowskiSum(pattern, path, isClosed) {\r\n        return Minkowski.sum(pattern, path, isClosed);\r\n    }\r\n    static MinkowskiDiff(pattern, path, isClosed) {\r\n        return Minkowski.diff(pattern, path, isClosed);\r\n    }\r\n    static area(path) {\r\n        // https://en.wikipedia.org/wiki/Shoelace_formula\r\n        let a = 0.0;\r\n        const cnt = path.length;\r\n        if (cnt < 3)\r\n            return 0.0;\r\n        let prevPt = path[cnt - 1];\r\n        for (const pt of path) {\r\n            a += (prevPt.y + pt.y) * (prevPt.x - pt.x);\r\n            prevPt = pt;\r\n        }\r\n        return a * 0.5;\r\n    }\r\n    static areaPaths(paths) {\r\n        let a = 0.0;\r\n        for (const path of paths)\r\n            a += this.area(path);\r\n        return a;\r\n    }\r\n    static isPositive(poly) {\r\n        return this.area(poly) >= 0;\r\n    }\r\n    static path64ToString(path) {\r\n        let result = \"\";\r\n        for (const pt of path)\r\n            result += pt.toString();\r\n        return result + '\\n';\r\n    }\r\n    static paths64ToString(paths) {\r\n        let result = \"\";\r\n        for (const path of paths)\r\n            result += this.path64ToString(path);\r\n        return result;\r\n    }\r\n    static offsetPath(path, dx, dy) {\r\n        const result = new Path64();\r\n        for (const pt of path)\r\n            result.push(new Point64(pt.x + dx, pt.y + dy));\r\n        return result;\r\n    }\r\n    static scalePoint64(pt, scale) {\r\n        const result = new Point64(Math.round(pt.x * scale), Math.round(pt.y * scale));\r\n        return result;\r\n    }\r\n    static scalePath(path, scale) {\r\n        if (InternalClipper.isAlmostZero(scale - 1))\r\n            return path;\r\n        const result = [];\r\n        for (const pt of path)\r\n            result.push({ x: pt.x * scale, y: pt.y * scale });\r\n        return result;\r\n    }\r\n    static scalePaths(paths, scale) {\r\n        if (InternalClipper.isAlmostZero(scale - 1))\r\n            return paths;\r\n        const result = [];\r\n        for (const path of paths)\r\n            result.push(this.scalePath(path, scale));\r\n        return result;\r\n    }\r\n    static translatePath(path, dx, dy) {\r\n        const result = [];\r\n        for (const pt of path) {\r\n            result.push({ x: pt.x + dx, y: pt.y + dy });\r\n        }\r\n        return result;\r\n    }\r\n    static translatePaths(paths, dx, dy) {\r\n        const result = [];\r\n        for (const path of paths) {\r\n            result.push(this.translatePath(path, dx, dy));\r\n        }\r\n        return result;\r\n    }\r\n    static reversePath(path) {\r\n        return [...path].reverse();\r\n    }\r\n    static reversePaths(paths) {\r\n        const result = [];\r\n        for (const t of paths) {\r\n            result.push(this.reversePath(t));\r\n        }\r\n        return result;\r\n    }\r\n    static getBounds(path) {\r\n        const result = Clipper.InvalidRect64;\r\n        for (const pt of path) {\r\n            if (pt.x < result.left)\r\n                result.left = pt.x;\r\n            if (pt.x > result.right)\r\n                result.right = pt.x;\r\n            if (pt.y < result.top)\r\n                result.top = pt.y;\r\n            if (pt.y > result.bottom)\r\n                result.bottom = pt.y;\r\n        }\r\n        return result.left === Number.MAX_SAFE_INTEGER ? new Rect64(0, 0, 0, 0) : result;\r\n    }\r\n    static getBoundsPaths(paths) {\r\n        const result = Clipper.InvalidRect64;\r\n        for (const path of paths) {\r\n            for (const pt of path) {\r\n                if (pt.x < result.left)\r\n                    result.left = pt.x;\r\n                if (pt.x > result.right)\r\n                    result.right = pt.x;\r\n                if (pt.y < result.top)\r\n                    result.top = pt.y;\r\n                if (pt.y > result.bottom)\r\n                    result.bottom = pt.y;\r\n            }\r\n        }\r\n        return result.left === Number.MAX_SAFE_INTEGER ? new Rect64(0, 0, 0, 0) : result;\r\n    }\r\n    static makePath(arr) {\r\n        const len = arr.length / 2;\r\n        const p = new Path64();\r\n        for (let i = 0; i < len; i++)\r\n            p.push(new Point64(arr[i * 2], arr[i * 2 + 1]));\r\n        return p;\r\n    }\r\n    static stripDuplicates(path, isClosedPath) {\r\n        const cnt = path.length;\r\n        const result = new Path64();\r\n        if (cnt === 0)\r\n            return result;\r\n        let lastPt = path[0];\r\n        result.push(lastPt);\r\n        for (let i = 1; i < cnt; i++)\r\n            if (lastPt !== path[i]) {\r\n                lastPt = path[i];\r\n                result.push(lastPt);\r\n            }\r\n        if (isClosedPath && lastPt === result[0])\r\n            result.pop();\r\n        return result;\r\n    }\r\n    static addPolyNodeToPaths(polyPath, paths) {\r\n        if (polyPath.polygon && polyPath.polygon.length > 0)\r\n            paths.push(polyPath.polygon);\r\n        for (let i = 0; i < polyPath.count; i++)\r\n            this.addPolyNodeToPaths(polyPath.children[i], paths);\r\n    }\r\n    static polyTreeToPaths64(polyTree) {\r\n        const result = new Paths64();\r\n        for (let i = 0; i < polyTree.count; i++) {\r\n            Clipper.addPolyNodeToPaths(polyTree.children[i], result);\r\n        }\r\n        return result;\r\n    }\r\n    static perpendicDistFromLineSqrd(pt, line1, line2) {\r\n        const a = pt.x - line1.x;\r\n        const b = pt.y - line1.y;\r\n        const c = line2.x - line1.x;\r\n        const d = line2.y - line1.y;\r\n        if (c === 0 && d === 0)\r\n            return 0;\r\n        return Clipper.sqr(a * d - c * b) / (c * c + d * d);\r\n    }\r\n    static rdp(path, begin, end, epsSqrd, flags) {\r\n        let idx = 0;\r\n        let max_d = 0;\r\n        while (end > begin && path[begin] === path[end]) {\r\n            flags[end--] = false;\r\n        }\r\n        for (let i = begin + 1; i < end; i++) {\r\n            const d = Clipper.perpendicDistFromLineSqrd(path[i], path[begin], path[end]);\r\n            if (d <= max_d)\r\n                continue;\r\n            max_d = d;\r\n            idx = i;\r\n        }\r\n        if (max_d <= epsSqrd)\r\n            return;\r\n        flags[idx] = true;\r\n        if (idx > begin + 1)\r\n            Clipper.rdp(path, begin, idx, epsSqrd, flags);\r\n        if (idx < end - 1)\r\n            Clipper.rdp(path, idx, end, epsSqrd, flags);\r\n    }\r\n    static ramerDouglasPeucker(path, epsilon) {\r\n        const len = path.length;\r\n        if (len < 5)\r\n            return path;\r\n        const flags = new Array(len).fill(false);\r\n        flags[0] = true;\r\n        flags[len - 1] = true;\r\n        Clipper.rdp(path, 0, len - 1, Clipper.sqr(epsilon), flags);\r\n        const result = [];\r\n        for (let i = 0; i < len; i++) {\r\n            if (flags[i])\r\n                result.push(path[i]);\r\n        }\r\n        return result;\r\n    }\r\n    static ramerDouglasPeuckerPaths(paths, epsilon) {\r\n        const result = [];\r\n        for (const path of paths) {\r\n            result.push(Clipper.ramerDouglasPeucker(path, epsilon));\r\n        }\r\n        return result;\r\n    }\r\n    static getNext(current, high, flags) {\r\n        current++;\r\n        while (current <= high && flags[current])\r\n            current++;\r\n        if (current <= high)\r\n            return current;\r\n        current = 0;\r\n        while (flags[current])\r\n            current++;\r\n        return current;\r\n    }\r\n    static getPrior(current, high, flags) {\r\n        if (current === 0)\r\n            current = high;\r\n        else\r\n            current--;\r\n        while (current > 0 && flags[current])\r\n            current--;\r\n        if (!flags[current])\r\n            return current;\r\n        current = high;\r\n        while (flags[current])\r\n            current--;\r\n        return current;\r\n    }\r\n    static sqr(value) {\r\n        return value * value;\r\n    }\r\n    static simplifyPath(path, epsilon, isClosedPath = false) {\r\n        const len = path.length;\r\n        const high = len - 1;\r\n        const epsSqr = this.sqr(epsilon);\r\n        if (len < 4)\r\n            return path;\r\n        const flags = new Array(len).fill(false);\r\n        const dsq = new Array(len).fill(0);\r\n        let prev = high;\r\n        let curr = 0;\r\n        let start, next, prior2, next2;\r\n        if (isClosedPath) {\r\n            dsq[0] = this.perpendicDistFromLineSqrd(path[0], path[high], path[1]);\r\n            dsq[high] = this.perpendicDistFromLineSqrd(path[high], path[0], path[high - 1]);\r\n        }\r\n        else {\r\n            dsq[0] = Number.MAX_VALUE;\r\n            dsq[high] = Number.MAX_VALUE;\r\n        }\r\n        for (let i = 1; i < high; i++) {\r\n            dsq[i] = this.perpendicDistFromLineSqrd(path[i], path[i - 1], path[i + 1]);\r\n        }\r\n        for (;;) {\r\n            if (dsq[curr] > epsSqr) {\r\n                start = curr;\r\n                do {\r\n                    curr = this.getNext(curr, high, flags);\r\n                } while (curr !== start && dsq[curr] > epsSqr);\r\n                if (curr === start)\r\n                    break;\r\n            }\r\n            prev = this.getPrior(curr, high, flags);\r\n            next = this.getNext(curr, high, flags);\r\n            if (next === prev)\r\n                break;\r\n            if (dsq[next] < dsq[curr]) {\r\n                flags[next] = true;\r\n                next = this.getNext(next, high, flags);\r\n                next2 = this.getNext(next, high, flags);\r\n                dsq[curr] = this.perpendicDistFromLineSqrd(path[curr], path[prev], path[next]);\r\n                if (next !== high || isClosedPath) {\r\n                    dsq[next] = this.perpendicDistFromLineSqrd(path[next], path[curr], path[next2]);\r\n                }\r\n                curr = next;\r\n            }\r\n            else {\r\n                flags[curr] = true;\r\n                curr = next;\r\n                next = this.getNext(next, high, flags);\r\n                prior2 = this.getPrior(prev, high, flags);\r\n                dsq[curr] = this.perpendicDistFromLineSqrd(path[curr], path[prev], path[next]);\r\n                if (prev !== 0 || isClosedPath) {\r\n                    dsq[prev] = this.perpendicDistFromLineSqrd(path[prev], path[prior2], path[curr]);\r\n                }\r\n            }\r\n        }\r\n        const result = [];\r\n        for (let i = 0; i < len; i++) {\r\n            if (!flags[i])\r\n                result.push(path[i]);\r\n        }\r\n        return result;\r\n    }\r\n    static simplifyPaths(paths, epsilon, isClosedPaths = false) {\r\n        const result = [];\r\n        for (const path of paths) {\r\n            result.push(this.simplifyPath(path, epsilon, isClosedPaths));\r\n        }\r\n        return result;\r\n    }\r\n    //private static getNext(current: number, high: number, flags: boolean[]): number {\r\n    //  current++;\r\n    //  while (current <= high && flags[current]) current++;\r\n    //  return current;\r\n    //}\r\n    //private static getPrior(current: number, high: number, flags: boolean[]): number {\r\n    //  if (current === 0) return high;\r\n    //  current--;\r\n    //  while (current > 0 && flags[current]) current--;\r\n    //  return current;\r\n    //}\r\n    static trimCollinear(path, isOpen = false) {\r\n        let len = path.length;\r\n        let i = 0;\r\n        if (!isOpen) {\r\n            while (i < len - 1 && InternalClipper.crossProduct(path[len - 1], path[i], path[i + 1]) === 0)\r\n                i++;\r\n            while (i < len - 1 && InternalClipper.crossProduct(path[len - 2], path[len - 1], path[i]) === 0)\r\n                len--;\r\n        }\r\n        if (len - i < 3) {\r\n            if (!isOpen || len < 2 || path[0] === path[1]) {\r\n                return [];\r\n            }\r\n            return path;\r\n        }\r\n        const result = [];\r\n        let last = path[i];\r\n        result.push(last);\r\n        for (i++; i < len - 1; i++) {\r\n            if (InternalClipper.crossProduct(last, path[i], path[i + 1]) === 0)\r\n                continue;\r\n            last = path[i];\r\n            result.push(last);\r\n        }\r\n        if (isOpen) {\r\n            result.push(path[len - 1]);\r\n        }\r\n        else if (InternalClipper.crossProduct(last, path[len - 1], result[0]) !== 0) {\r\n            result.push(path[len - 1]);\r\n        }\r\n        else {\r\n            while (result.length > 2 && InternalClipper.crossProduct(result[result.length - 1], result[result.length - 2], result[0]) === 0) {\r\n                result.pop();\r\n            }\r\n            if (result.length < 3)\r\n                result.splice(0, result.length);\r\n        }\r\n        return result;\r\n    }\r\n    static pointInPolygon(pt, polygon) {\r\n        return InternalClipper.pointInPolygon(pt, polygon);\r\n    }\r\n    static ellipse(center, radiusX, radiusY = 0, steps = 0) {\r\n        if (radiusX <= 0)\r\n            return [];\r\n        if (radiusY <= 0)\r\n            radiusY = radiusX;\r\n        if (steps <= 2)\r\n            steps = Math.ceil(Math.PI * Math.sqrt((radiusX + radiusY) / 2));\r\n        const si = Math.sin(2 * Math.PI / steps);\r\n        const co = Math.cos(2 * Math.PI / steps);\r\n        let dx = co, dy = si;\r\n        const result = [{ x: center.x + radiusX, y: center.y }];\r\n        for (let i = 1; i < steps; ++i) {\r\n            result.push({ x: center.x + radiusX * dx, y: center.y + radiusY * dy });\r\n            const x = dx * co - dy * si;\r\n            dy = dy * co + dx * si;\r\n            dx = x;\r\n        }\r\n        return result;\r\n    }\r\n    static showPolyPathStructure(pp, level) {\r\n        const spaces = ' '.repeat(level * 2);\r\n        const caption = pp.isHole ? \"Hole \" : \"Outer \";\r\n        if (pp.count === 0) {\r\n            console.log(spaces + caption);\r\n        }\r\n        else {\r\n            console.log(spaces + caption + `(${pp.count})`);\r\n            pp.forEach(child => this.showPolyPathStructure(child, level + 1));\r\n        }\r\n    }\r\n    static showPolyTreeStructure(polytree) {\r\n        console.log(\"Polytree Root\");\r\n        polytree.forEach(child => this.showPolyPathStructure(child, 1));\r\n    }\r\n}\n\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  27 August 2023                                                  *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  This is the main polygon clipping module                        *\r\n* Thanks    :  Special thanks to Thong Nguyen, Guus Kuiper, Phil Stopford,     *\r\n*           :  and Daniel Gosnell for their invaluable assistance with C#.     *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Engine.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\nvar PointInPolygonResult;\r\n(function (PointInPolygonResult) {\r\n    PointInPolygonResult[PointInPolygonResult[\"IsOn\"] = 0] = \"IsOn\";\r\n    PointInPolygonResult[PointInPolygonResult[\"IsInside\"] = 1] = \"IsInside\";\r\n    PointInPolygonResult[PointInPolygonResult[\"IsOutside\"] = 2] = \"IsOutside\";\r\n})(PointInPolygonResult || (PointInPolygonResult = {}));\r\nvar VertexFlags;\r\n(function (VertexFlags) {\r\n    VertexFlags[VertexFlags[\"None\"] = 0] = \"None\";\r\n    VertexFlags[VertexFlags[\"OpenStart\"] = 1] = \"OpenStart\";\r\n    VertexFlags[VertexFlags[\"OpenEnd\"] = 2] = \"OpenEnd\";\r\n    VertexFlags[VertexFlags[\"LocalMax\"] = 4] = \"LocalMax\";\r\n    VertexFlags[VertexFlags[\"LocalMin\"] = 8] = \"LocalMin\";\r\n})(VertexFlags || (VertexFlags = {}));\r\nclass Vertex {\r\n    constructor(pt, flags, prev) {\r\n        this.pt = pt;\r\n        this.flags = flags;\r\n        this.next = undefined;\r\n        this.prev = prev;\r\n    }\r\n}\r\nclass LocalMinima {\r\n    constructor(vertex, polytype, isOpen = false) {\r\n        this.vertex = vertex;\r\n        this.polytype = polytype;\r\n        this.isOpen = isOpen;\r\n    }\r\n    static equals(lm1, lm2) {\r\n        return lm1.vertex === lm2.vertex;\r\n    }\r\n    static notEquals(lm1, lm2) {\r\n        return lm1.vertex !== lm2.vertex;\r\n    }\r\n}\r\nclass IntersectNode {\r\n    constructor(pt, edge1, edge2) {\r\n        this.pt = pt;\r\n        this.edge1 = edge1;\r\n        this.edge2 = edge2;\r\n    }\r\n}\r\nclass OutPt {\r\n    constructor(pt, outrec) {\r\n        this.pt = pt;\r\n        this.outrec = outrec;\r\n        this.next = this;\r\n        this.prev = this;\r\n        this.horz = undefined;\r\n    }\r\n}\r\nvar JoinWith;\r\n(function (JoinWith) {\r\n    JoinWith[JoinWith[\"None\"] = 0] = \"None\";\r\n    JoinWith[JoinWith[\"Left\"] = 1] = \"Left\";\r\n    JoinWith[JoinWith[\"Right\"] = 2] = \"Right\";\r\n})(JoinWith || (JoinWith = {}));\r\nvar HorzPosition;\r\n(function (HorzPosition) {\r\n    HorzPosition[HorzPosition[\"Bottom\"] = 0] = \"Bottom\";\r\n    HorzPosition[HorzPosition[\"Middle\"] = 1] = \"Middle\";\r\n    HorzPosition[HorzPosition[\"Top\"] = 2] = \"Top\";\r\n})(HorzPosition || (HorzPosition = {}));\r\nclass OutRec {\r\n    constructor(idx) {\r\n        this.idx = idx;\r\n        this.isOpen = false;\r\n    }\r\n}\r\nclass HorzSegment {\r\n    constructor(op) {\r\n        this.leftOp = op;\r\n        this.rightOp = undefined;\r\n        this.leftToRight = true;\r\n    }\r\n}\r\nclass HorzJoin {\r\n    constructor(ltor, rtol) {\r\n        this.op1 = ltor;\r\n        this.op2 = rtol;\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////\r\n// Important: UP and DOWN here are premised on Y-axis positive down\r\n// displays, which is the orientation used in Clipper's development.\r\n///////////////////////////////////////////////////////////////////\r\nclass Active {\r\n    constructor() {\r\n        this.dx = this.windCount = this.windCount2 = 0;\r\n        this.isLeftBound = false;\r\n        this.joinWith = JoinWith.None;\r\n    }\r\n}\r\nclass ClipperEngine {\r\n    static addLocMin(vert, polytype, isOpen, minimaList) {\r\n        // make sure the vertex is added only once ...\r\n        if ((vert.flags & VertexFlags.LocalMin) !== VertexFlags.None)\r\n            return;\r\n        vert.flags |= VertexFlags.LocalMin;\r\n        const lm = new LocalMinima(vert, polytype, isOpen);\r\n        minimaList.push(lm);\r\n    }\r\n    static addPathsToVertexList(paths, polytype, isOpen, minimaList, vertexList) {\r\n        let totalVertCnt = 0;\r\n        for (const path of paths)\r\n            totalVertCnt += path.length;\r\n        for (const path of paths) {\r\n            let v0 = undefined;\r\n            let prev_v = undefined;\r\n            let curr_v = undefined;\r\n            for (const pt of path) {\r\n                if (!v0) {\r\n                    v0 = new Vertex(pt, VertexFlags.None, undefined);\r\n                    vertexList.push(v0);\r\n                    prev_v = v0;\r\n                }\r\n                else if (prev_v.pt !== pt) { // i.e., skips duplicates\r\n                    curr_v = new Vertex(pt, VertexFlags.None, prev_v);\r\n                    vertexList.push(curr_v);\r\n                    prev_v.next = curr_v;\r\n                    prev_v = curr_v;\r\n                }\r\n            }\r\n            if (!prev_v || !prev_v.prev)\r\n                continue;\r\n            if (!isOpen && prev_v.pt === v0.pt)\r\n                prev_v = prev_v.prev;\r\n            prev_v.next = v0;\r\n            v0.prev = prev_v;\r\n            if (!isOpen && prev_v.next === prev_v)\r\n                continue;\r\n            // OK, we have a valid path\r\n            let going_up = false;\r\n            if (isOpen) {\r\n                curr_v = v0.next;\r\n                let count = 0;\r\n                while (curr_v !== v0 && curr_v.pt.y === v0.pt.y) {\r\n                    curr_v = curr_v.next;\r\n                    if (count++ > totalVertCnt) {\r\n                        console.warn('infinite loop detected');\r\n                        break;\r\n                    }\r\n                }\r\n                going_up = curr_v.pt.y <= v0.pt.y;\r\n                if (going_up) {\r\n                    v0.flags = VertexFlags.OpenStart;\r\n                    this.addLocMin(v0, polytype, true, minimaList);\r\n                }\r\n                else {\r\n                    v0.flags = VertexFlags.OpenStart | VertexFlags.LocalMax;\r\n                }\r\n            }\r\n            else { // closed path\r\n                prev_v = v0.prev;\r\n                let count = 0;\r\n                while (prev_v !== v0 && prev_v.pt.y === v0.pt.y) {\r\n                    prev_v = prev_v.prev;\r\n                    if (count++ > totalVertCnt) {\r\n                        console.warn('infinite loop detected');\r\n                        break;\r\n                    }\r\n                }\r\n                if (prev_v === v0) {\r\n                    continue; // only open paths can be completely flat\r\n                }\r\n                going_up = prev_v.pt.y > v0.pt.y;\r\n            }\r\n            const going_up0 = going_up;\r\n            prev_v = v0;\r\n            curr_v = v0.next;\r\n            let count = 0;\r\n            while (curr_v !== v0) {\r\n                if (curr_v.pt.y > prev_v.pt.y && going_up) {\r\n                    prev_v.flags |= VertexFlags.LocalMax;\r\n                    going_up = false;\r\n                }\r\n                else if (curr_v.pt.y < prev_v.pt.y && !going_up) {\r\n                    going_up = true;\r\n                    this.addLocMin(prev_v, polytype, isOpen, minimaList);\r\n                }\r\n                prev_v = curr_v;\r\n                curr_v = curr_v.next;\r\n                if (count++ > totalVertCnt) {\r\n                    console.warn('infinite loop detected');\r\n                    break;\r\n                }\r\n            }\r\n            if (isOpen) {\r\n                prev_v.flags |= VertexFlags.OpenEnd;\r\n                if (going_up) {\r\n                    prev_v.flags |= VertexFlags.LocalMax;\r\n                }\r\n                else {\r\n                    this.addLocMin(prev_v, polytype, isOpen, minimaList);\r\n                }\r\n            }\r\n            else if (going_up !== going_up0) {\r\n                if (going_up0) {\r\n                    this.addLocMin(prev_v, polytype, false, minimaList);\r\n                }\r\n                else {\r\n                    prev_v.flags |= VertexFlags.LocalMax;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nclass ReuseableDataContainer64 {\r\n    constructor() {\r\n        this._minimaList = [];\r\n        this._vertexList = [];\r\n    }\r\n    clear() {\r\n        this._minimaList.length = 0;\r\n        this._vertexList.length = 0;\r\n    }\r\n    addPaths(paths, pt, isOpen) {\r\n        ClipperEngine.addPathsToVertexList(paths, pt, isOpen, this._minimaList, this._vertexList);\r\n    }\r\n}\r\nclass SimpleNavigableSet {\r\n    constructor() {\r\n        this.items = [];\r\n        this.items = [];\r\n    }\r\n    clear() { this.items.length = 0; }\r\n    isEmpty() { return this.items.length == 0; }\r\n    pollLast() {\r\n        return this.items.pop();\r\n    }\r\n    add(item) {\r\n        if (!this.items.includes(item)) {\r\n            this.items.push(item);\r\n            this.items.sort((a, b) => a - b);\r\n        }\r\n    }\r\n}\r\nclass ClipperBase {\r\n    constructor() {\r\n        this._cliptype = ClipType.None;\r\n        this._fillrule = FillRule.EvenOdd;\r\n        this._currentLocMin = 0;\r\n        this._currentBotY = 0;\r\n        this._isSortedMinimaList = false;\r\n        this._hasOpenPaths = false;\r\n        this._using_polytree = false;\r\n        this._succeeded = false;\r\n        this.reverseSolution = false;\r\n        this._minimaList = [];\r\n        this._intersectList = [];\r\n        this._vertexList = [];\r\n        this._outrecList = [];\r\n        this._scanlineList = new SimpleNavigableSet();\r\n        this._horzSegList = [];\r\n        this._horzJoinList = [];\r\n        this.preserveCollinear = true;\r\n    }\r\n    static isOdd(val) {\r\n        return ((val & 1) !== 0);\r\n    }\r\n    static isHotEdgeActive(ae) {\r\n        return ae.outrec !== undefined;\r\n    }\r\n    static isOpen(ae) {\r\n        return ae.localMin.isOpen;\r\n    }\r\n    static isOpenEndActive(ae) {\r\n        return ae.localMin.isOpen && ClipperBase.isOpenEnd(ae.vertexTop);\r\n    }\r\n    static isOpenEnd(v) {\r\n        return (v.flags & (VertexFlags.OpenStart | VertexFlags.OpenEnd)) !== VertexFlags.None;\r\n    }\r\n    static getPrevHotEdge(ae) {\r\n        let prev = ae.prevInAEL;\r\n        while (prev && (ClipperBase.isOpen(prev) || !ClipperBase.isHotEdgeActive(prev)))\r\n            prev = prev.prevInAEL;\r\n        return prev;\r\n    }\r\n    static isFront(ae) {\r\n        return ae === ae.outrec.frontEdge;\r\n    }\r\n    /*******************************************************************************\r\n    *  Dx:                             0(90deg)                                    *\r\n    *                                  |                                           *\r\n    *               +inf (180deg) <--- o --. -inf (0deg)                          *\r\n    *******************************************************************************/\r\n    static getDx(pt1, pt2) {\r\n        const dy = pt2.y - pt1.y;\r\n        if (dy !== 0)\r\n            return (pt2.x - pt1.x) / dy;\r\n        if (pt2.x > pt1.x)\r\n            return Number.NEGATIVE_INFINITY;\r\n        return Number.POSITIVE_INFINITY;\r\n    }\r\n    static topX(ae, currentY) {\r\n        if ((currentY === ae.top.y) || (ae.top.x === ae.bot.x))\r\n            return ae.top.x;\r\n        if (currentY === ae.bot.y)\r\n            return ae.bot.x;\r\n        return ae.bot.x + Math.round(ae.dx * (currentY - ae.bot.y));\r\n    }\r\n    static isHorizontal(ae) {\r\n        return (ae.top.y === ae.bot.y);\r\n    }\r\n    static isHeadingRightHorz(ae) {\r\n        return (Number.NEGATIVE_INFINITY === ae.dx);\r\n    }\r\n    static isHeadingLeftHorz(ae) {\r\n        return (Number.POSITIVE_INFINITY === ae.dx);\r\n    }\r\n    static swapActives(ae1, ae2) {\r\n        [ae2, ae1] = [ae1, ae2];\r\n    }\r\n    static getPolyType(ae) {\r\n        return ae.localMin.polytype;\r\n    }\r\n    static isSamePolyType(ae1, ae2) {\r\n        return ae1.localMin.polytype === ae2.localMin.polytype;\r\n    }\r\n    static setDx(ae) {\r\n        ae.dx = ClipperBase.getDx(ae.bot, ae.top);\r\n    }\r\n    static nextVertex(ae) {\r\n        if (ae.windDx > 0)\r\n            return ae.vertexTop.next;\r\n        return ae.vertexTop.prev;\r\n    }\r\n    static prevPrevVertex(ae) {\r\n        if (ae.windDx > 0)\r\n            return ae.vertexTop.prev.prev;\r\n        return ae.vertexTop.next.next;\r\n    }\r\n    static isMaxima(vertex) {\r\n        return (vertex.flags & VertexFlags.LocalMax) !== VertexFlags.None;\r\n    }\r\n    static isMaximaActive(ae) {\r\n        return ClipperBase.isMaxima(ae.vertexTop);\r\n    }\r\n    static getMaximaPair(ae) {\r\n        let ae2 = ae.nextInAEL;\r\n        while (ae2) {\r\n            if (ae2.vertexTop === ae.vertexTop)\r\n                return ae2; // Found!\r\n            ae2 = ae2.nextInAEL;\r\n        }\r\n        return undefined;\r\n    }\r\n    static getCurrYMaximaVertex_Open(ae) {\r\n        let result = ae.vertexTop;\r\n        if (ae.windDx > 0) {\r\n            while (result.next.pt.y === result.pt.y &&\r\n                ((result.flags & (VertexFlags.OpenEnd |\r\n                    VertexFlags.LocalMax)) === VertexFlags.None))\r\n                result = result.next;\r\n        }\r\n        else {\r\n            while (result.prev.pt.y === result.pt.y &&\r\n                ((result.flags & (VertexFlags.OpenEnd |\r\n                    VertexFlags.LocalMax)) === VertexFlags.None))\r\n                result = result.prev;\r\n        }\r\n        if (!ClipperBase.isMaxima(result))\r\n            result = undefined; // not a maxima\r\n        return result;\r\n    }\r\n    static getCurrYMaximaVertex(ae) {\r\n        let result = ae.vertexTop;\r\n        if (ae.windDx > 0) {\r\n            while (result.next.pt.y === result.pt.y)\r\n                result = result.next;\r\n        }\r\n        else {\r\n            while (result.prev.pt.y === result.pt.y)\r\n                result = result.prev;\r\n        }\r\n        if (!ClipperBase.isMaxima(result))\r\n            result = undefined; // not a maxima\r\n        return result;\r\n    }\r\n    static setSides(outrec, startEdge, endEdge) {\r\n        outrec.frontEdge = startEdge;\r\n        outrec.backEdge = endEdge;\r\n    }\r\n    static swapOutrecs(ae1, ae2) {\r\n        const or1 = ae1.outrec;\r\n        const or2 = ae2.outrec;\r\n        if (or1 === or2) {\r\n            const ae = or1.frontEdge;\r\n            or1.frontEdge = or1.backEdge;\r\n            or1.backEdge = ae;\r\n            return;\r\n        }\r\n        if (or1) {\r\n            if (ae1 === or1.frontEdge)\r\n                or1.frontEdge = ae2;\r\n            else\r\n                or1.backEdge = ae2;\r\n        }\r\n        if (or2) {\r\n            if (ae2 === or2.frontEdge)\r\n                or2.frontEdge = ae1;\r\n            else\r\n                or2.backEdge = ae1;\r\n        }\r\n        ae1.outrec = or2;\r\n        ae2.outrec = or1;\r\n    }\r\n    static setOwner(outrec, newOwner) {\r\n        while (newOwner.owner && !newOwner.owner.pts) {\r\n            newOwner.owner = newOwner.owner.owner;\r\n        }\r\n        //make sure that outrec isn't an owner of newOwner\r\n        let tmp = newOwner;\r\n        while (tmp && tmp !== outrec)\r\n            tmp = tmp.owner;\r\n        if (tmp)\r\n            newOwner.owner = outrec.owner;\r\n        outrec.owner = newOwner;\r\n    }\r\n    static area(op) {\r\n        // https://en.wikipedia.org/wiki/Shoelace_formula\r\n        let area = 0.0;\r\n        let op2 = op;\r\n        do {\r\n            area += (op2.prev.pt.y + op2.pt.y) *\r\n                (op2.prev.pt.x - op2.pt.x);\r\n            op2 = op2.next;\r\n        } while (op2 !== op);\r\n        return area * 0.5;\r\n    }\r\n    static areaTriangle(pt1, pt2, pt3) {\r\n        return (pt3.y + pt1.y) * (pt3.x - pt1.x) +\r\n            (pt1.y + pt2.y) * (pt1.x - pt2.x) +\r\n            (pt2.y + pt3.y) * (pt2.x - pt3.x);\r\n    }\r\n    static getRealOutRec(outRec) {\r\n        while (outRec !== undefined && outRec.pts === undefined) {\r\n            outRec = outRec.owner;\r\n        }\r\n        return outRec;\r\n    }\r\n    static isValidOwner(outRec, testOwner) {\r\n        while (testOwner !== undefined && testOwner !== outRec)\r\n            testOwner = testOwner.owner;\r\n        return testOwner === undefined;\r\n    }\r\n    static uncoupleOutRec(ae) {\r\n        const outrec = ae.outrec;\r\n        if (outrec === undefined)\r\n            return;\r\n        outrec.frontEdge.outrec = undefined;\r\n        outrec.backEdge.outrec = undefined;\r\n        outrec.frontEdge = undefined;\r\n        outrec.backEdge = undefined;\r\n    }\r\n    static outrecIsAscending(hotEdge) {\r\n        return (hotEdge === hotEdge.outrec.frontEdge);\r\n    }\r\n    static swapFrontBackSides(outrec) {\r\n        // while this proc. is needed for open paths\r\n        // it's almost never needed for closed paths\r\n        const ae2 = outrec.frontEdge;\r\n        outrec.frontEdge = outrec.backEdge;\r\n        outrec.backEdge = ae2;\r\n        outrec.pts = outrec.pts.next;\r\n    }\r\n    static edgesAdjacentInAEL(inode) {\r\n        return (inode.edge1.nextInAEL === inode.edge2) || (inode.edge1.prevInAEL === inode.edge2);\r\n    }\r\n    clearSolutionOnly() {\r\n        while (this._actives)\r\n            this.deleteFromAEL(this._actives);\r\n        this._scanlineList.clear();\r\n        this.disposeIntersectNodes();\r\n        this._outrecList.length = 0;\r\n        this._horzSegList.length = 0;\r\n        this._horzJoinList.length = 0;\r\n    }\r\n    clear() {\r\n        this.clearSolutionOnly();\r\n        this._minimaList.length = 0;\r\n        this._vertexList.length = 0;\r\n        this._currentLocMin = 0;\r\n        this._isSortedMinimaList = false;\r\n        this._hasOpenPaths = false;\r\n    }\r\n    reset() {\r\n        if (!this._isSortedMinimaList) {\r\n            this._minimaList.sort((locMin1, locMin2) => locMin2.vertex.pt.y - locMin1.vertex.pt.y);\r\n            this._isSortedMinimaList = true;\r\n        }\r\n        for (let i = this._minimaList.length - 1; i >= 0; i--) {\r\n            this._scanlineList.add(this._minimaList[i].vertex.pt.y);\r\n        }\r\n        this._currentBotY = 0;\r\n        this._currentLocMin = 0;\r\n        this._actives = undefined;\r\n        this._sel = undefined;\r\n        this._succeeded = true;\r\n    }\r\n    insertScanline(y) {\r\n        this._scanlineList.add(y);\r\n    }\r\n    popScanline() {\r\n        return this._scanlineList.pollLast();\r\n    }\r\n    hasLocMinAtY(y) {\r\n        return (this._currentLocMin < this._minimaList.length && this._minimaList[this._currentLocMin].vertex.pt.y == y);\r\n    }\r\n    popLocalMinima() {\r\n        return this._minimaList[this._currentLocMin++];\r\n    }\r\n    addLocMin(vert, polytype, isOpen) {\r\n        // make sure the vertex is added only once ...\r\n        if ((vert.flags & VertexFlags.LocalMin) != VertexFlags.None)\r\n            return;\r\n        vert.flags |= VertexFlags.LocalMin;\r\n        const lm = new LocalMinima(vert, polytype, isOpen);\r\n        this._minimaList.push(lm);\r\n    }\r\n    addSubject(path) {\r\n        this.addPath(path, PathType.Subject);\r\n    }\r\n    addOpenSubject(path) {\r\n        this.addPath(path, PathType.Subject, true);\r\n    }\r\n    addClip(path) {\r\n        this.addPath(path, PathType.Clip);\r\n    }\r\n    addPath(path, polytype, isOpen = false) {\r\n        const tmp = [path];\r\n        this.addPaths(tmp, polytype, isOpen);\r\n    }\r\n    addPaths(paths, polytype, isOpen = false) {\r\n        if (isOpen)\r\n            this._hasOpenPaths = true;\r\n        this._isSortedMinimaList = false;\r\n        ClipperEngine.addPathsToVertexList(paths, polytype, isOpen, this._minimaList, this._vertexList);\r\n    }\r\n    addReuseableData(reuseableData) {\r\n        if (reuseableData._minimaList.length === 0)\r\n            return;\r\n        this._isSortedMinimaList = false;\r\n        for (const lm of reuseableData._minimaList) {\r\n            this._minimaList.push(new LocalMinima(lm.vertex, lm.polytype, lm.isOpen));\r\n            if (lm.isOpen)\r\n                this._hasOpenPaths = true;\r\n        }\r\n    }\r\n    isContributingClosed(ae) {\r\n        switch (this._fillrule) {\r\n            case FillRule.Positive:\r\n                if (ae.windCount !== 1)\r\n                    return false;\r\n                break;\r\n            case FillRule.Negative:\r\n                if (ae.windCount !== -1)\r\n                    return false;\r\n                break;\r\n            case FillRule.NonZero:\r\n                if (Math.abs(ae.windCount) !== 1)\r\n                    return false;\r\n                break;\r\n        }\r\n        switch (this._cliptype) {\r\n            case ClipType.Intersection:\r\n                switch (this._fillrule) {\r\n                    case FillRule.Positive: return ae.windCount2 > 0;\r\n                    case FillRule.Negative: return ae.windCount2 < 0;\r\n                    default: return ae.windCount2 !== 0;\r\n                }\r\n            case ClipType.Union:\r\n                switch (this._fillrule) {\r\n                    case FillRule.Positive: return ae.windCount2 <= 0;\r\n                    case FillRule.Negative: return ae.windCount2 >= 0;\r\n                    default: return ae.windCount2 === 0;\r\n                }\r\n            case ClipType.Difference:\r\n                const result = this._fillrule === FillRule.Positive ? (ae.windCount2 <= 0) :\r\n                    this._fillrule === FillRule.Negative ? (ae.windCount2 >= 0) :\r\n                        (ae.windCount2 === 0);\r\n                return ClipperBase.getPolyType(ae) === PathType.Subject ? result : !result;\r\n            case ClipType.Xor:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    isContributingOpen(ae) {\r\n        let isInClip, isInSubj;\r\n        switch (this._fillrule) {\r\n            case FillRule.Positive:\r\n                isInSubj = ae.windCount > 0;\r\n                isInClip = ae.windCount2 > 0;\r\n                break;\r\n            case FillRule.Negative:\r\n                isInSubj = ae.windCount < 0;\r\n                isInClip = ae.windCount2 < 0;\r\n                break;\r\n            default:\r\n                isInSubj = ae.windCount !== 0;\r\n                isInClip = ae.windCount2 !== 0;\r\n                break;\r\n        }\r\n        switch (this._cliptype) {\r\n            case ClipType.Intersection:\r\n                return isInClip;\r\n            case ClipType.Union:\r\n                return !isInSubj && !isInClip;\r\n            default:\r\n                return !isInClip;\r\n        }\r\n    }\r\n    setWindCountForClosedPathEdge(ae) {\r\n        let ae2 = ae.prevInAEL;\r\n        const pt = ClipperBase.getPolyType(ae);\r\n        while (ae2 !== undefined && (ClipperBase.getPolyType(ae2) !== pt || ClipperBase.isOpen(ae2))) {\r\n            ae2 = ae2.prevInAEL;\r\n        }\r\n        if (ae2 === undefined) {\r\n            ae.windCount = ae.windDx;\r\n            ae2 = this._actives;\r\n        }\r\n        else if (this._fillrule === FillRule.EvenOdd) {\r\n            ae.windCount = ae.windDx;\r\n            ae.windCount2 = ae2.windCount2;\r\n            ae2 = ae2.nextInAEL;\r\n        }\r\n        else {\r\n            // NonZero, positive, or negative filling here ...\r\n            // when e2's WindCnt is in the SAME direction as its WindDx,\r\n            // then polygon will fill on the right of 'e2' (and 'e' will be inside)\r\n            // nb: neither e2.WindCnt nor e2.WindDx should ever be 0.\r\n            if (ae2.windCount * ae2.windDx < 0) {\r\n                // opposite directions so 'ae' is outside 'ae2' ...\r\n                if (Math.abs(ae2.windCount) > 1) {\r\n                    // outside prev poly but still inside another.\r\n                    if (ae2.windDx * ae.windDx < 0)\r\n                        // reversing direction so use the same WC\r\n                        ae.windCount = ae2.windCount;\r\n                    else\r\n                        // otherwise keep 'reducing' the WC by 1 (i.e. towards 0) ...\r\n                        ae.windCount = ae2.windCount + ae.windDx;\r\n                }\r\n                else {\r\n                    // now outside all polys of same polytype so set own WC ...\r\n                    ae.windCount = (ClipperBase.isOpen(ae) ? 1 : ae.windDx);\r\n                }\r\n            }\r\n            else {\r\n                // 'ae' must be inside 'ae2'\r\n                if (ae2.windDx * ae.windDx < 0)\r\n                    // reversing direction so use the same WC\r\n                    ae.windCount = ae2.windCount;\r\n                else\r\n                    // otherwise keep 'increasing' the WC by 1 (i.e. away from 0) ...\r\n                    ae.windCount = ae2.windCount + ae.windDx;\r\n            }\r\n            ae.windCount2 = ae2.windCount2;\r\n            ae2 = ae2.nextInAEL; // i.e. get ready to calc WindCnt2\r\n        }\r\n        if (this._fillrule === FillRule.EvenOdd) {\r\n            while (ae2 !== ae) {\r\n                if (ClipperBase.getPolyType(ae2) !== pt && !ClipperBase.isOpen(ae2)) {\r\n                    ae.windCount2 = (ae.windCount2 === 0 ? 1 : 0);\r\n                }\r\n                ae2 = ae2.nextInAEL;\r\n            }\r\n        }\r\n        else {\r\n            while (ae2 !== ae) {\r\n                if (ClipperBase.getPolyType(ae2) !== pt && !ClipperBase.isOpen(ae2)) {\r\n                    ae.windCount2 += ae2.windDx;\r\n                }\r\n                ae2 = ae2.nextInAEL;\r\n            }\r\n        }\r\n    }\r\n    setWindCountForOpenPathEdge(ae) {\r\n        let ae2 = this._actives;\r\n        if (this._fillrule === FillRule.EvenOdd) {\r\n            let cnt1 = 0, cnt2 = 0;\r\n            while (ae2 !== ae) {\r\n                if (ClipperBase.getPolyType(ae2) === PathType.Clip)\r\n                    cnt2++;\r\n                else if (!ClipperBase.isOpen(ae2))\r\n                    cnt1++;\r\n                ae2 = ae2.nextInAEL;\r\n            }\r\n            ae.windCount = (ClipperBase.isOdd(cnt1) ? 1 : 0);\r\n            ae.windCount2 = (ClipperBase.isOdd(cnt2) ? 1 : 0);\r\n        }\r\n        else {\r\n            while (ae2 !== ae) {\r\n                if (ClipperBase.getPolyType(ae2) === PathType.Clip)\r\n                    ae.windCount2 += ae2.windDx;\r\n                else if (!ClipperBase.isOpen(ae2))\r\n                    ae.windCount += ae2.windDx;\r\n                ae2 = ae2.nextInAEL;\r\n            }\r\n        }\r\n    }\r\n    static isValidAelOrder(resident, newcomer) {\r\n        if (newcomer.curX !== resident.curX)\r\n            return newcomer.curX > resident.curX;\r\n        // get the turning direction  a1.top, a2.bot, a2.top\r\n        const d = InternalClipper.crossProduct(resident.top, newcomer.bot, newcomer.top);\r\n        if (d !== 0.0)\r\n            return (d < 0);\r\n        // edges must be collinear to get here\r\n        // for starting open paths, place them according to\r\n        // the direction they're about to turn\r\n        if (!this.isMaximaActive(resident) && (resident.top.y > newcomer.top.y)) {\r\n            return InternalClipper.crossProduct(newcomer.bot, resident.top, this.nextVertex(resident).pt) <= 0;\r\n        }\r\n        if (!this.isMaximaActive(newcomer) && (newcomer.top.y > resident.top.y)) {\r\n            return InternalClipper.crossProduct(newcomer.bot, newcomer.top, this.nextVertex(newcomer).pt) >= 0;\r\n        }\r\n        const y = newcomer.bot.y;\r\n        const newcomerIsLeft = newcomer.isLeftBound;\r\n        if (resident.bot.y !== y || resident.localMin.vertex.pt.y !== y)\r\n            return newcomer.isLeftBound;\r\n        // resident must also have just been inserted\r\n        if (resident.isLeftBound !== newcomerIsLeft)\r\n            return newcomerIsLeft;\r\n        if (InternalClipper.crossProduct(this.prevPrevVertex(resident).pt, resident.bot, resident.top) === 0)\r\n            return true;\r\n        // compare turning direction of the alternate bound\r\n        return (InternalClipper.crossProduct(this.prevPrevVertex(resident).pt, newcomer.bot, this.prevPrevVertex(newcomer).pt) > 0) === newcomerIsLeft;\r\n    }\r\n    insertLeftEdge(ae) {\r\n        let ae2;\r\n        if (!this._actives) {\r\n            ae.prevInAEL = undefined;\r\n            ae.nextInAEL = undefined;\r\n            this._actives = ae;\r\n        }\r\n        else if (!ClipperBase.isValidAelOrder(this._actives, ae)) {\r\n            ae.prevInAEL = undefined;\r\n            ae.nextInAEL = this._actives;\r\n            this._actives.prevInAEL = ae;\r\n            this._actives = ae;\r\n        }\r\n        else {\r\n            ae2 = this._actives;\r\n            while (ae2.nextInAEL && ClipperBase.isValidAelOrder(ae2.nextInAEL, ae))\r\n                ae2 = ae2.nextInAEL;\r\n            //don't separate joined edges\r\n            if (ae2.joinWith === JoinWith.Right)\r\n                ae2 = ae2.nextInAEL;\r\n            ae.nextInAEL = ae2.nextInAEL;\r\n            if (ae2.nextInAEL)\r\n                ae2.nextInAEL.prevInAEL = ae;\r\n            ae.prevInAEL = ae2;\r\n            ae2.nextInAEL = ae;\r\n        }\r\n    }\r\n    static insertRightEdge(ae, ae2) {\r\n        ae2.nextInAEL = ae.nextInAEL;\r\n        if (ae.nextInAEL)\r\n            ae.nextInAEL.prevInAEL = ae2;\r\n        ae2.prevInAEL = ae;\r\n        ae.nextInAEL = ae2;\r\n    }\r\n    insertLocalMinimaIntoAEL(botY) {\r\n        let localMinima;\r\n        let leftBound;\r\n        let rightBound;\r\n        // Add any local minima (if any) at BotY ...\r\n        // NB horizontal local minima edges should contain locMin.vertex.prev\r\n        while (this.hasLocMinAtY(botY)) {\r\n            localMinima = this.popLocalMinima();\r\n            if ((localMinima.vertex.flags & VertexFlags.OpenStart) !== VertexFlags.None) {\r\n                leftBound = undefined;\r\n            }\r\n            else {\r\n                leftBound = new Active();\r\n                leftBound.bot = localMinima.vertex.pt;\r\n                leftBound.curX = localMinima.vertex.pt.x;\r\n                leftBound.windDx = -1;\r\n                leftBound.vertexTop = localMinima.vertex.prev;\r\n                leftBound.top = localMinima.vertex.prev.pt;\r\n                leftBound.outrec = undefined;\r\n                leftBound.localMin = localMinima;\r\n                ClipperBase.setDx(leftBound);\r\n            }\r\n            if ((localMinima.vertex.flags & VertexFlags.OpenEnd) !== VertexFlags.None) {\r\n                rightBound = undefined;\r\n            }\r\n            else {\r\n                rightBound = new Active();\r\n                rightBound.bot = localMinima.vertex.pt;\r\n                rightBound.curX = localMinima.vertex.pt.x;\r\n                rightBound.windDx = 1;\r\n                rightBound.vertexTop = localMinima.vertex.next;\r\n                rightBound.top = localMinima.vertex.next.pt;\r\n                rightBound.outrec = undefined;\r\n                rightBound.localMin = localMinima;\r\n                ClipperBase.setDx(rightBound);\r\n            }\r\n            if (leftBound && rightBound) {\r\n                if (ClipperBase.isHorizontal(leftBound)) {\r\n                    if (ClipperBase.isHeadingRightHorz(leftBound)) {\r\n                        [rightBound, leftBound] = [leftBound, rightBound];\r\n                    }\r\n                }\r\n                else if (ClipperBase.isHorizontal(rightBound)) {\r\n                    if (ClipperBase.isHeadingLeftHorz(rightBound)) {\r\n                        [rightBound, leftBound] = [leftBound, rightBound];\r\n                    }\r\n                }\r\n                else if (leftBound.dx < rightBound.dx) {\r\n                    [rightBound, leftBound] = [leftBound, rightBound];\r\n                }\r\n                //so when leftBound has windDx == 1, the polygon will be oriented\r\n                //counter-clockwise in Cartesian coords (clockwise with inverted Y).\r\n            }\r\n            else if (leftBound === undefined) {\r\n                leftBound = rightBound;\r\n                rightBound = undefined;\r\n            }\r\n            let contributing = false;\r\n            leftBound.isLeftBound = true;\r\n            this.insertLeftEdge(leftBound);\r\n            if (ClipperBase.isOpen(leftBound)) {\r\n                this.setWindCountForOpenPathEdge(leftBound);\r\n                contributing = this.isContributingOpen(leftBound);\r\n            }\r\n            else {\r\n                this.setWindCountForClosedPathEdge(leftBound);\r\n                contributing = this.isContributingClosed(leftBound);\r\n            }\r\n            if (rightBound) {\r\n                rightBound.windCount = leftBound.windCount;\r\n                rightBound.windCount2 = leftBound.windCount2;\r\n                ClipperBase.insertRightEdge(leftBound, rightBound);\r\n                if (contributing) {\r\n                    this.addLocalMinPoly(leftBound, rightBound, leftBound.bot, true);\r\n                    if (!ClipperBase.isHorizontal(leftBound)) {\r\n                        this.checkJoinLeft(leftBound, leftBound.bot);\r\n                    }\r\n                }\r\n                while (rightBound.nextInAEL &&\r\n                    ClipperBase.isValidAelOrder(rightBound.nextInAEL, rightBound)) {\r\n                    this.intersectEdges(rightBound, rightBound.nextInAEL, rightBound.bot);\r\n                    this.swapPositionsInAEL(rightBound, rightBound.nextInAEL);\r\n                }\r\n                if (ClipperBase.isHorizontal(rightBound)) {\r\n                    this.pushHorz(rightBound);\r\n                }\r\n                else {\r\n                    this.checkJoinRight(rightBound, rightBound.bot);\r\n                    this.insertScanline(rightBound.top.y);\r\n                }\r\n            }\r\n            else if (contributing) {\r\n                this.startOpenPath(leftBound, leftBound.bot);\r\n            }\r\n            if (ClipperBase.isHorizontal(leftBound)) {\r\n                this.pushHorz(leftBound);\r\n            }\r\n            else {\r\n                this.insertScanline(leftBound.top.y);\r\n            }\r\n        }\r\n    }\r\n    pushHorz(ae) {\r\n        ae.nextInSEL = this._sel;\r\n        this._sel = ae;\r\n    }\r\n    popHorz() {\r\n        const ae = this._sel;\r\n        if (this._sel === undefined)\r\n            return undefined;\r\n        this._sel = this._sel.nextInSEL;\r\n        return ae;\r\n    }\r\n    addLocalMinPoly(ae1, ae2, pt, isNew = false) {\r\n        const outrec = this.newOutRec();\r\n        ae1.outrec = outrec;\r\n        ae2.outrec = outrec;\r\n        if (ClipperBase.isOpen(ae1)) {\r\n            outrec.owner = undefined;\r\n            outrec.isOpen = true;\r\n            if (ae1.windDx > 0)\r\n                ClipperBase.setSides(outrec, ae1, ae2);\r\n            else\r\n                ClipperBase.setSides(outrec, ae2, ae1);\r\n        }\r\n        else {\r\n            outrec.isOpen = false;\r\n            const prevHotEdge = ClipperBase.getPrevHotEdge(ae1);\r\n            // e.windDx is the winding direction of the **input** paths\r\n            // and unrelated to the winding direction of output polygons.\r\n            // Output orientation is determined by e.outrec.frontE which is\r\n            // the ascending edge (see AddLocalMinPoly).\r\n            if (prevHotEdge) {\r\n                if (this._using_polytree)\r\n                    ClipperBase.setOwner(outrec, prevHotEdge.outrec);\r\n                outrec.owner = prevHotEdge.outrec;\r\n                if (ClipperBase.outrecIsAscending(prevHotEdge) === isNew)\r\n                    ClipperBase.setSides(outrec, ae2, ae1);\r\n                else\r\n                    ClipperBase.setSides(outrec, ae1, ae2);\r\n            }\r\n            else {\r\n                outrec.owner = undefined;\r\n                if (isNew)\r\n                    ClipperBase.setSides(outrec, ae1, ae2);\r\n                else\r\n                    ClipperBase.setSides(outrec, ae2, ae1);\r\n            }\r\n        }\r\n        const op = new OutPt(pt, outrec);\r\n        outrec.pts = op;\r\n        return op;\r\n    }\r\n    addLocalMaxPoly(ae1, ae2, pt) {\r\n        if (ClipperBase.isJoined(ae1))\r\n            this.split(ae1, pt);\r\n        if (ClipperBase.isJoined(ae2))\r\n            this.split(ae2, pt);\r\n        if (ClipperBase.isFront(ae1) === ClipperBase.isFront(ae2)) {\r\n            if (ClipperBase.isOpenEndActive(ae1))\r\n                ClipperBase.swapFrontBackSides(ae1.outrec);\r\n            else if (ClipperBase.isOpenEndActive(ae2))\r\n                ClipperBase.swapFrontBackSides(ae2.outrec);\r\n            else {\r\n                this._succeeded = false;\r\n                return undefined;\r\n            }\r\n        }\r\n        const result = ClipperBase.addOutPt(ae1, pt);\r\n        if (ae1.outrec === ae2.outrec) {\r\n            const outrec = ae1.outrec;\r\n            outrec.pts = result;\r\n            if (this._using_polytree) {\r\n                const e = ClipperBase.getPrevHotEdge(ae1);\r\n                if (e === undefined)\r\n                    outrec.owner = undefined;\r\n                else\r\n                    ClipperBase.setOwner(outrec, e.outrec);\r\n            }\r\n            ClipperBase.uncoupleOutRec(ae1);\r\n        }\r\n        else if (ClipperBase.isOpen(ae1)) {\r\n            if (ae1.windDx < 0)\r\n                ClipperBase.joinOutrecPaths(ae1, ae2);\r\n            else\r\n                ClipperBase.joinOutrecPaths(ae2, ae1);\r\n        }\r\n        else if (ae1.outrec.idx < ae2.outrec.idx)\r\n            ClipperBase.joinOutrecPaths(ae1, ae2);\r\n        else\r\n            ClipperBase.joinOutrecPaths(ae2, ae1);\r\n        return result;\r\n    }\r\n    static joinOutrecPaths(ae1, ae2) {\r\n        // join ae2 outrec path onto ae1 outrec path and then delete ae2 outrec path\r\n        // pointers. (NB Only very rarely do the joining ends share the same coords.)\r\n        const p1Start = ae1.outrec.pts;\r\n        const p2Start = ae2.outrec.pts;\r\n        const p1End = p1Start.next;\r\n        const p2End = p2Start.next;\r\n        if (ClipperBase.isFront(ae1)) {\r\n            p2End.prev = p1Start;\r\n            p1Start.next = p2End;\r\n            p2Start.next = p1End;\r\n            p1End.prev = p2Start;\r\n            ae1.outrec.pts = p2Start;\r\n            // nb: if IsOpen(e1) then e1 & e2 must be a 'maximaPair'\r\n            ae1.outrec.frontEdge = ae2.outrec.frontEdge;\r\n            if (ae1.outrec.frontEdge)\r\n                ae1.outrec.frontEdge.outrec = ae1.outrec;\r\n        }\r\n        else {\r\n            p1End.prev = p2Start;\r\n            p2Start.next = p1End;\r\n            p1Start.next = p2End;\r\n            p2End.prev = p1Start;\r\n            ae1.outrec.backEdge = ae2.outrec.backEdge;\r\n            if (ae1.outrec.backEdge)\r\n                ae1.outrec.backEdge.outrec = ae1.outrec;\r\n        }\r\n        // after joining, the ae2.OutRec must contains no vertices ...\r\n        ae2.outrec.frontEdge = undefined;\r\n        ae2.outrec.backEdge = undefined;\r\n        ae2.outrec.pts = undefined;\r\n        ClipperBase.setOwner(ae2.outrec, ae1.outrec);\r\n        if (ClipperBase.isOpenEndActive(ae1)) {\r\n            ae2.outrec.pts = ae1.outrec.pts;\r\n            ae1.outrec.pts = undefined;\r\n        }\r\n        // and ae1 and ae2 are maxima and are about to be dropped from the Actives list.\r\n        ae1.outrec = undefined;\r\n        ae2.outrec = undefined;\r\n    }\r\n    static addOutPt(ae, pt) {\r\n        const outrec = ae.outrec;\r\n        const toFront = ClipperBase.isFront(ae);\r\n        const opFront = outrec.pts;\r\n        const opBack = opFront.next;\r\n        if (toFront && (pt == opFront.pt))\r\n            return opFront;\r\n        else if (!toFront && (pt == opBack.pt))\r\n            return opBack;\r\n        const newOp = new OutPt(pt, outrec);\r\n        opBack.prev = newOp;\r\n        newOp.prev = opFront;\r\n        newOp.next = opBack;\r\n        opFront.next = newOp;\r\n        if (toFront)\r\n            outrec.pts = newOp;\r\n        return newOp;\r\n    }\r\n    newOutRec() {\r\n        const result = new OutRec(this._outrecList.length);\r\n        this._outrecList.push(result);\r\n        return result;\r\n    }\r\n    startOpenPath(ae, pt) {\r\n        const outrec = this.newOutRec();\r\n        outrec.isOpen = true;\r\n        if (ae.windDx > 0) {\r\n            outrec.frontEdge = ae;\r\n            outrec.backEdge = undefined;\r\n        }\r\n        else {\r\n            outrec.frontEdge = undefined;\r\n            outrec.backEdge = ae;\r\n        }\r\n        ae.outrec = outrec;\r\n        const op = new OutPt(pt, outrec);\r\n        outrec.pts = op;\r\n        return op;\r\n    }\r\n    updateEdgeIntoAEL(ae) {\r\n        ae.bot = ae.top;\r\n        ae.vertexTop = ClipperBase.nextVertex(ae);\r\n        ae.top = ae.vertexTop.pt;\r\n        ae.curX = ae.bot.x;\r\n        ClipperBase.setDx(ae);\r\n        if (ClipperBase.isJoined(ae))\r\n            this.split(ae, ae.bot);\r\n        if (ClipperBase.isHorizontal(ae))\r\n            return;\r\n        this.insertScanline(ae.top.y);\r\n        this.checkJoinLeft(ae, ae.bot);\r\n        this.checkJoinRight(ae, ae.bot, true);\r\n    }\r\n    static findEdgeWithMatchingLocMin(e) {\r\n        let result = e.nextInAEL;\r\n        while (result) {\r\n            if (result.localMin === e.localMin)\r\n                return result;\r\n            if (!ClipperBase.isHorizontal(result) && e.bot !== result.bot)\r\n                result = undefined;\r\n            else\r\n                result = result.nextInAEL;\r\n        }\r\n        result = e.prevInAEL;\r\n        while (result) {\r\n            if (result.localMin === e.localMin)\r\n                return result;\r\n            if (!ClipperBase.isHorizontal(result) && e.bot !== result.bot)\r\n                return undefined;\r\n            result = result.prevInAEL;\r\n        }\r\n        return result;\r\n    }\r\n    intersectEdges(ae1, ae2, pt) {\r\n        let resultOp = undefined;\r\n        // MANAGE OPEN PATH INTERSECTIONS SEPARATELY ...\r\n        if (this._hasOpenPaths && (ClipperBase.isOpen(ae1) || ClipperBase.isOpen(ae2))) {\r\n            if (ClipperBase.isOpen(ae1) && ClipperBase.isOpen(ae2))\r\n                return undefined;\r\n            // the following line avoids duplicating quite a bit of code\r\n            if (ClipperBase.isOpen(ae2))\r\n                ClipperBase.swapActives(ae1, ae2);\r\n            if (ClipperBase.isJoined(ae2))\r\n                this.split(ae2, pt);\r\n            if (this._cliptype === ClipType.Union) {\r\n                if (!ClipperBase.isHotEdgeActive(ae2))\r\n                    return undefined;\r\n            }\r\n            else if (ae2.localMin.polytype === PathType.Subject)\r\n                return undefined;\r\n            switch (this._fillrule) {\r\n                case FillRule.Positive:\r\n                    if (ae2.windCount !== 1)\r\n                        return undefined;\r\n                    break;\r\n                case FillRule.Negative:\r\n                    if (ae2.windCount !== -1)\r\n                        return undefined;\r\n                    break;\r\n                default:\r\n                    if (Math.abs(ae2.windCount) !== 1)\r\n                        return undefined;\r\n                    break;\r\n            }\r\n            // toggle contribution ...\r\n            if (ClipperBase.isHotEdgeActive(ae1)) {\r\n                resultOp = ClipperBase.addOutPt(ae1, pt);\r\n                if (ClipperBase.isFront(ae1)) {\r\n                    ae1.outrec.frontEdge = undefined;\r\n                }\r\n                else {\r\n                    ae1.outrec.backEdge = undefined;\r\n                }\r\n                ae1.outrec = undefined;\r\n                // horizontal edges can pass under open paths at a LocMins\r\n            }\r\n            else if (pt === ae1.localMin.vertex.pt && !ClipperBase.isOpenEnd(ae1.localMin.vertex)) {\r\n                // find the other side of the LocMin and\r\n                // if it's 'hot' join up with it ...\r\n                const ae3 = ClipperBase.findEdgeWithMatchingLocMin(ae1);\r\n                if (ae3 && ClipperBase.isHotEdgeActive(ae3)) {\r\n                    ae1.outrec = ae3.outrec;\r\n                    if (ae1.windDx > 0) {\r\n                        ClipperBase.setSides(ae3.outrec, ae1, ae3);\r\n                    }\r\n                    else {\r\n                        ClipperBase.setSides(ae3.outrec, ae3, ae1);\r\n                    }\r\n                    return ae3.outrec.pts;\r\n                }\r\n                resultOp = this.startOpenPath(ae1, pt);\r\n            }\r\n            else {\r\n                resultOp = this.startOpenPath(ae1, pt);\r\n            }\r\n            return resultOp;\r\n        }\r\n        // MANAGING CLOSED PATHS FROM HERE ON\r\n        if (ClipperBase.isJoined(ae1))\r\n            this.split(ae1, pt);\r\n        if (ClipperBase.isJoined(ae2))\r\n            this.split(ae2, pt);\r\n        // UPDATE WINDING COUNTS...\r\n        let oldE1WindCount;\r\n        let oldE2WindCount;\r\n        if (ae1.localMin.polytype === ae2.localMin.polytype) {\r\n            if (this._fillrule === FillRule.EvenOdd) {\r\n                oldE1WindCount = ae1.windCount;\r\n                ae1.windCount = ae2.windCount;\r\n                ae2.windCount = oldE1WindCount;\r\n            }\r\n            else {\r\n                if (ae1.windCount + ae2.windDx === 0)\r\n                    ae1.windCount = -ae1.windCount;\r\n                else\r\n                    ae1.windCount += ae2.windDx;\r\n                if (ae2.windCount - ae1.windDx === 0)\r\n                    ae2.windCount = -ae2.windCount;\r\n                else\r\n                    ae2.windCount -= ae1.windDx;\r\n            }\r\n        }\r\n        else {\r\n            if (this._fillrule !== FillRule.EvenOdd)\r\n                ae1.windCount2 += ae2.windDx;\r\n            else\r\n                ae1.windCount2 = (ae1.windCount2 === 0 ? 1 : 0);\r\n            if (this._fillrule !== FillRule.EvenOdd)\r\n                ae2.windCount2 -= ae1.windDx;\r\n            else\r\n                ae2.windCount2 = (ae2.windCount2 === 0 ? 1 : 0);\r\n        }\r\n        switch (this._fillrule) {\r\n            case FillRule.Positive:\r\n                oldE1WindCount = ae1.windCount;\r\n                oldE2WindCount = ae2.windCount;\r\n                break;\r\n            case FillRule.Negative:\r\n                oldE1WindCount = -ae1.windCount;\r\n                oldE2WindCount = -ae2.windCount;\r\n                break;\r\n            default:\r\n                oldE1WindCount = Math.abs(ae1.windCount);\r\n                oldE2WindCount = Math.abs(ae2.windCount);\r\n                break;\r\n        }\r\n        const e1WindCountIs0or1 = oldE1WindCount === 0 || oldE1WindCount === 1;\r\n        const e2WindCountIs0or1 = oldE2WindCount === 0 || oldE2WindCount === 1;\r\n        if ((!ClipperBase.isHotEdgeActive(ae1) && !e1WindCountIs0or1) || (!ClipperBase.isHotEdgeActive(ae2) && !e2WindCountIs0or1))\r\n            return undefined;\r\n        // NOW PROCESS THE INTERSECTION ...\r\n        // if both edges are 'hot' ...\r\n        if (ClipperBase.isHotEdgeActive(ae1) && ClipperBase.isHotEdgeActive(ae2)) {\r\n            if ((oldE1WindCount !== 0 && oldE1WindCount !== 1) ||\r\n                (oldE2WindCount !== 0 && oldE2WindCount !== 1) ||\r\n                (ae1.localMin.polytype !== ae2.localMin.polytype &&\r\n                    this._cliptype !== ClipType.Xor)) {\r\n                resultOp = this.addLocalMaxPoly(ae1, ae2, pt);\r\n            }\r\n            else if (ClipperBase.isFront(ae1) || (ae1.outrec === ae2.outrec)) {\r\n                // this 'else if' condition isn't strictly needed but\r\n                // it's sensible to split polygons that only touch at\r\n                // a common vertex (not at common edges).\r\n                resultOp = this.addLocalMaxPoly(ae1, ae2, pt);\r\n                this.addLocalMinPoly(ae1, ae2, pt);\r\n            }\r\n            else {\r\n                // can't treat as maxima & minima\r\n                resultOp = ClipperBase.addOutPt(ae1, pt);\r\n                ClipperBase.addOutPt(ae2, pt);\r\n                ClipperBase.swapOutrecs(ae1, ae2);\r\n            }\r\n        }\r\n        // if one or the other edge is 'hot' ...\r\n        else if (ClipperBase.isHotEdgeActive(ae1)) {\r\n            resultOp = ClipperBase.addOutPt(ae1, pt);\r\n            ClipperBase.swapOutrecs(ae1, ae2);\r\n        }\r\n        else if (ClipperBase.isHotEdgeActive(ae2)) {\r\n            resultOp = ClipperBase.addOutPt(ae2, pt);\r\n            ClipperBase.swapOutrecs(ae1, ae2);\r\n        }\r\n        // neither edge is 'hot'\r\n        else {\r\n            let e1Wc2;\r\n            let e2Wc2;\r\n            switch (this._fillrule) {\r\n                case FillRule.Positive:\r\n                    e1Wc2 = ae1.windCount2;\r\n                    e2Wc2 = ae2.windCount2;\r\n                    break;\r\n                case FillRule.Negative:\r\n                    e1Wc2 = -ae1.windCount2;\r\n                    e2Wc2 = -ae2.windCount2;\r\n                    break;\r\n                default:\r\n                    e1Wc2 = Math.abs(ae1.windCount2);\r\n                    e2Wc2 = Math.abs(ae2.windCount2);\r\n                    break;\r\n            }\r\n            if (!ClipperBase.isSamePolyType(ae1, ae2)) {\r\n                resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n            }\r\n            else if (oldE1WindCount === 1 && oldE2WindCount === 1) {\r\n                resultOp = undefined;\r\n                switch (this._cliptype) {\r\n                    case ClipType.Union:\r\n                        if (e1Wc2 > 0 && e2Wc2 > 0)\r\n                            return undefined;\r\n                        resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n                        break;\r\n                    case ClipType.Difference:\r\n                        if (((ClipperBase.getPolyType(ae1) === PathType.Clip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\r\n                            ((ClipperBase.getPolyType(ae1) === PathType.Subject) && (e1Wc2 <= 0) && (e2Wc2 <= 0))) {\r\n                            resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n                        }\r\n                        break;\r\n                    case ClipType.Xor:\r\n                        resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n                        break;\r\n                    default: // ClipType.Intersection:\r\n                        if (e1Wc2 <= 0 || e2Wc2 <= 0)\r\n                            return undefined;\r\n                        resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        return resultOp;\r\n    }\r\n    deleteFromAEL(ae) {\r\n        const prev = ae.prevInAEL;\r\n        const next = ae.nextInAEL;\r\n        if (!prev && !next && ae !== this._actives)\r\n            return; // already deleted\r\n        if (prev)\r\n            prev.nextInAEL = next;\r\n        else\r\n            this._actives = next;\r\n        if (next)\r\n            next.prevInAEL = prev;\r\n    }\r\n    adjustCurrXAndCopyToSEL(topY) {\r\n        let ae = this._actives;\r\n        this._sel = ae;\r\n        while (ae) {\r\n            ae.prevInSEL = ae.prevInAEL;\r\n            ae.nextInSEL = ae.nextInAEL;\r\n            ae.jump = ae.nextInSEL;\r\n            if (ae.joinWith === JoinWith.Left)\r\n                ae.curX = ae.prevInAEL.curX; // This also avoids complications\r\n            else\r\n                ae.curX = ClipperBase.topX(ae, topY);\r\n            // NB don't update ae.curr.Y yet (see AddNewIntersectNode)\r\n            ae = ae.nextInAEL;\r\n        }\r\n    }\r\n    executeInternal(ct, fillRule) {\r\n        if (ct === ClipType.None)\r\n            return;\r\n        this._fillrule = fillRule;\r\n        this._cliptype = ct;\r\n        this.reset();\r\n        let y = this.popScanline();\r\n        if (y === undefined)\r\n            return;\r\n        while (this._succeeded) {\r\n            this.insertLocalMinimaIntoAEL(y);\r\n            let ae = this.popHorz();\r\n            while (ae) {\r\n                this.doHorizontal(ae);\r\n                ae = this.popHorz();\r\n            }\r\n            if (this._horzSegList.length > 0) {\r\n                this.convertHorzSegsToJoins();\r\n                this._horzSegList.length = 0;\r\n            }\r\n            this._currentBotY = y; // bottom of scanbeam\r\n            y = this.popScanline();\r\n            if (y === undefined)\r\n                break; // y new top of scanbeam\r\n            this.doIntersections(y);\r\n            this.doTopOfScanbeam(y);\r\n            ae = this.popHorz();\r\n            while (ae) {\r\n                this.doHorizontal(ae);\r\n                ae = this.popHorz();\r\n            }\r\n        }\r\n        if (this._succeeded)\r\n            this.processHorzJoins();\r\n    }\r\n    doIntersections(topY) {\r\n        if (this.buildIntersectList(topY)) {\r\n            this.processIntersectList();\r\n            this.disposeIntersectNodes();\r\n        }\r\n    }\r\n    disposeIntersectNodes() {\r\n        this._intersectList.length = 0;\r\n    }\r\n    addNewIntersectNode(ae1, ae2, topY) {\r\n        const result = InternalClipper.getIntersectPt(ae1.bot, ae1.top, ae2.bot, ae2.top);\r\n        let ip = result.ip;\r\n        if (!result.success) {\r\n            ip = new Point64(ae1.curX, topY);\r\n        }\r\n        if (ip.y > this._currentBotY || ip.y < topY) {\r\n            const absDx1 = Math.abs(ae1.dx);\r\n            const absDx2 = Math.abs(ae2.dx);\r\n            if (absDx1 > 100 && absDx2 > 100) {\r\n                if (absDx1 > absDx2) {\r\n                    ip = InternalClipper.getClosestPtOnSegment(ip, ae1.bot, ae1.top);\r\n                }\r\n                else {\r\n                    ip = InternalClipper.getClosestPtOnSegment(ip, ae2.bot, ae2.top);\r\n                }\r\n            }\r\n            else if (absDx1 > 100) {\r\n                ip = InternalClipper.getClosestPtOnSegment(ip, ae1.bot, ae1.top);\r\n            }\r\n            else if (absDx2 > 100) {\r\n                ip = InternalClipper.getClosestPtOnSegment(ip, ae2.bot, ae2.top);\r\n            }\r\n            else {\r\n                if (ip.y < topY) {\r\n                    ip.y = topY;\r\n                }\r\n                else {\r\n                    ip.y = this._currentBotY;\r\n                }\r\n                if (absDx1 < absDx2) {\r\n                    ip.x = ClipperBase.topX(ae1, ip.y);\r\n                }\r\n                else {\r\n                    ip.x = ClipperBase.topX(ae2, ip.y);\r\n                }\r\n            }\r\n        }\r\n        const node = new IntersectNode(ip, ae1, ae2);\r\n        this._intersectList.push(node);\r\n    }\r\n    static extractFromSEL(ae) {\r\n        const res = ae.nextInSEL;\r\n        if (res) {\r\n            res.prevInSEL = ae.prevInSEL;\r\n        }\r\n        ae.prevInSEL.nextInSEL = res;\r\n        return res;\r\n    }\r\n    static insert1Before2InSEL(ae1, ae2) {\r\n        ae1.prevInSEL = ae2.prevInSEL;\r\n        if (ae1.prevInSEL) {\r\n            ae1.prevInSEL.nextInSEL = ae1;\r\n        }\r\n        ae1.nextInSEL = ae2;\r\n        ae2.prevInSEL = ae1;\r\n    }\r\n    buildIntersectList(topY) {\r\n        if (!this._actives || !this._actives.nextInAEL)\r\n            return false;\r\n        // Calculate edge positions at the top of the current scanbeam, and from this\r\n        // we will determine the intersections required to reach these new positions.\r\n        this.adjustCurrXAndCopyToSEL(topY);\r\n        // Find all edge intersections in the current scanbeam using a stable merge\r\n        // sort that ensures only adjacent edges are intersecting. Intersect info is\r\n        // stored in FIntersectList ready to be processed in ProcessIntersectList.\r\n        // Re merge sorts see https://stackoverflow.com/a/46319131/359538\r\n        let left = this._sel, right, lEnd, rEnd, currBase, prevBase, tmp;\r\n        while (left.jump) {\r\n            prevBase = undefined;\r\n            while (left && left.jump) {\r\n                currBase = left;\r\n                right = left.jump;\r\n                lEnd = right;\r\n                rEnd = right.jump;\r\n                left.jump = rEnd;\r\n                while (left !== lEnd && right !== rEnd) {\r\n                    if (right.curX < left.curX) {\r\n                        tmp = right.prevInSEL;\r\n                        for (;;) {\r\n                            this.addNewIntersectNode(tmp, right, topY);\r\n                            if (tmp === left)\r\n                                break;\r\n                            tmp = tmp.prevInSEL;\r\n                        }\r\n                        tmp = right;\r\n                        right = ClipperBase.extractFromSEL(tmp);\r\n                        lEnd = right;\r\n                        ClipperBase.insert1Before2InSEL(tmp, left);\r\n                        if (left === currBase) {\r\n                            currBase = tmp;\r\n                            currBase.jump = rEnd;\r\n                            if (prevBase === undefined)\r\n                                this._sel = currBase;\r\n                            else\r\n                                prevBase.jump = currBase;\r\n                        }\r\n                    }\r\n                    else {\r\n                        left = left.nextInSEL;\r\n                    }\r\n                }\r\n                prevBase = currBase;\r\n                left = rEnd;\r\n            }\r\n            left = this._sel;\r\n        }\r\n        return this._intersectList.length > 0;\r\n    }\r\n    processIntersectList() {\r\n        // We now have a list of intersections required so that edges will be\r\n        // correctly positioned at the top of the scanbeam. However, it's important\r\n        // that edge intersections are processed from the bottom up, but it's also\r\n        // crucial that intersections only occur between adjacent edges.\r\n        // First we do a quicksort so intersections proceed in a bottom up order ...\r\n        this._intersectList.sort((a, b) => {\r\n            if (a.pt.y === b.pt.y) {\r\n                if (a.pt.x === b.pt.x)\r\n                    return 0;\r\n                return (a.pt.x < b.pt.x) ? -1 : 1;\r\n            }\r\n            return (a.pt.y > b.pt.y) ? -1 : 1;\r\n        });\r\n        // Now as we process these intersections, we must sometimes adjust the order\r\n        // to ensure that intersecting edges are always adjacent ...\r\n        for (let i = 0; i < this._intersectList.length; ++i) {\r\n            if (!ClipperBase.edgesAdjacentInAEL(this._intersectList[i])) {\r\n                let j = i + 1;\r\n                while (!ClipperBase.edgesAdjacentInAEL(this._intersectList[j]))\r\n                    j++;\r\n                // swap\r\n                [this._intersectList[j], this._intersectList[i]] =\r\n                    [this._intersectList[i], this._intersectList[j]];\r\n            }\r\n            const node = this._intersectList[i];\r\n            this.intersectEdges(node.edge1, node.edge2, node.pt);\r\n            this.swapPositionsInAEL(node.edge1, node.edge2);\r\n            node.edge1.curX = node.pt.x;\r\n            node.edge2.curX = node.pt.x;\r\n            this.checkJoinLeft(node.edge2, node.pt, true);\r\n            this.checkJoinRight(node.edge1, node.pt, true);\r\n        }\r\n    }\r\n    swapPositionsInAEL(ae1, ae2) {\r\n        // preconditon: ae1 must be immediately to the left of ae2\r\n        const next = ae2.nextInAEL;\r\n        if (next)\r\n            next.prevInAEL = ae1;\r\n        const prev = ae1.prevInAEL;\r\n        if (prev)\r\n            prev.nextInAEL = ae2;\r\n        ae2.prevInAEL = prev;\r\n        ae2.nextInAEL = ae1;\r\n        ae1.prevInAEL = ae2;\r\n        ae1.nextInAEL = next;\r\n        if (!ae2.prevInAEL)\r\n            this._actives = ae2;\r\n    }\r\n    static resetHorzDirection(horz, vertexMax) {\r\n        let leftX, rightX;\r\n        if (horz.bot.x === horz.top.x) {\r\n            // the horizontal edge is going nowhere ...\r\n            leftX = horz.curX;\r\n            rightX = horz.curX;\r\n            let ae = horz.nextInAEL;\r\n            while (ae && ae.vertexTop !== vertexMax)\r\n                ae = ae.nextInAEL;\r\n            return { isLeftToRight: ae !== undefined, leftX, rightX };\r\n        }\r\n        if (horz.curX < horz.top.x) {\r\n            leftX = horz.curX;\r\n            rightX = horz.top.x;\r\n            return { isLeftToRight: true, leftX, rightX };\r\n        }\r\n        leftX = horz.top.x;\r\n        rightX = horz.curX;\r\n        return { isLeftToRight: false, leftX, rightX }; // right to left\r\n    }\r\n    static horzIsSpike(horz) {\r\n        const nextPt = ClipperBase.nextVertex(horz).pt;\r\n        return (horz.bot.x < horz.top.x) !== (horz.top.x < nextPt.x);\r\n    }\r\n    static trimHorz(horzEdge, preserveCollinear) {\r\n        let wasTrimmed = false;\r\n        let pt = ClipperBase.nextVertex(horzEdge).pt;\r\n        while (pt.y === horzEdge.top.y) {\r\n            // always trim 180 deg. spikes (in closed paths)\r\n            // but otherwise break if preserveCollinear = true\r\n            if (preserveCollinear &&\r\n                (pt.x < horzEdge.top.x) !== (horzEdge.bot.x < horzEdge.top.x)) {\r\n                break;\r\n            }\r\n            horzEdge.vertexTop = ClipperBase.nextVertex(horzEdge);\r\n            horzEdge.top = pt;\r\n            wasTrimmed = true;\r\n            if (ClipperBase.isMaximaActive(horzEdge))\r\n                break;\r\n            pt = ClipperBase.nextVertex(horzEdge).pt;\r\n        }\r\n        if (wasTrimmed)\r\n            ClipperBase.setDx(horzEdge); // +/-infinity\r\n    }\r\n    addToHorzSegList(op) {\r\n        if (op.outrec.isOpen)\r\n            return;\r\n        this._horzSegList.push(new HorzSegment(op));\r\n    }\r\n    getLastOp(hotEdge) {\r\n        const outrec = hotEdge.outrec;\r\n        return (hotEdge === outrec.frontEdge) ?\r\n            outrec.pts : outrec.pts.next;\r\n    }\r\n    /*******************************************************************************\r\n    * Notes: Horizontal edges (HEs) at scanline intersections (i.e. at the top or    *\r\n    * bottom of a scanbeam) are processed as if layered.The order in which HEs     *\r\n    * are processed doesn't matter. HEs intersect with the bottom vertices of      *\r\n    * other HEs[#] and with non-horizontal edges [*]. Once these intersections     *\r\n    * are completed, intermediate HEs are 'promoted' to the next edge in their     *\r\n    * bounds, and they in turn may be intersected[%] by other HEs.                 *\r\n    *                                                                              *\r\n    * eg: 3 horizontals at a scanline:    /   |                     /           /  *\r\n    *              |                     /    |     (HE3)o ========%========== o   *\r\n    *              o ======= o(HE2)     /     |         /         /                *\r\n    *          o ============#=========*======*========#=========o (HE1)           *\r\n    *         /              |        /       |       /                            *\r\n    *******************************************************************************/\r\n    doHorizontal(horz) {\r\n        let pt;\r\n        const horzIsOpen = ClipperBase.isOpen(horz);\r\n        const Y = horz.bot.y;\r\n        const vertex_max = horzIsOpen ?\r\n            ClipperBase.getCurrYMaximaVertex_Open(horz) :\r\n            ClipperBase.getCurrYMaximaVertex(horz);\r\n        // remove 180 deg.spikes and also simplify\r\n        // consecutive horizontals when PreserveCollinear = true\r\n        if (vertex_max && !horzIsOpen && vertex_max !== horz.vertexTop)\r\n            ClipperBase.trimHorz(horz, this.preserveCollinear);\r\n        let { isLeftToRight, leftX, rightX } = ClipperBase.resetHorzDirection(horz, vertex_max);\r\n        if (ClipperBase.isHotEdgeActive(horz)) {\r\n            const op = ClipperBase.addOutPt(horz, new Point64(horz.curX, Y));\r\n            this.addToHorzSegList(op);\r\n        }\r\n        for (;;) {\r\n            // loops through consec. horizontal edges (if open)\r\n            let ae = isLeftToRight ? horz.nextInAEL : horz.prevInAEL;\r\n            while (ae) {\r\n                if (ae.vertexTop === vertex_max) {\r\n                    // do this first!!\r\n                    if (ClipperBase.isHotEdgeActive(horz) && ClipperBase.isJoined(ae))\r\n                        this.split(ae, ae.top);\r\n                    if (ClipperBase.isHotEdgeActive(horz)) {\r\n                        while (horz.vertexTop !== vertex_max) {\r\n                            ClipperBase.addOutPt(horz, horz.top);\r\n                            this.updateEdgeIntoAEL(horz);\r\n                        }\r\n                        if (isLeftToRight)\r\n                            this.addLocalMaxPoly(horz, ae, horz.top);\r\n                        else\r\n                            this.addLocalMaxPoly(ae, horz, horz.top);\r\n                    }\r\n                    this.deleteFromAEL(ae);\r\n                    this.deleteFromAEL(horz);\r\n                    return;\r\n                }\r\n                // if horzEdge is a maxima, keep going until we reach\r\n                // its maxima pair, otherwise check for break conditions\r\n                if (vertex_max !== horz.vertexTop || ClipperBase.isOpenEndActive(horz)) {\r\n                    // otherwise stop when 'ae' is beyond the end of the horizontal line\r\n                    if ((isLeftToRight && ae.curX > rightX) || (!isLeftToRight && ae.curX < leftX))\r\n                        break;\r\n                    if (ae.curX === horz.top.x && !ClipperBase.isHorizontal(ae)) {\r\n                        pt = ClipperBase.nextVertex(horz).pt;\r\n                        // to maximize the possibility of putting open edges into\r\n                        // solutions, we'll only break if it's past HorzEdge's end\r\n                        if (ClipperBase.isOpen(ae) && !ClipperBase.isSamePolyType(ae, horz) && !ClipperBase.isHotEdgeActive(ae)) {\r\n                            if ((isLeftToRight && (ClipperBase.topX(ae, pt.y) > pt.x)) || (!isLeftToRight && (ClipperBase.topX(ae, pt.y) < pt.x)))\r\n                                break;\r\n                        }\r\n                        // otherwise for edges at horzEdge's end, only stop when horzEdge's\r\n                        // outslope is greater than e's slope when heading right or when\r\n                        // horzEdge's outslope is less than e's slope when heading left.\r\n                        else if ((isLeftToRight && (ClipperBase.topX(ae, pt.y) >= pt.x)) || (!isLeftToRight && (ClipperBase.topX(ae, pt.y) <= pt.x)))\r\n                            break;\r\n                    }\r\n                }\r\n                pt = new Point64(ae.curX, Y);\r\n                if (isLeftToRight) {\r\n                    this.intersectEdges(horz, ae, pt);\r\n                    this.swapPositionsInAEL(horz, ae);\r\n                    horz.curX = ae.curX;\r\n                    ae = horz.nextInAEL;\r\n                }\r\n                else {\r\n                    this.intersectEdges(ae, horz, pt);\r\n                    this.swapPositionsInAEL(ae, horz);\r\n                    horz.curX = ae.curX;\r\n                    ae = horz.prevInAEL;\r\n                }\r\n                if (ClipperBase.isHotEdgeActive(horz))\r\n                    this.addToHorzSegList(this.getLastOp(horz));\r\n            } // we've reached the end of this horizontal\r\n            // check if we've finished looping\r\n            // through consecutive horizontals\r\n            if (horzIsOpen && ClipperBase.isOpenEndActive(horz)) { // ie open at top\r\n                if (ClipperBase.isHotEdgeActive(horz)) {\r\n                    ClipperBase.addOutPt(horz, horz.top);\r\n                    if (ClipperBase.isFront(horz))\r\n                        horz.outrec.frontEdge = undefined;\r\n                    else\r\n                        horz.outrec.backEdge = undefined;\r\n                    horz.outrec = undefined;\r\n                }\r\n                this.deleteFromAEL(horz);\r\n                return;\r\n            }\r\n            else if (ClipperBase.nextVertex(horz).pt.y !== horz.top.y)\r\n                break;\r\n            // still more horizontals in bound to process ...\r\n            if (ClipperBase.isHotEdgeActive(horz)) {\r\n                ClipperBase.addOutPt(horz, horz.top);\r\n            }\r\n            this.updateEdgeIntoAEL(horz);\r\n            if (this.preserveCollinear && !horzIsOpen && ClipperBase.horzIsSpike(horz)) {\r\n                ClipperBase.trimHorz(horz, true);\r\n            }\r\n            const result = ClipperBase.resetHorzDirection(horz, vertex_max);\r\n            isLeftToRight = result.isLeftToRight;\r\n            leftX = result.leftX;\r\n            rightX = result.rightX;\r\n        }\r\n        if (ClipperBase.isHotEdgeActive(horz)) {\r\n            const op = ClipperBase.addOutPt(horz, horz.top);\r\n            this.addToHorzSegList(op);\r\n        }\r\n        this.updateEdgeIntoAEL(horz);\r\n    }\r\n    doTopOfScanbeam(y) {\r\n        this._sel = undefined; // _sel is reused to flag horizontals (see pushHorz below)\r\n        let ae = this._actives;\r\n        while (ae) {\r\n            // NB 'ae' will never be horizontal here\r\n            if (ae.top.y === y) {\r\n                ae.curX = ae.top.x;\r\n                if (ClipperBase.isMaximaActive(ae)) {\r\n                    ae = this.doMaxima(ae); // TOP OF BOUND (MAXIMA)\r\n                    continue;\r\n                }\r\n                // INTERMEDIATE VERTEX ...\r\n                if (ClipperBase.isHotEdgeActive(ae))\r\n                    ClipperBase.addOutPt(ae, ae.top);\r\n                this.updateEdgeIntoAEL(ae);\r\n                if (ClipperBase.isHorizontal(ae))\r\n                    this.pushHorz(ae); // horizontals are processed later\r\n            }\r\n            else { // i.e. not the top of the edge\r\n                ae.curX = ClipperBase.topX(ae, y);\r\n            }\r\n            ae = ae.nextInAEL;\r\n        }\r\n    }\r\n    doMaxima(ae) {\r\n        const prevE = ae.prevInAEL;\r\n        let nextE = ae.nextInAEL;\r\n        if (ClipperBase.isOpenEndActive(ae)) {\r\n            if (ClipperBase.isHotEdgeActive(ae))\r\n                ClipperBase.addOutPt(ae, ae.top);\r\n            if (!ClipperBase.isHorizontal(ae)) {\r\n                if (ClipperBase.isHotEdgeActive(ae)) {\r\n                    if (ClipperBase.isFront(ae))\r\n                        ae.outrec.frontEdge = undefined;\r\n                    else\r\n                        ae.outrec.backEdge = undefined;\r\n                    ae.outrec = undefined;\r\n                }\r\n                this.deleteFromAEL(ae);\r\n            }\r\n            return nextE;\r\n        }\r\n        const maxPair = ClipperBase.getMaximaPair(ae);\r\n        if (!maxPair)\r\n            return nextE; // eMaxPair is horizontal\r\n        if (ClipperBase.isJoined(ae))\r\n            this.split(ae, ae.top);\r\n        if (ClipperBase.isJoined(maxPair))\r\n            this.split(maxPair, maxPair.top);\r\n        // only non-horizontal maxima here.\r\n        // process any edges between maxima pair ...\r\n        while (nextE !== maxPair) {\r\n            this.intersectEdges(ae, nextE, ae.top);\r\n            this.swapPositionsInAEL(ae, nextE);\r\n            nextE = ae.nextInAEL;\r\n        }\r\n        if (ClipperBase.isOpen(ae)) {\r\n            if (ClipperBase.isHotEdgeActive(ae))\r\n                this.addLocalMaxPoly(ae, maxPair, ae.top);\r\n            this.deleteFromAEL(maxPair);\r\n            this.deleteFromAEL(ae);\r\n            return (prevE ? prevE.nextInAEL : this._actives);\r\n        }\r\n        // here ae.nextInAel == ENext == EMaxPair ...\r\n        if (ClipperBase.isHotEdgeActive(ae))\r\n            this.addLocalMaxPoly(ae, maxPair, ae.top);\r\n        this.deleteFromAEL(ae);\r\n        this.deleteFromAEL(maxPair);\r\n        return (prevE ? prevE.nextInAEL : this._actives);\r\n    }\r\n    static isJoined(e) {\r\n        return e.joinWith !== JoinWith.None;\r\n    }\r\n    split(e, currPt) {\r\n        if (e.joinWith === JoinWith.Right) {\r\n            e.joinWith = JoinWith.None;\r\n            e.nextInAEL.joinWith = JoinWith.None;\r\n            this.addLocalMinPoly(e, e.nextInAEL, currPt, true);\r\n        }\r\n        else {\r\n            e.joinWith = JoinWith.None;\r\n            e.prevInAEL.joinWith = JoinWith.None;\r\n            this.addLocalMinPoly(e.prevInAEL, e, currPt, true);\r\n        }\r\n    }\r\n    checkJoinLeft(e, pt, checkCurrX = false) {\r\n        const prev = e.prevInAEL;\r\n        if (!prev || ClipperBase.isOpen(e) || ClipperBase.isOpen(prev) ||\r\n            !ClipperBase.isHotEdgeActive(e) || !ClipperBase.isHotEdgeActive(prev))\r\n            return;\r\n        if ((pt.y < e.top.y + 2 || pt.y < prev.top.y + 2) && // avoid trivial joins\r\n            ((e.bot.y > pt.y) || (prev.bot.y > pt.y)))\r\n            return; // (#490)\r\n        if (checkCurrX) {\r\n            if (Clipper.perpendicDistFromLineSqrd(pt, prev.bot, prev.top) > 0.25)\r\n                return;\r\n        }\r\n        else if (e.curX !== prev.curX)\r\n            return;\r\n        if (InternalClipper.crossProduct(e.top, pt, prev.top) !== 0)\r\n            return;\r\n        if (e.outrec.idx === prev.outrec.idx)\r\n            this.addLocalMaxPoly(prev, e, pt);\r\n        else if (e.outrec.idx < prev.outrec.idx)\r\n            ClipperBase.joinOutrecPaths(e, prev);\r\n        else\r\n            ClipperBase.joinOutrecPaths(prev, e);\r\n        prev.joinWith = JoinWith.Right;\r\n        e.joinWith = JoinWith.Left;\r\n    }\r\n    checkJoinRight(e, pt, checkCurrX = false) {\r\n        const next = e.nextInAEL;\r\n        if (ClipperBase.isOpen(e) || !ClipperBase.isHotEdgeActive(e) || ClipperBase.isJoined(e) ||\r\n            !next || ClipperBase.isOpen(next) || !ClipperBase.isHotEdgeActive(next))\r\n            return;\r\n        if ((pt.y < e.top.y + 2 || pt.y < next.top.y + 2) && // avoid trivial joins\r\n            ((e.bot.y > pt.y) || (next.bot.y > pt.y)))\r\n            return; // (#490)\r\n        if (checkCurrX) {\r\n            if (Clipper.perpendicDistFromLineSqrd(pt, next.bot, next.top) > 0.25)\r\n                return;\r\n        }\r\n        else if (e.curX !== next.curX)\r\n            return;\r\n        if (InternalClipper.crossProduct(e.top, pt, next.top) !== 0)\r\n            return;\r\n        if (e.outrec.idx === next.outrec.idx)\r\n            this.addLocalMaxPoly(e, next, pt);\r\n        else if (e.outrec.idx < next.outrec.idx)\r\n            ClipperBase.joinOutrecPaths(e, next);\r\n        else\r\n            ClipperBase.joinOutrecPaths(next, e);\r\n        e.joinWith = JoinWith.Right;\r\n        next.joinWith = JoinWith.Left;\r\n    }\r\n    static fixOutRecPts(outrec) {\r\n        let op = outrec.pts;\r\n        do {\r\n            op.outrec = outrec;\r\n            op = op.next;\r\n        } while (op !== outrec.pts);\r\n    }\r\n    static setHorzSegHeadingForward(hs, opP, opN) {\r\n        if (opP.pt.x === opN.pt.x)\r\n            return false;\r\n        if (opP.pt.x < opN.pt.x) {\r\n            hs.leftOp = opP;\r\n            hs.rightOp = opN;\r\n            hs.leftToRight = true;\r\n        }\r\n        else {\r\n            hs.leftOp = opN;\r\n            hs.rightOp = opP;\r\n            hs.leftToRight = false;\r\n        }\r\n        return true;\r\n    }\r\n    static updateHorzSegment(hs) {\r\n        const op = hs.leftOp;\r\n        const outrec = this.getRealOutRec(op.outrec);\r\n        const outrecHasEdges = outrec.frontEdge !== undefined;\r\n        const curr_y = op.pt.y;\r\n        let opP = op, opN = op;\r\n        if (outrecHasEdges) {\r\n            const opA = outrec.pts, opZ = opA.next;\r\n            while (opP !== opZ && opP.prev.pt.y === curr_y)\r\n                opP = opP.prev;\r\n            while (opN !== opA && opN.next.pt.y === curr_y)\r\n                opN = opN.next;\r\n        }\r\n        else {\r\n            while (opP.prev !== opN && opP.prev.pt.y === curr_y)\r\n                opP = opP.prev;\r\n            while (opN.next !== opP && opN.next.pt.y === curr_y)\r\n                opN = opN.next;\r\n        }\r\n        const result = this.setHorzSegHeadingForward(hs, opP, opN) && hs.leftOp.horz === undefined;\r\n        if (result)\r\n            hs.leftOp.horz = hs;\r\n        else\r\n            hs.rightOp = undefined; // (for sorting)\r\n        return result;\r\n    }\r\n    static duplicateOp(op, insert_after) {\r\n        const result = new OutPt(op.pt, op.outrec);\r\n        if (insert_after) {\r\n            result.next = op.next;\r\n            result.next.prev = result;\r\n            result.prev = op;\r\n            op.next = result;\r\n        }\r\n        else {\r\n            result.prev = op.prev;\r\n            result.prev.next = result;\r\n            result.next = op;\r\n            op.prev = result;\r\n        }\r\n        return result;\r\n    }\r\n    convertHorzSegsToJoins() {\r\n        let k = 0;\r\n        for (const hs of this._horzSegList) {\r\n            if (ClipperBase.updateHorzSegment(hs))\r\n                k++;\r\n        }\r\n        if (k < 2)\r\n            return;\r\n        this._horzSegList.sort((hs1, hs2) => {\r\n            if (!hs1 || !hs2)\r\n                return 0;\r\n            if (!hs1.rightOp) {\r\n                return !hs2.rightOp ? 0 : 1;\r\n            }\r\n            else if (!hs2.rightOp)\r\n                return -1;\r\n            else\r\n                return hs1.leftOp.pt.x - hs2.leftOp.pt.x;\r\n        });\r\n        for (let i = 0; i < k - 1; i++) {\r\n            const hs1 = this._horzSegList[i];\r\n            // for each HorzSegment, find others that overlap\r\n            for (let j = i + 1; j < k; j++) {\r\n                const hs2 = this._horzSegList[j];\r\n                if (hs2.leftOp.pt.x >= hs1.rightOp.pt.x ||\r\n                    hs2.leftToRight === hs1.leftToRight ||\r\n                    hs2.rightOp.pt.x <= hs1.leftOp.pt.x)\r\n                    continue;\r\n                const curr_y = hs1.leftOp.pt.y;\r\n                if (hs1.leftToRight) {\r\n                    while (hs1.leftOp.next.pt.y === curr_y &&\r\n                        hs1.leftOp.next.pt.x <= hs2.leftOp.pt.x) {\r\n                        hs1.leftOp = hs1.leftOp.next;\r\n                    }\r\n                    while (hs2.leftOp.prev.pt.y === curr_y &&\r\n                        hs2.leftOp.prev.pt.x <= hs1.leftOp.pt.x) {\r\n                        hs2.leftOp = hs2.leftOp.prev;\r\n                    }\r\n                    const join = new HorzJoin(ClipperBase.duplicateOp(hs1.leftOp, true), ClipperBase.duplicateOp(hs2.leftOp, false));\r\n                    this._horzJoinList.push(join);\r\n                }\r\n                else {\r\n                    while (hs1.leftOp.prev.pt.y === curr_y &&\r\n                        hs1.leftOp.prev.pt.x <= hs2.leftOp.pt.x) {\r\n                        hs1.leftOp = hs1.leftOp.prev;\r\n                    }\r\n                    while (hs2.leftOp.next.pt.y === curr_y &&\r\n                        hs2.leftOp.next.pt.x <= hs1.leftOp.pt.x) {\r\n                        hs2.leftOp = hs2.leftOp.next;\r\n                    }\r\n                    const join = new HorzJoin(ClipperBase.duplicateOp(hs2.leftOp, true), ClipperBase.duplicateOp(hs1.leftOp, false));\r\n                    this._horzJoinList.push(join);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static getCleanPath(op) {\r\n        const result = new Path64();\r\n        let op2 = op;\r\n        while (op2.next !== op &&\r\n            ((op2.pt.x === op2.next.pt.x && op2.pt.x === op2.prev.pt.x) ||\r\n                (op2.pt.y === op2.next.pt.y && op2.pt.y === op2.prev.pt.y))) {\r\n            op2 = op2.next;\r\n        }\r\n        result.push(op2.pt);\r\n        let prevOp = op2;\r\n        op2 = op2.next;\r\n        while (op2 !== op) {\r\n            if ((op2.pt.x !== op2.next.pt.x || op2.pt.x !== prevOp.pt.x) &&\r\n                (op2.pt.y !== op2.next.pt.y || op2.pt.y !== prevOp.pt.y)) {\r\n                result.push(op2.pt);\r\n                prevOp = op2;\r\n            }\r\n            op2 = op2.next;\r\n        }\r\n        return result;\r\n    }\r\n    static pointInOpPolygon(pt, op) {\r\n        if (op === op.next || op.prev === op.next)\r\n            return PointInPolygonResult.IsOutside;\r\n        let op2 = op;\r\n        do {\r\n            if (op.pt.y !== pt.y)\r\n                break;\r\n            op = op.next;\r\n        } while (op !== op2);\r\n        if (op.pt.y === pt.y) // not a proper polygon\r\n            return PointInPolygonResult.IsOutside;\r\n        let isAbove = op.pt.y < pt.y;\r\n        const startingAbove = isAbove;\r\n        let val = 0;\r\n        op2 = op.next;\r\n        while (op2 !== op) {\r\n            if (isAbove)\r\n                while (op2 !== op && op2.pt.y < pt.y)\r\n                    op2 = op2.next;\r\n            else\r\n                while (op2 !== op && op2.pt.y > pt.y)\r\n                    op2 = op2.next;\r\n            if (op2 === op)\r\n                break;\r\n            if (op2.pt.y === pt.y) {\r\n                if (op2.pt.x === pt.x || (op2.pt.y === op2.prev.pt.y &&\r\n                    (pt.x < op2.prev.pt.x) !== (pt.x < op2.pt.x)))\r\n                    return PointInPolygonResult.IsOn;\r\n                op2 = op2.next;\r\n                if (op2 === op)\r\n                    break;\r\n                continue;\r\n            }\r\n            if (op2.pt.x <= pt.x || op2.prev.pt.x <= pt.x) {\r\n                if (op2.prev.pt.x < pt.x && op2.pt.x < pt.x)\r\n                    val = 1 - val;\r\n                else {\r\n                    const d = InternalClipper.crossProduct(op2.prev.pt, op2.pt, pt);\r\n                    if (d === 0)\r\n                        return PointInPolygonResult.IsOn;\r\n                    if ((d < 0) === isAbove)\r\n                        val = 1 - val;\r\n                }\r\n            }\r\n            isAbove = !isAbove;\r\n            op2 = op2.next;\r\n        }\r\n        if (isAbove !== startingAbove) {\r\n            const d = InternalClipper.crossProduct(op2.prev.pt, op2.pt, pt);\r\n            if (d === 0)\r\n                return PointInPolygonResult.IsOn;\r\n            if ((d < 0) === isAbove)\r\n                val = 1 - val;\r\n        }\r\n        if (val === 0)\r\n            return PointInPolygonResult.IsOutside;\r\n        else\r\n            return PointInPolygonResult.IsInside;\r\n    }\r\n    static path1InsidePath2(op1, op2) {\r\n        let result;\r\n        let outside_cnt = 0;\r\n        let op = op1;\r\n        do {\r\n            result = this.pointInOpPolygon(op.pt, op2);\r\n            if (result === PointInPolygonResult.IsOutside)\r\n                ++outside_cnt;\r\n            else if (result === PointInPolygonResult.IsInside)\r\n                --outside_cnt;\r\n            op = op.next;\r\n        } while (op !== op1 && Math.abs(outside_cnt) < 2);\r\n        if (Math.abs(outside_cnt) > 1)\r\n            return (outside_cnt < 0);\r\n        const mp = ClipperBase.getBoundsPath(this.getCleanPath(op1)).midPoint();\r\n        const path2 = this.getCleanPath(op2);\r\n        return InternalClipper.pointInPolygon(mp, path2) !== PointInPolygonResult.IsOutside;\r\n    }\r\n    moveSplits(fromOr, toOr) {\r\n        if (!fromOr.splits)\r\n            return;\r\n        toOr.splits = toOr.splits || [];\r\n        for (const i of fromOr.splits) {\r\n            toOr.splits.push(i);\r\n        }\r\n        fromOr.splits = undefined;\r\n    }\r\n    processHorzJoins() {\r\n        for (const j of this._horzJoinList) {\r\n            const or1 = ClipperBase.getRealOutRec(j.op1.outrec);\r\n            let or2 = ClipperBase.getRealOutRec(j.op2.outrec);\r\n            const op1b = j.op1.next;\r\n            const op2b = j.op2.prev;\r\n            j.op1.next = j.op2;\r\n            j.op2.prev = j.op1;\r\n            op1b.prev = op2b;\r\n            op2b.next = op1b;\r\n            if (or1 === or2) {\r\n                or2 = this.newOutRec();\r\n                or2.pts = op1b;\r\n                ClipperBase.fixOutRecPts(or2);\r\n                if (or1.pts.outrec === or2) {\r\n                    or1.pts = j.op1;\r\n                    or1.pts.outrec = or1;\r\n                }\r\n                if (this._using_polytree) {\r\n                    if (ClipperBase.path1InsidePath2(or1.pts, or2.pts)) {\r\n                        const tmp = or1.pts;\r\n                        or1.pts = or2.pts;\r\n                        or2.pts = tmp;\r\n                        ClipperBase.fixOutRecPts(or1);\r\n                        ClipperBase.fixOutRecPts(or2);\r\n                        or2.owner = or1.owner;\r\n                    }\r\n                    else if (ClipperBase.path1InsidePath2(or2.pts, or1.pts)) {\r\n                        or2.owner = or1;\r\n                    }\r\n                    else {\r\n                        or2.owner = or1.owner;\r\n                    }\r\n                    or1.splits = or1.splits || [];\r\n                    or1.splits.push(or2.idx);\r\n                }\r\n                else {\r\n                    or2.owner = or1;\r\n                }\r\n            }\r\n            else {\r\n                or2.pts = undefined;\r\n                if (this._using_polytree) {\r\n                    ClipperBase.setOwner(or2, or1);\r\n                    this.moveSplits(or2, or1);\r\n                }\r\n                else {\r\n                    or2.owner = or1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static ptsReallyClose(pt1, pt2) {\r\n        return (Math.abs(pt1.x - pt2.x) < 2) && (Math.abs(pt1.y - pt2.y) < 2);\r\n    }\r\n    static isVerySmallTriangle(op) {\r\n        return op.next.next === op.prev &&\r\n            (this.ptsReallyClose(op.prev.pt, op.next.pt) ||\r\n                this.ptsReallyClose(op.pt, op.next.pt) ||\r\n                this.ptsReallyClose(op.pt, op.prev.pt));\r\n    }\r\n    static isValidClosedPath(op) {\r\n        return op !== undefined && op.next !== op &&\r\n            (op.next !== op.prev || !this.isVerySmallTriangle(op));\r\n    }\r\n    static disposeOutPt(op) {\r\n        const result = op.next === op ? undefined : op.next;\r\n        op.prev.next = op.next;\r\n        op.next.prev = op.prev;\r\n        return result;\r\n    }\r\n    cleanCollinear(outrec) {\r\n        outrec = ClipperBase.getRealOutRec(outrec);\r\n        if (outrec === undefined || outrec.isOpen)\r\n            return;\r\n        if (!ClipperBase.isValidClosedPath(outrec.pts)) {\r\n            outrec.pts = undefined;\r\n            return;\r\n        }\r\n        let startOp = outrec.pts;\r\n        let op2 = startOp;\r\n        for (;;) {\r\n            // NB if preserveCollinear == true, then only remove 180 deg. spikes\r\n            if (InternalClipper.crossProduct(op2.prev.pt, op2.pt, op2.next.pt) === 0 &&\r\n                (op2.pt === op2.prev.pt || op2.pt === op2.next.pt || !this.preserveCollinear ||\r\n                    InternalClipper.dotProduct(op2.prev.pt, op2.pt, op2.next.pt) < 0)) {\r\n                if (op2 === outrec.pts) {\r\n                    outrec.pts = op2.prev;\r\n                }\r\n                op2 = ClipperBase.disposeOutPt(op2);\r\n                if (!ClipperBase.isValidClosedPath(op2)) {\r\n                    outrec.pts = undefined;\r\n                    return;\r\n                }\r\n                startOp = op2;\r\n                continue;\r\n            }\r\n            op2 = op2.next;\r\n            if (op2 === startOp)\r\n                break;\r\n        }\r\n        this.fixSelfIntersects(outrec);\r\n    }\r\n    doSplitOp(outrec, splitOp) {\r\n        // splitOp.prev <=> splitOp &&\r\n        // splitOp.next <=> splitOp.next.next are intersecting\r\n        const prevOp = splitOp.prev;\r\n        const nextNextOp = splitOp.next.next;\r\n        outrec.pts = prevOp;\r\n        const ip = InternalClipper.getIntersectPoint(prevOp.pt, splitOp.pt, splitOp.next.pt, nextNextOp.pt).ip;\r\n        const area1 = ClipperBase.area(prevOp);\r\n        const absArea1 = Math.abs(area1);\r\n        if (absArea1 < 2) {\r\n            outrec.pts = undefined;\r\n            return;\r\n        }\r\n        const area2 = ClipperBase.areaTriangle(ip, splitOp.pt, splitOp.next.pt);\r\n        const absArea2 = Math.abs(area2);\r\n        // de-link splitOp and splitOp.next from the path\r\n        // while inserting the intersection point\r\n        if (ip === prevOp.pt || ip === nextNextOp.pt) {\r\n            nextNextOp.prev = prevOp;\r\n            prevOp.next = nextNextOp;\r\n        }\r\n        else {\r\n            const newOp2 = new OutPt(ip, outrec);\r\n            newOp2.prev = prevOp;\r\n            newOp2.next = nextNextOp;\r\n            nextNextOp.prev = newOp2;\r\n            prevOp.next = newOp2;\r\n        }\r\n        // nb: area1 is the path's area *before* splitting, whereas area2 is\r\n        // the area of the triangle containing splitOp & splitOp.next.\r\n        // So the only way for these areas to have the same sign is if\r\n        // the split triangle is larger than the path containing prevOp or\r\n        // if there's more than one self=intersection.\r\n        if (absArea2 > 1 &&\r\n            (absArea2 > absArea1 || (area2 > 0) === (area1 > 0))) {\r\n            const newOutRec = this.newOutRec();\r\n            newOutRec.owner = outrec.owner;\r\n            splitOp.outrec = newOutRec;\r\n            splitOp.next.outrec = newOutRec;\r\n            const newOp = new OutPt(ip, newOutRec);\r\n            newOp.prev = splitOp.next;\r\n            newOp.next = splitOp;\r\n            newOutRec.pts = newOp;\r\n            splitOp.prev = newOp;\r\n            splitOp.next.next = newOp;\r\n            if (this._using_polytree) {\r\n                if (ClipperBase.path1InsidePath2(prevOp, newOp)) {\r\n                    newOutRec.splits = newOutRec.splits || [];\r\n                    newOutRec.splits.push(outrec.idx);\r\n                }\r\n                else {\r\n                    outrec.splits = outrec.splits || [];\r\n                    outrec.splits.push(newOutRec.idx);\r\n                }\r\n            }\r\n        }\r\n        // else { splitOp = undefined; splitOp.next = undefined; }\r\n    }\r\n    fixSelfIntersects(outrec) {\r\n        let op2 = outrec.pts;\r\n        for (;;) {\r\n            if (op2.prev === op2.next.next)\r\n                break;\r\n            if (InternalClipper.segsIntersect(op2.prev.pt, op2.pt, op2.next.pt, op2.next.next.pt)) {\r\n                this.doSplitOp(outrec, op2);\r\n                if (!outrec.pts)\r\n                    return;\r\n                op2 = outrec.pts;\r\n                continue;\r\n            }\r\n            else {\r\n                op2 = op2.next;\r\n            }\r\n            if (op2 === outrec.pts)\r\n                break;\r\n        }\r\n    }\r\n    static buildPath(op, reverse, isOpen, path) {\r\n        if (op === undefined || op.next === op || (!isOpen && op.next === op.prev))\r\n            return false;\r\n        path.length = 0;\r\n        let lastPt;\r\n        let op2;\r\n        if (reverse) {\r\n            lastPt = op.pt;\r\n            op2 = op.prev;\r\n        }\r\n        else {\r\n            op = op.next;\r\n            lastPt = op.pt;\r\n            op2 = op.next;\r\n        }\r\n        path.push(lastPt);\r\n        while (op2 !== op) {\r\n            if (op2.pt !== lastPt) {\r\n                lastPt = op2.pt;\r\n                path.push(lastPt);\r\n            }\r\n            if (reverse) {\r\n                op2 = op2.prev;\r\n            }\r\n            else {\r\n                op2 = op2.next;\r\n            }\r\n        }\r\n        if (path.length === 3 && this.isVerySmallTriangle(op2))\r\n            return false;\r\n        else\r\n            return true;\r\n    }\r\n    buildPaths(solutionClosed, solutionOpen) {\r\n        solutionClosed.length = 0;\r\n        solutionOpen.length = 0;\r\n        let i = 0;\r\n        while (i < this._outrecList.length) {\r\n            const outrec = this._outrecList[i++];\r\n            if (!outrec.pts)\r\n                continue;\r\n            const path = new Path64();\r\n            if (outrec.isOpen) {\r\n                if (ClipperBase.buildPath(outrec.pts, this.reverseSolution, true, path)) {\r\n                    solutionOpen.push(path);\r\n                }\r\n            }\r\n            else {\r\n                this.cleanCollinear(outrec);\r\n                // closed paths should always return a Positive orientation\r\n                // except when reverseSolution == true\r\n                if (ClipperBase.buildPath(outrec.pts, this.reverseSolution, false, path)) {\r\n                    solutionClosed.push(path);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static getBoundsPath(path) {\r\n        if (path.length === 0)\r\n            return new Rect64();\r\n        const result = Clipper.InvalidRect64;\r\n        for (const pt of path) {\r\n            if (pt.x < result.left)\r\n                result.left = pt.x;\r\n            if (pt.x > result.right)\r\n                result.right = pt.x;\r\n            if (pt.y < result.top)\r\n                result.top = pt.y;\r\n            if (pt.y > result.bottom)\r\n                result.bottom = pt.y;\r\n        }\r\n        return result;\r\n    }\r\n    checkBounds(outrec) {\r\n        if (outrec.pts === undefined)\r\n            return false;\r\n        if (!outrec.bounds.isEmpty())\r\n            return true;\r\n        this.cleanCollinear(outrec);\r\n        if (outrec.pts === undefined || !ClipperBase.buildPath(outrec.pts, this.reverseSolution, false, outrec.path))\r\n            return false;\r\n        outrec.bounds = ClipperBase.getBoundsPath(outrec.path);\r\n        return true;\r\n    }\r\n    checkSplitOwner(outrec, splits) {\r\n        for (const i of splits) {\r\n            const split = ClipperBase.getRealOutRec(this._outrecList[i]);\r\n            if (split === undefined || split === outrec || split.recursiveSplit === outrec)\r\n                continue;\r\n            split.recursiveSplit = outrec; //#599\r\n            if (split.splits !== undefined && this.checkSplitOwner(outrec, split.splits))\r\n                return true;\r\n            if (ClipperBase.isValidOwner(outrec, split) &&\r\n                this.checkBounds(split) &&\r\n                split.bounds.containsRect(outrec.bounds) &&\r\n                ClipperBase.path1InsidePath2(outrec.pts, split.pts)) {\r\n                outrec.owner = split; //found in split\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    recursiveCheckOwners(outrec, polypath) {\r\n        // pre-condition: outrec will have valid bounds\r\n        // post-condition: if a valid path, outrec will have a polypath\r\n        if (outrec.polypath !== undefined || outrec.bounds.isEmpty())\r\n            return;\r\n        while (outrec.owner !== undefined) {\r\n            if (outrec.owner.splits !== undefined &&\r\n                this.checkSplitOwner(outrec, outrec.owner.splits))\r\n                break;\r\n            else if (outrec.owner.pts !== undefined && this.checkBounds(outrec.owner) &&\r\n                ClipperBase.path1InsidePath2(outrec.pts, outrec.owner.pts))\r\n                break;\r\n            outrec.owner = outrec.owner.owner;\r\n        }\r\n        if (outrec.owner !== undefined) {\r\n            if (outrec.owner.polypath === undefined)\r\n                this.recursiveCheckOwners(outrec.owner, polypath);\r\n            outrec.polypath = outrec.owner.polypath.addChild(outrec.path);\r\n        }\r\n        else {\r\n            outrec.polypath = polypath.addChild(outrec.path);\r\n        }\r\n    }\r\n    buildTree(polytree, solutionOpen) {\r\n        polytree.clear();\r\n        solutionOpen.length = 0;\r\n        let i = 0;\r\n        while (i < this._outrecList.length) {\r\n            const outrec = this._outrecList[i++];\r\n            if (outrec.pts === undefined)\r\n                continue;\r\n            if (outrec.isOpen) {\r\n                const open_path = new Path64();\r\n                if (ClipperBase.buildPath(outrec.pts, this.reverseSolution, true, open_path))\r\n                    solutionOpen.push(open_path);\r\n                continue;\r\n            }\r\n            if (this.checkBounds(outrec))\r\n                this.recursiveCheckOwners(outrec, polytree);\r\n        }\r\n    }\r\n    getBounds() {\r\n        const bounds = Clipper.InvalidRect64;\r\n        for (const t of this._vertexList) {\r\n            let v = t;\r\n            do {\r\n                if (v.pt.x < bounds.left)\r\n                    bounds.left = v.pt.x;\r\n                if (v.pt.x > bounds.right)\r\n                    bounds.right = v.pt.x;\r\n                if (v.pt.y < bounds.top)\r\n                    bounds.top = v.pt.y;\r\n                if (v.pt.y > bounds.bottom)\r\n                    bounds.bottom = v.pt.y;\r\n                v = v.next;\r\n            } while (v !== t);\r\n        }\r\n        return bounds.isEmpty() ? new Rect64(0, 0, 0, 0) : bounds;\r\n    }\r\n}\r\nclass Clipper64 extends ClipperBase {\r\n    addPath(path, polytype, isOpen = false) {\r\n        super.addPath(path, polytype, isOpen);\r\n    }\r\n    addReusableData(reusableData) {\r\n        super.addReuseableData(reusableData);\r\n    }\r\n    addPaths(paths, polytype, isOpen = false) {\r\n        super.addPaths(paths, polytype, isOpen);\r\n    }\r\n    addSubjectPaths(paths) {\r\n        this.addPaths(paths, PathType.Subject);\r\n    }\r\n    addOpenSubjectPaths(paths) {\r\n        this.addPaths(paths, PathType.Subject, true);\r\n    }\r\n    addClipPaths(paths) {\r\n        this.addPaths(paths, PathType.Clip);\r\n    }\r\n    execute(clipType, fillRule, solutionClosed, solutionOpen = new Paths64()) {\r\n        solutionClosed.length = 0;\r\n        solutionOpen.length = 0;\r\n        try {\r\n            this.executeInternal(clipType, fillRule);\r\n            this.buildPaths(solutionClosed, solutionOpen);\r\n        }\r\n        catch (error) {\r\n            this._succeeded = false;\r\n        }\r\n        this.clearSolutionOnly();\r\n        return this._succeeded;\r\n    }\r\n    executePolyTree(clipType, fillRule, polytree, openPaths = new Paths64()) {\r\n        polytree.clear();\r\n        openPaths.length = 0;\r\n        this._using_polytree = true;\r\n        try {\r\n            this.executeInternal(clipType, fillRule);\r\n            this.buildTree(polytree, openPaths);\r\n        }\r\n        catch (error) {\r\n            this._succeeded = false;\r\n        }\r\n        this.clearSolutionOnly();\r\n        return this._succeeded;\r\n    }\r\n}\r\nclass PolyPathBase {\r\n    get isHole() {\r\n        return this.getIsHole();\r\n    }\r\n    constructor(parent) {\r\n        this.children = [];\r\n        this.forEach = this.children.forEach;\r\n        this._parent = parent;\r\n    }\r\n    getLevel() {\r\n        let result = 0;\r\n        let pp = this._parent;\r\n        while (pp !== undefined) {\r\n            ++result;\r\n            pp = pp._parent;\r\n        }\r\n        return result;\r\n    }\r\n    get level() {\r\n        return this.getLevel();\r\n    }\r\n    getIsHole() {\r\n        const lvl = this.getLevel();\r\n        return lvl !== 0 && (lvl & 1) === 0;\r\n    }\r\n    get count() {\r\n        return this.children.length;\r\n    }\r\n    clear() {\r\n        this.children.length = 0;\r\n    }\r\n} // end of PolyPathBase class\r\nclass PolyPath64 extends PolyPathBase {\r\n    constructor(parent) {\r\n        super(parent);\r\n    }\r\n    addChild(p) {\r\n        const newChild = new PolyPath64(this);\r\n        newChild.polygon = p;\r\n        this.children.push(newChild);\r\n        return newChild;\r\n    }\r\n    get(index) {\r\n        if (index < 0 || index >= this.children.length) {\r\n            throw new Error(\"InvalidOperationException\");\r\n        }\r\n        return this.children[index];\r\n    }\r\n    child(index) {\r\n        if (index < 0 || index >= this.children.length) {\r\n            throw new Error(\"InvalidOperationException\");\r\n        }\r\n        return this.children[index];\r\n    }\r\n    area() {\r\n        let result = this.polygon ? Clipper.area(this.polygon) : 0;\r\n        for (const polyPathBase of this.children) {\r\n            const child = polyPathBase;\r\n            result += child.area();\r\n        }\r\n        return result;\r\n    }\r\n}\r\nclass PolyTree64 extends PolyPath64 {\r\n}\r\nclass ClipperLibException extends Error {\r\n    constructor(description) {\r\n        super(description);\r\n    }\r\n}\n\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  26 July 2023                                                    *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  Core structures and functions for the Clipper Library           *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\n// Note: all clipping operations except for Difference are commutative.\r\nvar ClipType;\r\n(function (ClipType) {\r\n    ClipType[ClipType[\"None\"] = 0] = \"None\";\r\n    ClipType[ClipType[\"Intersection\"] = 1] = \"Intersection\";\r\n    ClipType[ClipType[\"Union\"] = 2] = \"Union\";\r\n    ClipType[ClipType[\"Difference\"] = 3] = \"Difference\";\r\n    ClipType[ClipType[\"Xor\"] = 4] = \"Xor\";\r\n})(ClipType || (ClipType = {}));\r\nvar PathType;\r\n(function (PathType) {\r\n    PathType[PathType[\"Subject\"] = 0] = \"Subject\";\r\n    PathType[PathType[\"Clip\"] = 1] = \"Clip\";\r\n})(PathType || (PathType = {}));\r\n// By far the most widely used filling rules for polygons are EvenOdd\r\n// and NonZero, sometimes called Alternate and Winding respectively.\r\n// https://en.wikipedia.org/wiki/Nonzero-rule\r\nvar FillRule;\r\n(function (FillRule) {\r\n    FillRule[FillRule[\"EvenOdd\"] = 0] = \"EvenOdd\";\r\n    FillRule[FillRule[\"NonZero\"] = 1] = \"NonZero\";\r\n    FillRule[FillRule[\"Positive\"] = 2] = \"Positive\";\r\n    FillRule[FillRule[\"Negative\"] = 3] = \"Negative\";\r\n})(FillRule || (FillRule = {}));\r\n// PointInPolygon\r\nvar PipResult;\r\n(function (PipResult) {\r\n    PipResult[PipResult[\"Inside\"] = 0] = \"Inside\";\r\n    PipResult[PipResult[\"Outside\"] = 1] = \"Outside\";\r\n    PipResult[PipResult[\"OnEdge\"] = 2] = \"OnEdge\";\r\n})(PipResult || (PipResult = {}));\r\nclass Path64 extends Array {\r\n}\r\nclass Paths64 extends Array {\r\n}\r\nclass Rect64 {\r\n    constructor(lOrIsValidOrRec, t, r, b) {\r\n        if (typeof lOrIsValidOrRec === 'boolean') {\r\n            if (lOrIsValidOrRec) {\r\n                this.left = 0;\r\n                this.top = 0;\r\n                this.right = 0;\r\n                this.bottom = 0;\r\n            }\r\n            else {\r\n                this.left = Number.MAX_SAFE_INTEGER;\r\n                this.top = Number.MAX_SAFE_INTEGER;\r\n                this.right = Number.MIN_SAFE_INTEGER;\r\n                this.bottom = Number.MIN_SAFE_INTEGER;\r\n            }\r\n        }\r\n        else if (typeof lOrIsValidOrRec === 'number') {\r\n            this.left = lOrIsValidOrRec;\r\n            this.top = t;\r\n            this.right = r;\r\n            this.bottom = b;\r\n        }\r\n        else {\r\n            this.left = lOrIsValidOrRec.left;\r\n            this.top = lOrIsValidOrRec.top;\r\n            this.right = lOrIsValidOrRec.right;\r\n            this.bottom = lOrIsValidOrRec.bottom;\r\n        }\r\n    }\r\n    get width() {\r\n        return this.right - this.left;\r\n    }\r\n    set width(value) {\r\n        this.right = this.left + value;\r\n    }\r\n    get height() {\r\n        return this.bottom - this.top;\r\n    }\r\n    set height(value) {\r\n        this.bottom = this.top + value;\r\n    }\r\n    isEmpty() {\r\n        return this.bottom <= this.top || this.right <= this.left;\r\n    }\r\n    midPoint() {\r\n        return new Point64((this.left + this.right) / 2, (this.top + this.bottom) / 2);\r\n    }\r\n    contains(pt) {\r\n        return pt.x > this.left && pt.x < this.right && pt.y > this.top && pt.y < this.bottom;\r\n    }\r\n    containsRect(rec) {\r\n        return rec.left >= this.left && rec.right <= this.right && rec.top >= this.top && rec.bottom <= this.bottom;\r\n    }\r\n    intersects(rec) {\r\n        return (Math.max(this.left, rec.left) <= Math.min(this.right, rec.right)) &&\r\n            (Math.max(this.top, rec.top) <= Math.min(this.bottom, rec.bottom));\r\n    }\r\n    asPath() {\r\n        const result = new Path64();\r\n        result.push(new Point64(this.left, this.top));\r\n        result.push(new Point64(this.right, this.top));\r\n        result.push(new Point64(this.right, this.bottom));\r\n        result.push(new Point64(this.left, this.bottom));\r\n        return result;\r\n    }\r\n}\r\nclass Point64 {\r\n    constructor(xOrPt, yOrScale) {\r\n        if (typeof xOrPt === 'number' && typeof yOrScale === 'number') {\r\n            this.x = Math.round(xOrPt);\r\n            this.y = Math.round(yOrScale);\r\n        }\r\n        else {\r\n            const pt = xOrPt;\r\n            if (yOrScale !== undefined) {\r\n                this.x = Math.round(pt.x * yOrScale);\r\n                this.y = Math.round(pt.y * yOrScale);\r\n            }\r\n            else {\r\n                this.x = pt.x;\r\n                this.y = pt.y;\r\n            }\r\n            //} else {\r\n            //  const pt = xOrPt as Point64\r\n            //  this.x = Math.round((<IPoint64>xOrPt).x * (yOrScale || 1));\r\n            //  this.y = Math.round((<IPoint64>xOrPt).y * (yOrScale || 1));\r\n        }\r\n    }\r\n    static equals(lhs, rhs) {\r\n        return lhs.x === rhs.x && lhs.y === rhs.y;\r\n    }\r\n    static notEquals(lhs, rhs) {\r\n        return lhs.x !== rhs.x || lhs.y !== rhs.y;\r\n    }\r\n    static add(lhs, rhs) {\r\n        return new Point64(lhs.x + rhs.x, lhs.y + rhs.y);\r\n    }\r\n    static subtract(lhs, rhs) {\r\n        return new Point64(lhs.x - rhs.x, lhs.y - rhs.y);\r\n    }\r\n    toString() {\r\n        return `${this.x},${this.y} `;\r\n    }\r\n    equals(obj) {\r\n        if (obj instanceof Point64) {\r\n            return Point64.equals(this, obj);\r\n        }\r\n        return false;\r\n    }\r\n}\r\nclass InternalClipper {\r\n    static checkPrecision(precision) {\r\n        if (precision < -8 || precision > 8)\r\n            throw new Error(this.precision_range_error);\r\n    }\r\n    static isAlmostZero(value) {\r\n        return (Math.abs(value) <= this.floatingPointTolerance);\r\n    }\r\n    static crossProduct(pt1, pt2, pt3) {\r\n        return ((pt2.x - pt1.x) * (pt3.y - pt2.y) - (pt2.y - pt1.y) * (pt3.x - pt2.x));\r\n    }\r\n    static dotProduct(pt1, pt2, pt3) {\r\n        return ((pt2.x - pt1.x) * (pt3.x - pt2.x) + (pt2.y - pt1.y) * (pt3.y - pt2.y));\r\n    }\r\n    static checkCastInt64(val) {\r\n        if ((val >= this.max_coord) || (val <= this.min_coord))\r\n            return this.Invalid64;\r\n        return Math.round(val);\r\n    }\r\n    static getIntersectPt(ln1a, ln1b, ln2a, ln2b) {\r\n        const dy1 = ln1b.y - ln1a.y;\r\n        const dx1 = ln1b.x - ln1a.x;\r\n        const dy2 = ln2b.y - ln2a.y;\r\n        const dx2 = ln2b.x - ln2a.x;\r\n        const det = dy1 * dx2 - dy2 * dx1;\r\n        let ip;\r\n        if (det === 0.0) {\r\n            ip = new Point64(0, 0);\r\n            return { ip, success: false };\r\n        }\r\n        const t = ((ln1a.x - ln2a.x) * dy2 - (ln1a.y - ln2a.y) * dx2) / det;\r\n        if (t <= 0.0)\r\n            ip = ln1a;\r\n        else if (t >= 1.0)\r\n            ip = ln1b;\r\n        else\r\n            ip = new Point64(ln1a.x + t * dx1, ln1a.y + t * dy1);\r\n        return { ip, success: true };\r\n    }\r\n    static getIntersectPoint(ln1a, ln1b, ln2a, ln2b) {\r\n        const dy1 = ln1b.y - ln1a.y;\r\n        const dx1 = ln1b.x - ln1a.x;\r\n        const dy2 = ln2b.y - ln2a.y;\r\n        const dx2 = ln2b.x - ln2a.x;\r\n        const det = dy1 * dx2 - dy2 * dx1;\r\n        let ip;\r\n        if (det === 0.0) {\r\n            ip = new Point64(0, 0);\r\n            return { ip, success: false };\r\n        }\r\n        const t = ((ln1a.x - ln2a.x) * dy2 - (ln1a.y - ln2a.y) * dx2) / det;\r\n        if (t <= 0.0)\r\n            ip = ln1a;\r\n        else if (t >= 1.0)\r\n            ip = ln2a;\r\n        else\r\n            ip = new Point64(ln1a.x + t * dx1, ln1a.y + t * dy1);\r\n        return { ip, success: true };\r\n    }\r\n    static segsIntersect(seg1a, seg1b, seg2a, seg2b, inclusive = false) {\r\n        if (inclusive) {\r\n            const res1 = InternalClipper.crossProduct(seg1a, seg2a, seg2b);\r\n            const res2 = InternalClipper.crossProduct(seg1b, seg2a, seg2b);\r\n            if (res1 * res2 > 0)\r\n                return false;\r\n            const res3 = InternalClipper.crossProduct(seg2a, seg1a, seg1b);\r\n            const res4 = InternalClipper.crossProduct(seg2b, seg1a, seg1b);\r\n            if (res3 * res4 > 0)\r\n                return false;\r\n            return (res1 !== 0 || res2 !== 0 || res3 !== 0 || res4 !== 0);\r\n        }\r\n        else {\r\n            return (InternalClipper.crossProduct(seg1a, seg2a, seg2b) * InternalClipper.crossProduct(seg1b, seg2a, seg2b) < 0) &&\r\n                (InternalClipper.crossProduct(seg2a, seg1a, seg1b) * InternalClipper.crossProduct(seg2b, seg1a, seg1b) < 0);\r\n        }\r\n    }\r\n    static getClosestPtOnSegment(offPt, seg1, seg2) {\r\n        if (seg1.x === seg2.x && seg1.y === seg2.y)\r\n            return seg1;\r\n        const dx = seg2.x - seg1.x;\r\n        const dy = seg2.y - seg1.y;\r\n        let q = ((offPt.x - seg1.x) * dx + (offPt.y - seg1.y) * dy) / ((dx * dx) + (dy * dy));\r\n        if (q < 0)\r\n            q = 0;\r\n        else if (q > 1)\r\n            q = 1;\r\n        return new Point64(seg1.x + Math.round(q * dx), seg1.y + Math.round(q * dy));\r\n    }\r\n    static pointInPolygon(pt, polygon) {\r\n        const len = polygon.length;\r\n        let start = 0;\r\n        if (len < 3)\r\n            return PointInPolygonResult.IsOutside;\r\n        while (start < len && polygon[start].y === pt.y)\r\n            start++;\r\n        if (start === len)\r\n            return PointInPolygonResult.IsOutside;\r\n        let d = 0;\r\n        let isAbove = polygon[start].y < pt.y;\r\n        const startingAbove = isAbove;\r\n        let val = 0;\r\n        let i = start + 1;\r\n        let end = len;\r\n        for (;;) {\r\n            if (i === end) {\r\n                if (end === 0 || start === 0)\r\n                    break;\r\n                end = start;\r\n                i = 0;\r\n            }\r\n            if (isAbove) {\r\n                while (i < end && polygon[i].y < pt.y)\r\n                    i++;\r\n                if (i === end)\r\n                    continue;\r\n            }\r\n            else {\r\n                while (i < end && polygon[i].y > pt.y)\r\n                    i++;\r\n                if (i === end)\r\n                    continue;\r\n            }\r\n            const curr = polygon[i];\r\n            const prev = i > 0 ? polygon[i - 1] : polygon[len - 1];\r\n            if (curr.y === pt.y) {\r\n                if (curr.x === pt.x || (curr.y === prev.y && (pt.x < prev.x !== pt.x < curr.x)))\r\n                    return PointInPolygonResult.IsOn;\r\n                i++;\r\n                if (i === start)\r\n                    break;\r\n                continue;\r\n            }\r\n            if (pt.x < curr.x && pt.x < prev.x) {\r\n                // we're only interested in edges crossing on the left\r\n            }\r\n            else if (pt.x > prev.x && pt.x > curr.x) {\r\n                val = 1 - val; // toggle val\r\n            }\r\n            else {\r\n                d = InternalClipper.crossProduct(prev, curr, pt);\r\n                if (d === 0)\r\n                    return PointInPolygonResult.IsOn;\r\n                if ((d < 0) === isAbove)\r\n                    val = 1 - val;\r\n            }\r\n            isAbove = !isAbove;\r\n            i++;\r\n        }\r\n        if (isAbove !== startingAbove) {\r\n            if (i === len)\r\n                i = 0;\r\n            else\r\n                d = InternalClipper.crossProduct(polygon[i - 1], polygon[i], pt);\r\n            if (d === 0)\r\n                return PointInPolygonResult.IsOn;\r\n            if ((d < 0) === isAbove)\r\n                val = 1 - val;\r\n        }\r\n        if (val === 0)\r\n            return PointInPolygonResult.IsOutside;\r\n        return PointInPolygonResult.IsInside;\r\n    }\r\n}\r\nInternalClipper.MaxInt64 = 9223372036854775807;\r\nInternalClipper.MaxCoord = InternalClipper.MaxInt64 / 4;\r\nInternalClipper.max_coord = InternalClipper.MaxCoord;\r\nInternalClipper.min_coord = -InternalClipper.MaxCoord;\r\nInternalClipper.Invalid64 = InternalClipper.MaxInt64;\r\nInternalClipper.defaultArcTolerance = 0.25;\r\nInternalClipper.floatingPointTolerance = 1E-12;\r\nInternalClipper.defaultMinimumEdgeLength = 0.1;\r\nInternalClipper.precision_range_error = \"Error: Precision is out of range.\";\n\n/*\r\n * Public API Surface of clipper2-js\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { Active, ClipType, Clipper, Clipper64, ClipperBase, ClipperEngine, ClipperLibException, ClipperOffset, EndType, FillRule, HorzPosition, InternalClipper, JoinType, JoinWith, Minkowski, OutPt2, OutRec, Path64, PathType, Paths64, PipResult, Point64, PointD, PointInPolygonResult, PolyPath64, PolyPathBase, PolyTree64, Rect64, RectClip64, RectClipLines64, ReuseableDataContainer64, VertexFlags };\n//# sourceMappingURL=clipper2-js.mjs.map\n","/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  15 October 2022                                                 *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2022                                         *\r\n* Purpose   :  Minkowski Sum and Difference                                    *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\n\r\nimport { Clipper } from \"./clipper\";\r\nimport { FillRule, IPoint64, Path64, Paths64 } from \"./core\";\r\n\r\n\r\nexport class Minkowski {\r\n  private static minkowskiInternal(pattern: Path64, path: Path64, isSum: boolean, isClosed: boolean): Paths64 {\r\n    const delta = isClosed ? 0 : 1;\r\n    const patLen = pattern.length;\r\n    const pathLen = path.length;\r\n    const tmp: Array<Array<IPoint64>> = []\r\n\r\n    for (const pathPt of path) {\r\n      const path2: Array<IPoint64> = []\r\n      if (isSum) {\r\n        for (const basePt of pattern)\r\n          path2.push({ x: pathPt.x + basePt.x, y: pathPt.y + basePt.y });\r\n      } else {\r\n        for (const basePt of pattern)\r\n          path2.push({ x: pathPt.x - basePt.x, y: pathPt.y - basePt.y });\r\n      }\r\n      tmp.push(path2);\r\n    }\r\n\r\n    const result: Array<Array<IPoint64>> = []\r\n    let g = isClosed ? pathLen - 1 : 0;\r\n\r\n    let h = patLen - 1;\r\n    for (let i = delta; i < pathLen; i++) {\r\n      for (let j = 0; j < patLen; j++) {\r\n        const quad: Path64 = [tmp[g][h], tmp[i][h], tmp[i][j], tmp[g][j]];\r\n        if (!Clipper.isPositive(quad))\r\n          result.push(Clipper.reversePath(quad));\r\n        else\r\n          result.push(quad);\r\n        h = j;\r\n      }\r\n      g = i;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public static sum(pattern: Path64, path: Path64, isClosed: boolean): Paths64 {\r\n    return Clipper.Union(this.minkowskiInternal(pattern, path, true, isClosed), undefined, FillRule.NonZero);\r\n  }\r\n\r\n  public static diff(pattern: Path64, path: Path64, isClosed: boolean): Paths64 {\r\n    return Clipper.Union(this.minkowskiInternal(pattern, path, false, isClosed), undefined, FillRule.NonZero);\r\n  }\r\n\r\n}\r\n","/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  7 August 2023                                                   *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  Path Offset (Inflate/Shrink)                                    *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\n\r\nimport { Clipper } from \"./clipper\";\r\nimport { ClipType, FillRule, IPoint64, InternalClipper, Path64, Paths64, Point64, Rect64 } from \"./core\";\r\nimport { Clipper64, PolyTree64 } from \"./engine\";\r\n\r\nexport enum JoinType {\r\n  Square,\r\n  Round,\r\n  Miter\r\n}\r\n\r\nexport enum EndType {\r\n  Polygon,\r\n  Joined,\r\n  Butt,\r\n  Square,\r\n  Round\r\n}\r\n\r\nclass Group {\r\n  inPaths: Paths64;\r\n  outPath: Path64;\r\n  outPaths: Paths64;\r\n  joinType: JoinType;\r\n  endType: EndType;\r\n  pathsReversed: boolean;\r\n\r\n  constructor(paths: Paths64, joinType: JoinType, endType: EndType = EndType.Polygon) {\r\n    this.inPaths = [...paths]; // creates a shallow copy of paths\r\n    this.joinType = joinType;\r\n    this.endType = endType;\r\n    this.outPath = [];\r\n    this.outPaths = [];\r\n    this.pathsReversed = false;\r\n  }\r\n}\r\n\r\nexport class PointD implements IPoint64 {\r\n  public x: number;\r\n  public y: number;\r\n\r\n  constructor(xOrPt: number | PointD | Point64, yOrScale?: number) {\r\n    if (typeof xOrPt === 'number' && typeof yOrScale === 'number') {\r\n      this.x = xOrPt;\r\n      this.y = yOrScale;\r\n    } else if (xOrPt instanceof PointD) {\r\n      if (yOrScale !== undefined) {\r\n        this.x = xOrPt.x * yOrScale;\r\n        this.y = xOrPt.y * yOrScale;\r\n      } else {\r\n        this.x = xOrPt.x;\r\n        this.y = xOrPt.y;\r\n      }\r\n    } else {\r\n      this.x = (<Point64>xOrPt).x * (yOrScale || 1);\r\n      this.y = (<Point64>xOrPt).y * (yOrScale || 1);\r\n    }\r\n  }\r\n\r\n  public toString(precision: number = 2): string {\r\n    return `${this.x.toFixed(precision)},${this.y.toFixed(precision)}`;\r\n  }\r\n\r\n  public static equals(lhs: PointD, rhs: PointD): boolean {\r\n    return InternalClipper.isAlmostZero(lhs.x - rhs.x) &&\r\n      InternalClipper.isAlmostZero(lhs.y - rhs.y);\r\n  }\r\n\r\n  public static notEquals(lhs: PointD, rhs: PointD): boolean {\r\n    return !InternalClipper.isAlmostZero(lhs.x - rhs.x) ||\r\n      !InternalClipper.isAlmostZero(lhs.y - rhs.y);\r\n  }\r\n\r\n  public equals(obj: PointD): boolean {\r\n    if (obj instanceof PointD) {\r\n      return PointD.equals(this, obj);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public negate(): void {\r\n    this.x = -this.x;\r\n    this.y = -this.y;\r\n  }\r\n\r\n  //  public getHashCode(): number {\r\n  //    return this.x ^ this.y;  // XOR-based hash combination. Adjust if needed.\r\n  //  }\r\n}\r\n\r\nexport class ClipperOffset {\r\n\r\n  private static Tolerance: number = 1.0E-12;\r\n  private _groupList: Array<Group> = [];\r\n  private _normals: Array<PointD> = [];\r\n  private _solution: Paths64 = [];\r\n  private _groupDelta!: number; //*0.5 for open paths; *-1.0 for negative areas\r\n  private _delta!: number;\r\n  private _mitLimSqr!: number;\r\n  private _stepsPerRad!: number;\r\n  private _stepSin!: number;\r\n  private _stepCos!: number;\r\n  private _joinType!: JoinType;\r\n  private _endType!: EndType;\r\n  public ArcTolerance: number;\r\n  public MergeGroups: boolean;\r\n  public MiterLimit: number;\r\n  public PreserveCollinear: boolean;\r\n  public ReverseSolution: boolean;\r\n\r\n  public DeltaCallback?: (path: IPoint64[], path_norms: PointD[], currPt: number, prevPt: number) => number;\r\n\r\n  constructor(miterLimit: number = 2.0, arcTolerance: number = 0.0,\r\n    preserveCollinear: boolean = false, reverseSolution: boolean = false) {\r\n    this.MiterLimit = miterLimit;\r\n    this.ArcTolerance = arcTolerance;\r\n    this.MergeGroups = true;\r\n    this.PreserveCollinear = preserveCollinear;\r\n    this.ReverseSolution = reverseSolution;\r\n  }\r\n\r\n  public clear(): void {\r\n    this._groupList = [];\r\n  }\r\n\r\n  public addPath(path: Point64[], joinType: JoinType, endType: EndType): void {\r\n    if (path.length === 0) return;\r\n    const pp: Point64[][] = [path];\r\n    this.addPaths(pp, joinType, endType);\r\n  }\r\n\r\n  public addPaths(paths: Paths64, joinType: JoinType, endType: EndType): void {\r\n    if (paths.length === 0) return;\r\n    this._groupList.push(new Group(paths, joinType, endType));\r\n  }\r\n\r\n  private executeInternal(delta: number): void {\r\n    this._solution = [];\r\n    if (this._groupList.length === 0) return;\r\n\r\n    if (Math.abs(delta) < 0.5) {\r\n      for (const group of this._groupList) {\r\n        for (const path of group.inPaths) {\r\n          this._solution.push(path);\r\n        }\r\n      }\r\n    } else {\r\n      this._delta = delta;\r\n      this._mitLimSqr = (this.MiterLimit <= 1 ? 2.0 : 2.0 / this.sqr(this.MiterLimit));\r\n      for (const group of this._groupList) {\r\n        this.doGroupOffset(group);\r\n      }\r\n    }\r\n  }\r\n\r\n  private sqr(value: number): number {\r\n    return value * value;\r\n  }\r\n\r\n\r\n  public execute(delta: number, solution: Paths64): void {\r\n    solution.length = 0;\r\n    this.executeInternal(delta);\r\n    if (this._groupList.length === 0) return;\r\n\r\n    // clean up self-intersections ...\r\n    const c = new Clipper64()\r\n    c.preserveCollinear = this.PreserveCollinear\r\n    // the solution should retain the orientation of the input\r\n    c.reverseSolution = this.ReverseSolution !== this._groupList[0].pathsReversed\r\n\r\n    c.addSubjectPaths(this._solution);\r\n    if (this._groupList[0].pathsReversed)\r\n      c.execute(ClipType.Union, FillRule.Negative, solution);\r\n    else\r\n      c.execute(ClipType.Union, FillRule.Positive, solution);\r\n  }\r\n\r\n  public executePolytree(delta: number, polytree: PolyTree64): void {\r\n    polytree.clear();\r\n    this.executeInternal(delta);\r\n    if (this._groupList.length === 0) return;\r\n\r\n    // clean up self-intersections ...\r\n    const c = new Clipper64()\r\n    c.preserveCollinear = this.PreserveCollinear\r\n    // the solution should retain the orientation of the input\r\n    c.reverseSolution = this.ReverseSolution !== this._groupList[0].pathsReversed\r\n\r\n    c.addSubjectPaths(this._solution);\r\n    if (this._groupList[0].pathsReversed)\r\n      c.executePolyTree(ClipType.Union, FillRule.Negative, polytree);\r\n    else\r\n      c.executePolyTree(ClipType.Union, FillRule.Positive, polytree);\r\n  }\r\n\r\n  protected static getUnitNormal(pt1: IPoint64, pt2: IPoint64): PointD {\r\n    let dx = pt2.x - pt1.x;\r\n    let dy = pt2.y - pt1.y;\r\n    if (dx === 0 && dy === 0) return new PointD(0, 0);\r\n\r\n    const f = 1.0 / Math.sqrt(dx * dx + dy * dy);\r\n    dx *= f;\r\n    dy *= f;\r\n\r\n    return new PointD(dy, -dx);\r\n  }\r\n\r\n  public executeCallback(deltaCallback: (path: IPoint64[], path_norms: PointD[], currPt: number, prevPt: number) => number, solution: Point64[][]): void {\r\n    this.DeltaCallback = deltaCallback;\r\n    this.execute(1.0, solution);\r\n  }\r\n\r\n  private static getBoundsAndLowestPolyIdx(paths: Paths64): { index: number, rec: Rect64 } {\r\n    const rec = new Rect64(false); // ie invalid rect\r\n    let lpX: number = Number.MIN_SAFE_INTEGER;\r\n    let index = -1;\r\n    for (let i = 0; i < paths.length; i++) {\r\n      for (const pt of paths[i]) {\r\n        if (pt.y >= rec.bottom) {\r\n          if (pt.y > rec.bottom || pt.x < lpX) {\r\n            index = i;\r\n            lpX = pt.x;\r\n            rec.bottom = pt.y;\r\n          }\r\n        } else if (pt.y < rec.top) rec.top = pt.y;\r\n        if (pt.x > rec.right) rec.right = pt.x;\r\n        else if (pt.x < rec.left) rec.left = pt.x;\r\n      }\r\n    }\r\n    return { index, rec }\r\n  }\r\n\r\n  private static translatePoint(pt: PointD, dx: number, dy: number): PointD {\r\n    return new PointD(pt.x + dx, pt.y + dy);\r\n  }\r\n\r\n  private static reflectPoint(pt: PointD, pivot: PointD): PointD {\r\n    return new PointD(pivot.x + (pivot.x - pt.x), pivot.y + (pivot.y - pt.y));\r\n  }\r\n\r\n  private static almostZero(value: number, epsilon: number = 0.001): boolean {\r\n    return Math.abs(value) < epsilon;\r\n  }\r\n\r\n  private static hypotenuse(x: number, y: number): number {\r\n    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n  }\r\n\r\n  private static normalizeVector(vec: PointD): PointD {\r\n    const h = this.hypotenuse(vec.x, vec.y);\r\n    if (this.almostZero(h)) return new PointD(0, 0);\r\n    const inverseHypot = 1 / h;\r\n    return new PointD(vec.x * inverseHypot, vec.y * inverseHypot);\r\n  }\r\n\r\n  private static getAvgUnitVector(vec1: PointD, vec2: PointD): PointD {\r\n    return this.normalizeVector(new PointD(vec1.x + vec2.x, vec1.y + vec2.y));\r\n  }\r\n\r\n  private static intersectPoint(pt1a: PointD, pt1b: PointD, pt2a: PointD, pt2b: PointD): PointD {\r\n    if (InternalClipper.isAlmostZero(pt1a.x - pt1b.x)) { //vertical\r\n      if (InternalClipper.isAlmostZero(pt2a.x - pt2b.x)) return new PointD(0, 0);\r\n      const m2 = (pt2b.y - pt2a.y) / (pt2b.x - pt2a.x);\r\n      const b2 = pt2a.y - m2 * pt2a.x;\r\n      return new PointD(pt1a.x, m2 * pt1a.x + b2);\r\n    }\r\n\r\n    if (InternalClipper.isAlmostZero(pt2a.x - pt2b.x)) { //vertical\r\n      const m1 = (pt1b.y - pt1a.y) / (pt1b.x - pt1a.x);\r\n      const b1 = pt1a.y - m1 * pt1a.x;\r\n      return new PointD(pt2a.x, m1 * pt2a.x + b1);\r\n    } else {\r\n      const m1 = (pt1b.y - pt1a.y) / (pt1b.x - pt1a.x);\r\n      const b1 = pt1a.y - m1 * pt1a.x;\r\n      const m2 = (pt2b.y - pt2a.y) / (pt2b.x - pt2a.x);\r\n      const b2 = pt2a.y - m2 * pt2a.x;\r\n      if (InternalClipper.isAlmostZero(m1 - m2)) return new PointD(0, 0);\r\n      const x = (b2 - b1) / (m1 - m2);\r\n      return new PointD(x, m1 * x + b1);\r\n    }\r\n  }\r\n\r\n  private getPerpendic(pt: IPoint64, norm: PointD): Point64 {\r\n    return new Point64(pt.x + norm.x * this._groupDelta, pt.y + norm.y * this._groupDelta);\r\n  }\r\n\r\n  private getPerpendicD(pt: IPoint64, norm: PointD): PointD {\r\n    return new PointD(pt.x + norm.x * this._groupDelta, pt.y + norm.y * this._groupDelta);\r\n  }\r\n\r\n  private doSquare(group: Group, path: Path64, j: number, k: number): void {\r\n    let vec: PointD;\r\n    if (j === k) {\r\n      vec = new PointD(this._normals[j].y, -this._normals[j].x);\r\n    } else {\r\n      vec = ClipperOffset.getAvgUnitVector(\r\n        new PointD(-this._normals[k].y, this._normals[k].x),\r\n        new PointD(this._normals[j].y, -this._normals[j].x)\r\n      );\r\n    }\r\n\r\n    const absDelta = Math.abs(this._groupDelta);\r\n    // now offset the original vertex delta units along unit vector\r\n    let ptQ = new PointD(path[j].x, path[j].y); \r\n    ptQ = ClipperOffset.translatePoint(ptQ, absDelta * vec.x, absDelta * vec.y);\r\n\r\n    // get perpendicular vertices\r\n    const pt1 = ClipperOffset.translatePoint(ptQ, this._groupDelta * vec.y, this._groupDelta * -vec.x);\r\n    const pt2 = ClipperOffset.translatePoint(ptQ, this._groupDelta * -vec.y, this._groupDelta * vec.x);\r\n    // get 2 vertices along one edge offset\r\n    const pt3 = this.getPerpendicD(path[k], this._normals[k]);\r\n\r\n    if (j === k) {\r\n      const pt4 = new PointD(pt3.x + vec.x * this._groupDelta, pt3.y + vec.y * this._groupDelta);\r\n      const pt = ClipperOffset.intersectPoint(pt1, pt2, pt3, pt4);\r\n      //get the second intersect point through reflection\r\n      group.outPath.push(new Point64(ClipperOffset.reflectPoint(pt, ptQ).x, ClipperOffset.reflectPoint(pt, ptQ).y));\r\n      group.outPath.push(new Point64(pt.x, pt.y));\r\n    } else {\r\n      const pt4 = this.getPerpendicD(path[j], this._normals[k]);\r\n      const pt = ClipperOffset.intersectPoint(pt1, pt2, pt3, pt4);\r\n      group.outPath.push(new Point64(pt.x, pt.y));\r\n      //get the second intersect point through reflection\r\n      group.outPath.push(new Point64(ClipperOffset.reflectPoint(pt, ptQ).x, ClipperOffset.reflectPoint(pt, ptQ).y));\r\n    }\r\n  }\r\n\r\n  private doMiter(group: Group, path: Path64, j: number, k: number, cosA: number): void {\r\n    const q = this._groupDelta / (cosA + 1);\r\n    group.outPath.push(new Point64(\r\n      path[j].x + (this._normals[k].x + this._normals[j].x) * q,\r\n      path[j].y + (this._normals[k].y + this._normals[j].y) * q\r\n    ));\r\n  }\r\n\r\n  private doRound(group: Group, path: Path64, j: number, k: number, angle: number): void {\r\n    if (typeof this.DeltaCallback !== \"undefined\") {\r\n      const absDelta = Math.abs(this._groupDelta);\r\n      const arcTol = this.ArcTolerance > 0.01\r\n        ? this.ArcTolerance\r\n        : Math.log10(2 + absDelta) * InternalClipper.defaultArcTolerance;\r\n      const stepsPer360 = Math.PI / Math.acos(1 - arcTol / absDelta);\r\n      this._stepSin = Math.sin((2 * Math.PI) / stepsPer360);\r\n      this._stepCos = Math.cos((2 * Math.PI) / stepsPer360);\r\n      if (this._groupDelta < 0.0) this._stepSin = -this._stepSin;\r\n      this._stepsPerRad = stepsPer360 / (2 * Math.PI);\r\n    }\r\n\r\n    const pt = path[j];\r\n    let offsetVec = new PointD(this._normals[k].x * this._groupDelta, this._normals[k].y * this._groupDelta);\r\n    if (j === k) offsetVec.negate();\r\n    group.outPath.push(new Point64(pt.x + offsetVec.x, pt.y + offsetVec.y));\r\n    if (angle > -Math.PI + 0.01) {\r\n      const steps = Math.ceil(this._stepsPerRad * Math.abs(angle));\r\n      for (let i = 1; i < steps; i++) {\r\n        offsetVec = new PointD(\r\n          offsetVec.x * this._stepCos - this._stepSin * offsetVec.y,\r\n          offsetVec.x * this._stepSin + offsetVec.y * this._stepCos\r\n        );\r\n        group.outPath.push(new Point64(pt.x + offsetVec.x, pt.y + offsetVec.y));\r\n      }\r\n    }\r\n    group.outPath.push(this.getPerpendic(pt, this._normals[j]));\r\n  }\r\n\r\n  private buildNormals(path: Path64): void {\r\n    const cnt = path.length;\r\n    this._normals = [];\r\n    this._normals.length = cnt;\r\n\r\n    for (let i = 0; i < cnt - 1; i++) {\r\n      this._normals.push(ClipperOffset.getUnitNormal(path[i], path[i + 1]));\r\n    }\r\n    this._normals.push(ClipperOffset.getUnitNormal(path[cnt - 1], path[0]));\r\n  }\r\n\r\n  crossProduct(vec1: PointD, vec2: PointD): number {\r\n    return (vec1.y * vec2.x - vec2.y * vec1.x);\r\n  }\r\n\r\n  dotProduct(vec1: PointD, vec2: PointD): number {\r\n    return (vec1.x * vec2.x + vec1.y * vec2.y);\r\n  }\r\n\r\n  private offsetPoint(group: Group, path: Path64, j: number, k: number): void {\r\n    const sinA = this.crossProduct(this._normals[j], this._normals[k]);\r\n    let cosA = this.dotProduct(this._normals[j], this._normals[k]);\r\n    if (sinA > 1.0) cosA = 1.0;\r\n    else if (sinA < -1.0) cosA = -1.0;\r\n\r\n    if (typeof this.DeltaCallback !== \"undefined\") {\r\n      this._groupDelta = this.DeltaCallback(path, this._normals, j, k);\r\n      if (group.pathsReversed) this._groupDelta = -this._groupDelta;\r\n    }\r\n\r\n    if (Math.abs(this._groupDelta) < ClipperOffset.Tolerance) {\r\n      group.outPath.push(path[j]);\r\n      return;\r\n    }\r\n\r\n    if (cosA > 0.999) {\r\n      this.doMiter(group, path, j, k, cosA);\r\n    } else if (cosA > -0.99 && (sinA * this._groupDelta < 0)) {\r\n      group.outPath.push(this.getPerpendic(path[j], this._normals[k]));\r\n      group.outPath.push(path[j]);\r\n      group.outPath.push(this.getPerpendic(path[j], this._normals[j]));\r\n    } else if (this._joinType === JoinType.Miter) {\r\n      if (cosA > this._mitLimSqr - 1) {\r\n        this.doMiter(group, path, j, k, cosA);\r\n      } else {\r\n        this.doSquare(group, path, j, k);\r\n      }\r\n    } else if (cosA > 0.99 || this._joinType === JoinType.Square) {\r\n      this.doSquare(group, path, j, k);\r\n    } else {\r\n      this.doRound(group, path, j, k, Math.atan2(sinA, cosA));\r\n    }\r\n\r\n    k = j;\r\n  }\r\n\r\n  private offsetPolygon(group: Group, path: Path64): void {\r\n    const area = Clipper.area(path);\r\n    if ((area < 0) !== (this._groupDelta < 0)) {\r\n      const rect = Clipper.getBounds(path);\r\n      if (Math.abs(this._groupDelta) * 2 > rect.width) return;\r\n    }\r\n\r\n    group.outPath = [];\r\n    const cnt = path.length;\r\n    const prev = cnt - 1;\r\n    for (let i = 0; i < cnt; i++) {\r\n      this.offsetPoint(group, path, i, prev);\r\n    }\r\n    group.outPaths.push(group.outPath);\r\n  }\r\n\r\n  private offsetOpenJoined(group: Group, path: Path64): void {\r\n    this.offsetPolygon(group, path);\r\n    path = Clipper.reversePath(path);\r\n    this.buildNormals(path);\r\n    this.offsetPolygon(group, path);\r\n  }\r\n\r\n  private offsetOpenPath(group: Group, path: Path64): void {\r\n    group.outPath = [];\r\n    const highI = path.length - 1;\r\n\r\n    if (typeof this.DeltaCallback !== \"undefined\") {\r\n      this._groupDelta = this.DeltaCallback(path, this._normals, 0, 0);\r\n    }\r\n\r\n    if (Math.abs(this._groupDelta) < ClipperOffset.Tolerance) {\r\n      group.outPath.push(path[0]);\r\n    } else {\r\n      switch (this._endType) {\r\n        case EndType.Butt:\r\n          group.outPath.push(new Point64(\r\n            path[0].x - this._normals[0].x * this._groupDelta,\r\n            path[0].y - this._normals[0].y * this._groupDelta\r\n          ));\r\n          group.outPath.push(this.getPerpendic(path[0], this._normals[0]));\r\n          break;\r\n        case EndType.Round:\r\n          this.doRound(group, path, 0, 0, Math.PI);\r\n          break;\r\n        default:\r\n          this.doSquare(group, path, 0, 0);\r\n          break;\r\n      }\r\n    }\r\n\r\n    for (let i = 1, k = 0; i < highI; i++) {\r\n      this.offsetPoint(group, path, i, k);\r\n    }\r\n\r\n    for (let i = highI; i > 0; i--) {\r\n      this._normals[i] = new PointD(-this._normals[i - 1].x, -this._normals[i - 1].y);\r\n    }\r\n    this._normals[0] = this._normals[highI];\r\n\r\n    if (typeof this.DeltaCallback !== \"undefined\") {\r\n      this._groupDelta = this.DeltaCallback(path, this._normals, highI, highI);\r\n    }\r\n\r\n    if (Math.abs(this._groupDelta) < ClipperOffset.Tolerance) {\r\n      group.outPath.push(path[highI]);\r\n    } else {\r\n      switch (this._endType) {\r\n        case EndType.Butt:\r\n          group.outPath.push(new Point64(\r\n            path[highI].x - this._normals[highI].x * this._groupDelta,\r\n            path[highI].y - this._normals[highI].y * this._groupDelta\r\n          ));\r\n          group.outPath.push(this.getPerpendic(path[highI], this._normals[highI]));\r\n          break;\r\n        case EndType.Round:\r\n          this.doRound(group, path, highI, highI, Math.PI);\r\n          break;\r\n        default:\r\n          this.doSquare(group, path, highI, highI);\r\n          break;\r\n      }\r\n    }\r\n\r\n    for (let i = highI, k = 0; i > 0; i--) {\r\n      this.offsetPoint(group, path, i, k);\r\n    }\r\n\r\n    group.outPaths.push(group.outPath);\r\n  }\r\n\r\n  private doGroupOffset(group: Group): void {\r\n    if (group.endType == EndType.Polygon) {\r\n\r\n      const { index } = ClipperOffset.getBoundsAndLowestPolyIdx(group.inPaths);\r\n\r\n      if (index < 0) return;\r\n\r\n      const area = Clipper.area(group.inPaths[index]);\r\n      group.pathsReversed = area < 0;\r\n\r\n      if (group.pathsReversed) {\r\n        this._groupDelta = -this._delta;\r\n      } else {\r\n        this._groupDelta = this._delta;\r\n      }\r\n    } else {\r\n      group.pathsReversed = false;\r\n      this._groupDelta = Math.abs(this._delta) * 0.5;\r\n    }\r\n\r\n    const absDelta = Math.abs(this._groupDelta);\r\n    this._joinType = group.joinType;\r\n    this._endType = group.endType;\r\n\r\n    if (!this.DeltaCallback &&\r\n      (group.joinType == JoinType.Round || group.endType == EndType.Round)) {\r\n      const arcTol = this.ArcTolerance > 0.01\r\n        ? this.ArcTolerance\r\n        : Math.log10(2 + absDelta) * InternalClipper.defaultArcTolerance;\r\n\r\n      const stepsPer360 = Math.PI / Math.acos(1 - arcTol / absDelta);\r\n      this._stepSin = Math.sin((2 * Math.PI) / stepsPer360);\r\n      this._stepCos = Math.cos((2 * Math.PI) / stepsPer360);\r\n\r\n      if (this._groupDelta < 0.0) {\r\n        this._stepSin = -this._stepSin;\r\n      }\r\n\r\n      this._stepsPerRad = stepsPer360 / (2 * Math.PI);\r\n    }\r\n\r\n    const isJoined = group.endType == EndType.Joined || group.endType == EndType.Polygon;\r\n\r\n    for (const p of group.inPaths) {\r\n      const path = Clipper.stripDuplicates(p, isJoined);\r\n      const cnt = path.length;\r\n\r\n      if (cnt === 0 || (cnt < 3 && this._endType == EndType.Polygon)) {\r\n        continue;\r\n      }\r\n\r\n      if (cnt == 1) {\r\n        group.outPath = [];\r\n\r\n        if (group.endType == EndType.Round) {\r\n          const r = absDelta;\r\n          group.outPath = Clipper.ellipse(path[0], r, r);\r\n        } else {\r\n          const d = Math.ceil(this._groupDelta);\r\n          const r = new Rect64(path[0].x - d, path[0].y - d, path[0].x - d, path[0].y - d);\r\n          group.outPath = r.asPath();\r\n        }\r\n\r\n        group.outPaths.push(group.outPath);\r\n      } else {\r\n        if (cnt == 2 && group.endType == EndType.Joined) {\r\n          if (group.joinType == JoinType.Round) {\r\n            this._endType = EndType.Round;\r\n          } else {\r\n            this._endType = EndType.Square;\r\n          }\r\n        }\r\n\r\n        this.buildNormals(path);\r\n\r\n        if (this._endType == EndType.Polygon) {\r\n          this.offsetPolygon(group, path);\r\n        } else if (this._endType == EndType.Joined) {\r\n          this.offsetOpenJoined(group, path);\r\n        } else {\r\n          this.offsetOpenPath(group, path);\r\n        }\r\n      }\r\n    }\r\n\r\n    this._solution.push(...group.outPaths);\r\n    group.outPaths = [];\r\n  }\r\n}\r\n","/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  6 August 2023                                                   *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  FAST rectangular clipping                                       *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\n\r\nimport { Clipper } from \"./clipper\";\r\nimport { IPoint64, InternalClipper, Path64, Paths64, Point64, Rect64 } from \"./core\";\r\nimport { PointInPolygonResult } from \"./engine\";\r\n\r\nexport class OutPt2 {\r\n  next?: OutPt2;\r\n  prev?: OutPt2;\r\n\r\n  pt: IPoint64;\r\n  ownerIdx: number;\r\n  edge?: Array<OutPt2 | undefined>;\r\n\r\n  constructor(pt: IPoint64) {\r\n    this.pt = pt;\r\n    this.ownerIdx = 0\r\n  }\r\n}\r\n\r\nenum Location {\r\n  left, top, right, bottom, inside\r\n}\r\n\r\nexport class RectClip64 {\r\n  protected rect: Rect64;\r\n  protected mp: Point64;\r\n  protected rectPath: Path64;\r\n  protected pathBounds!: Rect64;\r\n  protected results: Array<OutPt2 | undefined>\r\n  protected edges: Array<OutPt2 | undefined>[];\r\n  protected currIdx = -1;\r\n\r\n  constructor(rect: Rect64) {\r\n    this.rect = rect;\r\n    this.mp = rect.midPoint();\r\n    this.rectPath = rect.asPath();\r\n    this.results = [];\r\n    this.edges = Array(8).fill(undefined).map(() => []);\r\n  }\r\n\r\n  protected add(pt: IPoint64, startingNewPath: boolean = false): OutPt2  {\r\n    let currIdx = this.results.length;\r\n    let result: OutPt2;\r\n    if (currIdx === 0 || startingNewPath) {\r\n      result = new OutPt2(pt);\r\n      this.results.push(result);\r\n      result.ownerIdx = currIdx;\r\n      result.prev = result;\r\n      result.next = result;\r\n    } else {\r\n      currIdx--;\r\n      const prevOp = this.results[currIdx];\r\n      if (prevOp!.pt === pt) return prevOp!;\r\n      result = new OutPt2(pt);\r\n      result.ownerIdx = currIdx;\r\n      result.next = prevOp!.next;\r\n      prevOp!.next!.prev = result;\r\n      prevOp!.next = result;\r\n      result.prev = prevOp!;\r\n      this.results[currIdx] = result;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private static path1ContainsPath2(path1: Path64, path2: Path64): boolean {\r\n    let ioCount = 0;\r\n    for (const pt of path2) {\r\n      const pip = InternalClipper.pointInPolygon(pt, path1);\r\n      switch (pip) {\r\n        case PointInPolygonResult.IsInside:\r\n          ioCount--; break;\r\n        case PointInPolygonResult.IsOutside:\r\n          ioCount++; break;\r\n      }\r\n      if (Math.abs(ioCount) > 1) break;\r\n    }\r\n    return ioCount <= 0;\r\n  }\r\n\r\n  private static isClockwise(prev: Location, curr: Location, prevPt: IPoint64, currPt: IPoint64, rectMidPoint: Point64): boolean {\r\n    if (this.areOpposites(prev, curr))\r\n      return InternalClipper.crossProduct(prevPt, rectMidPoint, currPt) < 0;\r\n    else\r\n      return this.headingClockwise(prev, curr);\r\n  }\r\n\r\n  private static areOpposites(prev: Location, curr: Location): boolean {\r\n    return Math.abs(prev - curr) === 2;\r\n  }\r\n\r\n  private static headingClockwise(prev: Location, curr: Location): boolean {\r\n    return (prev + 1) % 4 === curr;\r\n  }\r\n\r\n  private static getAdjacentLocation(loc: Location, isClockwise: boolean): Location {\r\n    const delta = isClockwise ? 1 : 3;\r\n    return (loc + delta) % 4;\r\n  }\r\n\r\n  private static unlinkOp(op: OutPt2 | undefined): OutPt2 | undefined {\r\n    if (op!.next === op) return undefined;\r\n    op!.prev!.next = op!.next;\r\n    op!.next!.prev = op!.prev;\r\n    return op!.next;\r\n  }\r\n\r\n  private static unlinkOpBack(op: OutPt2 | undefined): OutPt2 | undefined {\r\n    if (op!.next === op) return undefined;\r\n    op!.prev!.next = op!.next;\r\n    op!.next!.prev = op!.prev;\r\n    return op!.prev;\r\n  }\r\n\r\n  private static getEdgesForPt(pt: IPoint64, rec: Rect64): number {\r\n    let result = 0;\r\n    if (pt.x === rec.left) result = 1;\r\n    else if (pt.x === rec.right) result = 4;\r\n    if (pt.y === rec.top) result += 2;\r\n    else if (pt.y === rec.bottom) result += 8;\r\n    return result;\r\n  }\r\n\r\n  private static isHeadingClockwise(pt1: IPoint64, pt2: IPoint64, edgeIdx: number): boolean {\r\n    switch (edgeIdx) {\r\n      case 0: return pt2.y < pt1.y;\r\n      case 1: return pt2.x > pt1.x;\r\n      case 2: return pt2.y > pt1.y;\r\n      default: return pt2.x < pt1.x;\r\n    }\r\n  }\r\n\r\n  private static hasHorzOverlap(left1: IPoint64, right1: IPoint64, left2: IPoint64, right2: IPoint64): boolean {\r\n    return (left1.x < right2.x) && (right1.x > left2.x);\r\n  }\r\n\r\n  private static hasVertOverlap(top1: IPoint64, bottom1: IPoint64, top2: IPoint64, bottom2: IPoint64): boolean {\r\n    return (top1.y < bottom2.y) && (bottom1.y > top2.y);\r\n  }\r\n\r\n  private static addToEdge(edge: (OutPt2 | undefined)[], op: OutPt2): void {\r\n    if (op.edge) return;\r\n    op.edge = edge;\r\n    edge.push(op);\r\n  }\r\n\r\n  private static uncoupleEdge(op: OutPt2): void {\r\n    if (!op.edge) return;\r\n    for (let i = 0; i < op.edge.length; i++) {\r\n      const op2 = op.edge[i];\r\n      if (op2 === op) {\r\n        op.edge[i] = undefined;\r\n        break;\r\n      }\r\n    }\r\n    op.edge = undefined;\r\n  }\r\n\r\n  private static setNewOwner(op: OutPt2, newIdx: number): void {\r\n    op.ownerIdx = newIdx;\r\n    let op2 = op.next!;\r\n    while (op2 !== op) {\r\n      op2.ownerIdx = newIdx;\r\n      op2 = op2.next!;\r\n    }\r\n  }\r\n\r\n  private addCorner(prev: Location, curr: Location): void {\r\n    if (RectClip64.headingClockwise(prev, curr))\r\n      this.add(this.rectPath[prev]);\r\n    else\r\n      this.add(this.rectPath[curr]);\r\n  }\r\n\r\n  private addCornerByRef(loc: Location, isClockwise: boolean): void {\r\n    if (isClockwise) {\r\n      this.add(this.rectPath[loc]);\r\n      loc = RectClip64.getAdjacentLocation(loc, true);\r\n    } else {\r\n      loc = RectClip64.getAdjacentLocation(loc, false);\r\n      this.add(this.rectPath[loc]);\r\n    }\r\n  }\r\n\r\n  protected static getLocation(rec: Rect64, pt: IPoint64): { success: boolean, loc: Location } {\r\n    let loc: Location;\r\n\r\n    if (pt.x === rec.left && pt.y >= rec.top && pt.y <= rec.bottom) {\r\n      loc = Location.left; // pt on rec\r\n      return { success: false, loc }\r\n    }\r\n    if (pt.x === rec.right && pt.y >= rec.top && pt.y <= rec.bottom) {\r\n      loc = Location.right; // pt on rec\r\n      return { success: false, loc };\r\n    }\r\n    if (pt.y === rec.top && pt.x >= rec.left && pt.x <= rec.right) {\r\n      loc = Location.top; // pt on rec\r\n      return { success: false, loc };\r\n    }\r\n    if (pt.y === rec.bottom && pt.x >= rec.left && pt.x <= rec.right) {\r\n      loc = Location.bottom; // pt on rec\r\n      return { success: false, loc };\r\n    }\r\n    if (pt.x < rec.left) loc = Location.left;\r\n    else if (pt.x > rec.right) loc = Location.right;\r\n    else if (pt.y < rec.top) loc = Location.top;\r\n    else if (pt.y > rec.bottom) loc = Location.bottom;\r\n    else loc = Location.inside;\r\n\r\n    return { success: true, loc };\r\n  }\r\n\r\n  protected static getIntersection(rectPath: Path64, p: IPoint64, p2: IPoint64, loc: Location): { success: boolean, loc: Location, ip: IPoint64 } {\r\n    // gets the pt of intersection between rectPath and segment(p, p2) that's closest to 'p'\r\n    // when result == false, loc will remain unchanged\r\n    let ip: IPoint64 = new Point64();\r\n    switch (loc) {\r\n      case Location.left:\r\n        if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n        } else if (p.y < rectPath[0].y && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n          loc = Location.top;\r\n        } else if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n          loc = Location.bottom;\r\n        }\r\n        else {\r\n          return { success: false, loc, ip }\r\n        }\r\n        break;\r\n\r\n      case Location.right:\r\n        if (InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n        } else if (p.y < rectPath[0].y && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n          loc = Location.top;\r\n        } else if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n          loc = Location.bottom;\r\n        } else {\r\n          return { success: false, loc, ip }\r\n        }\r\n        break;\r\n      case Location.top:\r\n        if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n        } else if (p.x < rectPath[0].x && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n          loc = Location.left;\r\n        } else if (p.x > rectPath[1].x && InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n          loc = Location.right;\r\n        } else {\r\n          return { success: false, loc, ip }\r\n        }\r\n        break;\r\n\r\n      case Location.bottom:\r\n        if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n        } else if (p.x < rectPath[3].x && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n          loc = Location.left;\r\n        } else if (p.x > rectPath[2].x && InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n          loc = Location.right;\r\n        } else {\r\n          return { success: false, loc, ip }\r\n        }\r\n        break;\r\n\r\n      case Location.inside:\r\n        if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n          loc = Location.left;\r\n        } else if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n          loc = Location.top;\r\n        } else if (InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n          loc = Location.right;\r\n        } else if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n          ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n          loc = Location.bottom;\r\n        } else {\r\n          return { success: false, loc, ip }\r\n        }\r\n        break;\r\n\r\n    }\r\n    return { success:true, loc, ip };\r\n  }\r\n\r\n  protected getNextLocation(path: Path64, context: { loc: Location, i: number, highI: number }): void {\r\n\r\n    switch (context.loc) {\r\n      case Location.left:\r\n        while (context.i <= context.highI && path[context.i].x <= this.rect.left) context.i++;\r\n        if (context.i > context.highI) break;\r\n        if (path[context.i].x >= this.rect.right) context.loc = Location.right;\r\n        else if (path[context.i].y <= this.rect.top) context.loc = Location.top;\r\n        else if (path[context.i].y >= this.rect.bottom) context.loc = Location.bottom;\r\n        else context.loc = Location.inside;\r\n        break;\r\n\r\n      case Location.top:\r\n        while (context.i <= context.highI && path[context.i].y <= this.rect.top) context.i++;\r\n        if (context.i > context.highI) break;\r\n        if (path[context.i].y >= this.rect.bottom) context.loc = Location.bottom;\r\n        else if (path[context.i].x <= this.rect.left) context.loc = Location.left;\r\n        else if (path[context.i].x >= this.rect.right) context.loc = Location.right;\r\n        else context.loc = Location.inside;\r\n        break;\r\n\r\n      case Location.right:\r\n        while (context.i <= context.highI && path[context.i].x >= this.rect.right) context.i++;\r\n        if (context.i > context.highI) break;\r\n        if (path[context.i].x <= this.rect.left) context.loc = Location.left;\r\n        else if (path[context.i].y <= this.rect.top) context.loc = Location.top;\r\n        else if (path[context.i].y >= this.rect.bottom) context.loc = Location.bottom;\r\n        else context.loc = Location.inside;\r\n        break;\r\n\r\n      case Location.bottom:\r\n        while (context.i <= context.highI && path[context.i].y >= this.rect.bottom) context.i++;\r\n        if (context.i > context.highI) break;\r\n        if (path[context.i].y <= this.rect.top) context.loc = Location.top;\r\n        else if (path[context.i].x <= this.rect.left) context.loc = Location.left;\r\n        else if (path[context.i].x >= this.rect.right) context.loc = Location.right;\r\n        else context.loc = Location.inside;\r\n        break;\r\n\r\n      case Location.inside:\r\n        while (context.i <= context.highI) {\r\n          if (path[context.i].x < this.rect.left) context.loc = Location.left;\r\n          else if (path[context.i].x > this.rect.right) context.loc = Location.right;\r\n          else if (path[context.i].y > this.rect.bottom) context.loc = Location.bottom;\r\n          else if (path[context.i].y < this.rect.top) context.loc = Location.top;\r\n          else {\r\n            this.add(path[context.i]);  \r\n            context.i++;\r\n            continue;\r\n          }\r\n          break;\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  protected executeInternal(path: Path64): void {\r\n    if (path.length < 3 || this.rect.isEmpty()) return;\r\n    const startLocs: Location[] = [];\r\n\r\n    let firstCross: Location = Location.inside;\r\n    let crossingLoc: Location = firstCross, prev: Location = firstCross;\r\n\r\n    let i: number\r\n    const highI = path.length - 1;\r\n    let result = RectClip64.getLocation(this.rect, path[highI])\r\n    let loc: Location = result.loc\r\n    if (!result.success) {\r\n      i = highI - 1;\r\n      while (i >= 0 && !result.success) {\r\n        i--\r\n        result = RectClip64.getLocation(this.rect, path[i])\r\n        prev = result.loc\r\n      }\r\n      if (i < 0) {\r\n        for (const pt of path) {\r\n          this.add(pt);\r\n        }\r\n        return;\r\n      }\r\n      if (prev == Location.inside) loc = Location.inside;\r\n    }\r\n    const startingLoc = loc;\r\n\r\n    ///////////////////////////////////////////////////\r\n    i = 0;\r\n    while (i <= highI) {\r\n      prev = loc;\r\n      const prevCrossLoc: Location = crossingLoc;\r\n      this.getNextLocation(path, { loc, i, highI });\r\n      if (i > highI) break;\r\n\r\n      const prevPt = (i == 0) ? path[highI] : path[i - 1];\r\n      crossingLoc = loc;\r\n\r\n      let result = RectClip64.getIntersection(this.rectPath, path[i], prevPt, crossingLoc)\r\n      const ip: IPoint64 = result.ip\r\n\r\n      if (!result.success) {\r\n        if (prevCrossLoc == Location.inside) {\r\n          const isClockw = RectClip64.isClockwise(prev, loc, prevPt, path[i], this.mp); \r\n          do {\r\n            startLocs.push(prev);\r\n            prev = RectClip64.getAdjacentLocation(prev, isClockw);\r\n          } while (prev != loc);\r\n          crossingLoc = prevCrossLoc;\r\n        } else if (prev != Location.inside && prev != loc) {\r\n          const isClockw = RectClip64.isClockwise(prev, loc, prevPt, path[i], this.mp);\r\n          do {\r\n            this.addCornerByRef(prev, isClockw);\r\n          } while (prev != loc);\r\n        }\r\n        ++i;\r\n        continue;\r\n      }\r\n\r\n      ////////////////////////////////////////////////////\r\n      // we must be crossing the rect boundary to get here\r\n      ////////////////////////////////////////////////////\r\n      if (loc == Location.inside) {\r\n        if (firstCross == Location.inside) {\r\n          firstCross = crossingLoc;\r\n          startLocs.push(prev);\r\n        } else if (prev != crossingLoc) {\r\n          const isClockw = RectClip64.isClockwise(prev, crossingLoc, prevPt, path[i], this.mp);\r\n          do {\r\n            this.addCornerByRef(prev, isClockw);\r\n          } while (prev != crossingLoc);\r\n        }\r\n      } else if (prev != Location.inside) {\r\n        // passing right through rect. 'ip' here will be the second\r\n        // intersect pt but we'll also need the first intersect pt (ip2)\r\n\r\n        loc = prev;\r\n        result = RectClip64.getIntersection(this.rectPath, prevPt, path[i], loc);\r\n        const ip2: IPoint64 = result.ip\r\n\r\n        if (prevCrossLoc != Location.inside && prevCrossLoc != loc)\r\n          this.addCorner(prevCrossLoc, loc);\r\n\r\n        if (firstCross == Location.inside) {\r\n          firstCross = loc;\r\n          startLocs.push(prev);\r\n        }\r\n\r\n        loc = crossingLoc;\r\n        this.add(ip2);\r\n        if (ip == ip2) {\r\n          loc = RectClip64.getLocation(this.rect, path[i]).loc;\r\n          this.addCorner(crossingLoc, loc);\r\n          crossingLoc = loc;\r\n          continue;\r\n        }\r\n      } else {\r\n        loc = crossingLoc;\r\n        if (firstCross == Location.inside)\r\n          firstCross = crossingLoc;\r\n      }\r\n\r\n      this.add(ip);\r\n    }//while i <= highI\r\n    ///////////////////////////////////////////////////\r\n\r\n    if (firstCross == Location.inside) {\r\n      if (startingLoc != Location.inside) {\r\n        if (this.pathBounds.containsRect(this.rect) && RectClip64.path1ContainsPath2(path, this.rectPath)) {\r\n          for (let j = 0; j < 4; j++) {\r\n            this.add(this.rectPath[j]);\r\n            RectClip64.addToEdge(this.edges[j * 2], this.results[0]!);\r\n          }\r\n        }\r\n      }\r\n    } else if (loc != Location.inside && (loc != firstCross || startLocs.length > 2)) {\r\n      if (startLocs.length > 0) {\r\n        prev = loc;\r\n        for (const loc2 of startLocs) {\r\n          if (prev == loc2) continue;\r\n          this.addCornerByRef(prev, RectClip64.headingClockwise(prev, loc2));\r\n          prev = loc2;\r\n        }\r\n        loc = prev;\r\n      }\r\n      if (loc != firstCross)\r\n        this.addCornerByRef(loc, RectClip64.headingClockwise(loc, firstCross));\r\n    }\r\n  }\r\n\r\n  public execute(paths: Paths64): Paths64 { \r\n    const result: Paths64 = []; \r\n    if (this.rect.isEmpty()) return result;\r\n\r\n    for (const path of paths) {\r\n      if (path.length < 3) continue;\r\n      this.pathBounds = Clipper.getBounds(path);\r\n\r\n      if (!this.rect.intersects(this.pathBounds)) continue;\r\n      else if (this.rect.containsRect(this.pathBounds)) {\r\n        result.push(path);\r\n        continue;\r\n      }\r\n      this.executeInternal(path);\r\n      this.checkEdges();\r\n      for (let i = 0; i < 4; ++i)\r\n        this.tidyEdgePair(i, this.edges[i * 2], this.edges[i * 2 + 1]);\r\n\r\n      for (const op of this.results) {\r\n        const tmp = this.getPath(op); \r\n        if (tmp.length > 0) result.push(tmp);\r\n      }\r\n\r\n      this.results.length = 0\r\n      for (let i = 0; i < 8; i++)\r\n        this.edges[i].length = 0\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private checkEdges(): void {\r\n    for (let i = 0; i < this.results.length; i++) {\r\n      let op = this.results[i];\r\n      let op2 = op;\r\n\r\n      if (op === undefined) continue;\r\n\r\n      do {\r\n        if (InternalClipper.crossProduct(op2!.prev!.pt, op2!.pt, op2!.next!.pt) === 0) { \r\n          if (op2 === op) {\r\n            op2 = RectClip64.unlinkOpBack(op2);\r\n            if (op2 === undefined) break;\r\n            op = op2.prev;\r\n          } else {\r\n            op2 = RectClip64.unlinkOpBack(op2);\r\n            if (op2 === undefined) break;\r\n          }\r\n        } else {\r\n          op2 = op2!.next;\r\n        }\r\n      } while (op2 !== op);\r\n\r\n      if (op2 === undefined) {\r\n        this.results[i] = undefined;\r\n        continue;\r\n      }\r\n      this.results[i] = op2;\r\n\r\n      let edgeSet1 = RectClip64.getEdgesForPt(op!.prev!.pt, this.rect);\r\n      op2 = op;\r\n      do {\r\n        const edgeSet2 = RectClip64.getEdgesForPt(op2!.pt, this.rect);\r\n        if (edgeSet2 !== 0 && op2!.edge === undefined) {\r\n          const combinedSet = (edgeSet1 & edgeSet2);\r\n          for (let j = 0; j < 4; ++j) {\r\n            if ((combinedSet & (1 << j)) !== 0) {\r\n              if (RectClip64.isHeadingClockwise(op2!.prev!.pt, op2!.pt, j))\r\n                RectClip64.addToEdge(this.edges[j * 2], op2!);\r\n              else\r\n                RectClip64.addToEdge(this.edges[j * 2 + 1], op2!);\r\n            }\r\n          }\r\n        }\r\n        edgeSet1 = edgeSet2;\r\n        op2 = op2!.next;\r\n      } while (op2 !== op);\r\n    }\r\n  }\r\n\r\n  private tidyEdgePair(idx: number, cw: Array<OutPt2 | undefined>, ccw: Array<OutPt2 | undefined>): void {\r\n    if (ccw.length === 0) return;\r\n    const isHorz = (idx === 1 || idx === 3);\r\n    const cwIsTowardLarger = (idx === 1 || idx === 2);\r\n    let i = 0, j = 0;\r\n    let p1: OutPt2 | undefined, p2: OutPt2 | undefined, p1a: OutPt2 | undefined, p2a: OutPt2 | undefined, op: OutPt2 | undefined, op2: OutPt2 | undefined;\r\n\r\n    while (i < cw.length) {\r\n      p1 = cw[i];\r\n      if (!p1 || p1.next === p1.prev) {\r\n        cw[i++] = undefined;\r\n        j = 0;\r\n        continue;\r\n      }\r\n\r\n      const jLim = ccw.length;\r\n      while (j < jLim && (!ccw[j] || ccw[j]!.next === ccw[j]!.prev)) ++j;\r\n\r\n      if (j === jLim) {\r\n        ++i;\r\n        j = 0;\r\n        continue;\r\n      }\r\n\r\n      if (cwIsTowardLarger) {\r\n        p1 = cw[i]!.prev!;\r\n        p1a = cw[i];\r\n        p2 = ccw[j];\r\n        p2a = ccw[j]!.prev!;\r\n      } else {\r\n        p1 = cw[i];\r\n        p1a = cw[i]!.prev!;\r\n        p2 = ccw[j]!.prev!;\r\n        p2a = ccw[j];\r\n      }\r\n\r\n      if ((isHorz && !RectClip64.hasHorzOverlap(p1!.pt, p1a!.pt, p2!.pt, p2a!.pt)) ||\r\n        (!isHorz && !RectClip64.hasVertOverlap(p1!.pt, p1a!.pt, p2!.pt, p2a!.pt))) {\r\n        ++j;\r\n        continue;\r\n      }\r\n\r\n      const isRejoining = cw[i]!.ownerIdx !== ccw[j]!.ownerIdx;\r\n\r\n      if (isRejoining) {\r\n        this.results[p2!.ownerIdx] = undefined;\r\n        RectClip64.setNewOwner(p2!, p1!.ownerIdx);\r\n      }\r\n\r\n      if (cwIsTowardLarger) {\r\n        // p1 >> | >> p1a;\r\n        // p2 << | << p2a;\r\n        p1!.next = p2;\r\n        p2!.prev = p1;\r\n        p1a!.prev = p2a;\r\n        p2a!.next = p1a;\r\n      } else {\r\n        // p1 << | << p1a;\r\n        // p2 >> | >> p2a;\r\n        p1!.prev = p2;\r\n        p2!.next = p1;\r\n        p1a!.next = p2a;\r\n        p2a!.prev = p1a;\r\n      }\r\n\r\n      if (!isRejoining) {\r\n        const new_idx = this.results.length;\r\n        this.results.push(p1a);\r\n        RectClip64.setNewOwner(p1a!, new_idx);\r\n      }\r\n\r\n      if (cwIsTowardLarger) {\r\n        op = p2;\r\n        op2 = p1a;\r\n      } else {\r\n        op = p1;\r\n        op2 = p2a;\r\n      }\r\n      this.results[op!.ownerIdx] = op;\r\n      this.results[op2!.ownerIdx] = op2;\r\n\r\n      // and now lots of work to get ready for the next loop\r\n\r\n      let opIsLarger: boolean, op2IsLarger: boolean;\r\n      if (isHorz) { // X\r\n        opIsLarger = op!.pt.x > op!.prev!.pt.x;\r\n        op2IsLarger = op2!.pt.x > op2!.prev!.pt.x;\r\n      } else {      // Y\r\n        opIsLarger = op!.pt.y > op!.prev!.pt.y;\r\n        op2IsLarger = op2!.pt.y > op2!.prev!.pt.y;\r\n      }\r\n\r\n      if ((op!.next === op!.prev) || (op!.pt === op!.prev!.pt)) {\r\n        if (op2IsLarger === cwIsTowardLarger) {\r\n          cw[i] = op2;\r\n          ccw[j++] = undefined;\r\n        } else {\r\n          ccw[j] = op2;\r\n          cw[i++] = undefined;\r\n        }\r\n      } else if ((op2!.next === op2!.prev) || (op2!.pt === op2!.prev!.pt)) {\r\n        if (opIsLarger === cwIsTowardLarger) {\r\n          cw[i] = op;\r\n          ccw[j++] = undefined;\r\n        } else {\r\n          ccw[j] = op;\r\n          cw[i++] = undefined;\r\n        }\r\n      } else if (opIsLarger === op2IsLarger) {\r\n        if (opIsLarger === cwIsTowardLarger) {\r\n          cw[i] = op;\r\n          RectClip64.uncoupleEdge(op2!);\r\n          RectClip64.addToEdge(cw, op2!);\r\n          ccw[j++] = undefined;\r\n        } else {\r\n          cw[i++] = undefined;\r\n          ccw[j] = op2;\r\n          RectClip64.uncoupleEdge(op!);\r\n          RectClip64.addToEdge(ccw, op!);\r\n          j = 0;\r\n        }\r\n      } else {\r\n        if (opIsLarger === cwIsTowardLarger)\r\n          cw[i] = op;\r\n        else\r\n          ccw[j] = op;\r\n\r\n        if (op2IsLarger === cwIsTowardLarger)\r\n          cw[i] = op2;\r\n        else\r\n          ccw[j] = op2;\r\n      }\r\n    }\r\n  }\r\n\r\n  protected getPath(op: OutPt2 | undefined): Path64 {\r\n    const result = new Path64();\r\n    if (!op || op.prev === op.next) return result;\r\n\r\n    let op2: OutPt2 | undefined = op.next;\r\n    while (op2 && op2 !== op) {\r\n      if (InternalClipper.crossProduct(op2.prev!.pt, op2.pt, op2.next!.pt) === 0) {\r\n        op = op2.prev!;\r\n        op2 = RectClip64.unlinkOp(op2);\r\n      } else {\r\n        op2 = op2.next!;\r\n      }\r\n    }\r\n\r\n    if (!op2) return new Path64();\r\n\r\n    result.push(op.pt);\r\n    op2 = op.next!;\r\n    while (op2 !== op) {\r\n      result.push(op2.pt);\r\n      op2 = op2.next!;\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nexport class RectClipLines64 extends RectClip64 {\r\n\r\n  constructor(rect: Rect64) {\r\n    super(rect);\r\n  }\r\n\r\n  public override execute(paths: Paths64): Paths64 {\r\n    const result = new Paths64();\r\n    if (this.rect.isEmpty()) return result; \r\n    for (const path of paths) {\r\n      if (path.length < 2) continue;\r\n      this.pathBounds = Clipper.getBounds(path);\r\n      if (!this.rect.intersects(this.pathBounds)) continue; \r\n\r\n      this.executeInternal(path);\r\n\r\n      for (const op of this.results) {\r\n        const tmp = this.getPath(op);\r\n        if (tmp.length > 0) result.push(tmp);\r\n      }\r\n\r\n      // Clean up after every loop\r\n      this.results.length = 0; // Clear the array\r\n      for (let i = 0; i < 8; i++) {\r\n        this.edges[i].length = 0; // Clear each array\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  protected override getPath(op: OutPt2 | undefined): Path64 {\r\n    const result = new Path64();\r\n    if (!op || op === op.next) return result;\r\n    op = op.next; // starting at path beginning \r\n    result.push(op!.pt);\r\n    let op2 = op!.next!;\r\n    while (op2 !== op) {\r\n      result.push(op2.pt);\r\n      op2 = op2.next!;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  protected override  executeInternal(path: Path64): void {\r\n    this.results = [];\r\n    if (path.length < 2 || this.rect.isEmpty()) return; \r\n\r\n    let prev: Location = Location.inside;\r\n    let i = 1;\r\n    const highI = path.length - 1;\r\n\r\n    let result = RectClipLines64.getLocation(this.rect, path[0])\r\n    let loc: Location = result.loc\r\n    if (!result.success) {\r\n      while (i <= highI && !result.success) {\r\n        i++\r\n        result = RectClipLines64.getLocation(this.rect, path[i])\r\n        prev = result.loc\r\n      }\r\n      if (i > highI) {\r\n        for (const pt of path) this.add(pt);\r\n      }\r\n      if (prev == Location.inside) loc = Location.inside;\r\n      i = 1;\r\n    }\r\n    if (loc == Location.inside) this.add(path[0]);\r\n\r\n    while (i <= highI) {\r\n      prev = loc;\r\n      this.getNextLocation(path, { loc, i, highI });\r\n\r\n      if (i > highI) break;\r\n\r\n      const prevPt: IPoint64 = path[i - 1];\r\n      let crossingLoc: Location = loc;\r\n\r\n      let result = RectClipLines64.getIntersection(this.rectPath, path[i], prevPt, crossingLoc)\r\n      const ip: IPoint64 = result.ip\r\n      crossingLoc = result.loc\r\n\r\n      if (!result.success) {\r\n        i++;\r\n        continue;\r\n      }\r\n\r\n      if (loc == Location.inside) {\r\n        this.add(ip, true);\r\n      } else if (prev !== Location.inside) {\r\n        crossingLoc = prev;\r\n\r\n        result = RectClipLines64.getIntersection(this.rectPath, prevPt, path[i], crossingLoc);\r\n        const ip2: IPoint64 = result.ip\r\n        crossingLoc = result.loc\r\n\r\n        this.add(ip2);\r\n        this.add(ip);\r\n      } else {\r\n        this.add(ip);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  16 July 2023                                                    *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  This module contains simple functions that will likely cover    *\r\n*              most polygon boolean and offsetting needs, while also avoiding  *\r\n*              the inherent complexities of the other modules.                 *\r\n* Thanks    :  Special thanks to Thong Nguyen, Guus Kuiper, Phil Stopford,     *\r\n*           :  and Daniel Gosnell for their invaluable assistance with C#.     *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\n\r\nimport { ClipType, FillRule, IPoint64, InternalClipper, Path64, PathType, Paths64, Point64, Rect64 } from \"./core\";\r\nimport { Clipper64, PointInPolygonResult, PolyPath64, PolyPathBase, PolyTree64 } from \"./engine\";\r\nimport { Minkowski } from \"./minkowski\";\r\nimport { ClipperOffset, EndType, JoinType } from \"./offset\";\r\nimport { RectClip64, RectClipLines64 } from \"./rectclip\";\r\n\r\nexport class Clipper {\r\n\r\n  private static invalidRect64: Rect64\r\n  public static get InvalidRect64(): Rect64 {\r\n    if (!Clipper.invalidRect64) Clipper.invalidRect64 = new Rect64(false);\r\n    return this.invalidRect64;\r\n  }\r\n\r\n  public static Intersect(subject: Paths64, clip: Paths64, fillRule: FillRule): Paths64 {\r\n    return this.BooleanOp(ClipType.Intersection, subject, clip, fillRule);\r\n  }\r\n\r\n  public static Union(subject: Paths64, clip?: Paths64, fillRule = FillRule.EvenOdd): Paths64 {\r\n    return this.BooleanOp(ClipType.Union, subject, clip, fillRule);\r\n  }\r\n\r\n  public static Difference(subject: Paths64, clip: Paths64, fillRule: FillRule): Paths64 {\r\n    return this.BooleanOp(ClipType.Difference, subject, clip, fillRule);\r\n  }\r\n\r\n  public static Xor(subject: Paths64, clip: Paths64, fillRule: FillRule): Paths64 {\r\n    return this.BooleanOp(ClipType.Xor, subject, clip, fillRule);\r\n  }\r\n\r\n  public static BooleanOp(clipType: ClipType, subject?: Paths64, clip?: Paths64, fillRule = FillRule.EvenOdd): Paths64 {\r\n    const solution: Paths64 = new Paths64();\r\n    if (!subject) return solution;\r\n    const c: Clipper64 = new Clipper64();\r\n    c.addPaths(subject, PathType.Subject);\r\n    if (clip)\r\n      c.addPaths(clip, PathType.Clip);\r\n    c.execute(clipType, fillRule, solution);\r\n    return solution;\r\n  }\r\n\r\n  //public static BooleanOp(clipType: ClipType, subject: Paths64, clip: Paths64, polytree: PolyTree64, fillRule: FillRule): void {\r\n  //  if (!subject) return;\r\n  //  const c: Clipper64 = new Clipper64();\r\n  //  c.addPaths(subject, PathType.Subject);\r\n  //  if (clip)\r\n  //    c.addPaths(clip, PathType.Clip);\r\n  //  c.execute(clipType, fillRule, polytree);\r\n  //}\r\n\r\n  public static InflatePaths(paths: Paths64, delta: number, joinType: JoinType, endType: EndType, miterLimit: number = 2.0): Paths64 {\r\n    const co: ClipperOffset = new ClipperOffset(miterLimit);\r\n    co.addPaths(paths, joinType, endType);\r\n    const solution: Paths64 = new Paths64();\r\n    co.execute(delta, solution);\r\n    return solution;\r\n  }\r\n\r\n  public static RectClipPaths(rect: Rect64, paths: Paths64): Paths64 {\r\n    if (rect.isEmpty() || paths.length === 0) return new Paths64();\r\n    const rc = new RectClip64(rect);\r\n    return rc.execute(paths);\r\n  }\r\n\r\n  public static RectClip(rect: Rect64, path: Path64): Paths64 {\r\n    if (rect.isEmpty() || path.length === 0) return new Paths64();\r\n    const tmp: Paths64 = new Paths64();\r\n    tmp.push(path);\r\n    return this.RectClipPaths(rect, tmp);\r\n  }\r\n\r\n  public static RectClipLinesPaths(rect: Rect64, paths: Paths64): Paths64 {\r\n    if (rect.isEmpty() || paths.length === 0) return new Paths64();\r\n    const rc = new RectClipLines64(rect);\r\n    return rc.execute(paths);\r\n  }\r\n\r\n  public static RectClipLines(rect: Rect64, path: Path64): Paths64 {\r\n    if (rect.isEmpty() || path.length === 0) return new Paths64();\r\n    const tmp: Paths64 = new Paths64();\r\n    tmp.push(path);\r\n    return this.RectClipLinesPaths(rect, tmp);\r\n  }\r\n\r\n  public static MinkowskiSum(pattern: Path64, path: Path64, isClosed: boolean): Paths64 {\r\n    return Minkowski.sum(pattern, path, isClosed);\r\n  }\r\n\r\n  public static MinkowskiDiff(pattern: Path64, path: Path64, isClosed: boolean): Paths64 {\r\n    return Minkowski.diff(pattern, path, isClosed);\r\n  }\r\n\r\n  public static area(path: Path64): number {\r\n    // https://en.wikipedia.org/wiki/Shoelace_formula\r\n    let a = 0.0;\r\n    const cnt = path.length;\r\n    if (cnt < 3) return 0.0;\r\n    let prevPt = path[cnt - 1];\r\n    for (const pt of path) {\r\n      a += (prevPt.y + pt.y) * (prevPt.x - pt.x);\r\n      prevPt = pt;\r\n    }\r\n    return a * 0.5;\r\n  }\r\n\r\n  public static areaPaths(paths: Paths64): number {\r\n    let a = 0.0;\r\n    for (const path of paths)\r\n      a += this.area(path);\r\n    return a;\r\n  }\r\n\r\n  public static isPositive(poly: Path64): boolean {\r\n    return this.area(poly) >= 0;\r\n  }\r\n\r\n  public static path64ToString(path: Path64): string {\r\n    let result = \"\";\r\n    for (const pt of path)\r\n      result += pt.toString();\r\n    return result + '\\n';\r\n  }\r\n\r\n  public static paths64ToString(paths: Paths64): string {\r\n    let result = \"\";\r\n    for (const path of paths)\r\n      result += this.path64ToString(path);\r\n    return result;\r\n  }\r\n\r\n  public static offsetPath(path: Path64, dx: number, dy: number): Path64 {\r\n    const result = new Path64();\r\n    for (const pt of path)\r\n      result.push(new Point64(pt.x + dx, pt.y + dy));\r\n    return result;\r\n  }\r\n\r\n  public static scalePoint64(pt: Point64, scale: number): Point64 {\r\n    const result = new Point64(\r\n      Math.round(pt.x * scale),\r\n      Math.round(pt.y * scale)\r\n    )\r\n    return result;\r\n  }\r\n\r\n  public static scalePath(path: Path64, scale: number): Path64 {\r\n    if (InternalClipper.isAlmostZero(scale - 1)) return path;\r\n    const result: Path64 = [];\r\n    for (const pt of path)\r\n      result.push({ x: pt.x * scale, y: pt.y * scale });\r\n    return result;\r\n  }\r\n\r\n  public static scalePaths(paths: Paths64, scale: number): Paths64 {\r\n    if (InternalClipper.isAlmostZero(scale - 1)) return paths;\r\n    const result: Paths64 = [];\r\n    for (const path of paths)\r\n      result.push(this.scalePath(path, scale));\r\n    return result;\r\n  }\r\n\r\n  public static translatePath(path: Path64, dx: number, dy: number): Path64 {\r\n    const result: Path64 = [];\r\n    for (const pt of path) {\r\n      result.push({ x: pt.x + dx, y: pt.y + dy });\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public static translatePaths(paths: Paths64, dx: number, dy: number): Paths64 {\r\n    const result: Paths64 = [];\r\n    for (const path of paths) {\r\n      result.push(this.translatePath(path, dx, dy));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public static reversePath(path: Path64): Path64 {\r\n    return [...path].reverse();\r\n  }\r\n\r\n  public static reversePaths(paths: Paths64): Paths64 {\r\n    const result: Paths64 = [];\r\n    for (const t of paths) {\r\n      result.push(this.reversePath(t));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public static getBounds(path: Path64): Rect64 {\r\n    const result: Rect64 = Clipper.InvalidRect64;\r\n    for (const pt of path) {\r\n      if (pt.x < result.left) result.left = pt.x;\r\n      if (pt.x > result.right) result.right = pt.x;\r\n      if (pt.y < result.top) result.top = pt.y;\r\n      if (pt.y > result.bottom) result.bottom = pt.y;\r\n    }\r\n    return result.left === Number.MAX_SAFE_INTEGER ? new Rect64(0, 0, 0, 0) : result;\r\n  }\r\n\r\n  public static getBoundsPaths(paths: Paths64): Rect64 {\r\n    const result: Rect64 = Clipper.InvalidRect64;\r\n    for (const path of paths) {\r\n      for (const pt of path) {\r\n        if (pt.x < result.left) result.left = pt.x;\r\n        if (pt.x > result.right) result.right = pt.x;\r\n        if (pt.y < result.top) result.top = pt.y;\r\n        if (pt.y > result.bottom) result.bottom = pt.y;\r\n      }\r\n    }\r\n    return result.left === Number.MAX_SAFE_INTEGER ? new Rect64(0, 0, 0, 0) : result;\r\n  }\r\n\r\n  static makePath(arr: number[]): Path64 {\r\n    const len = arr.length / 2;\r\n    const p = new Path64();\r\n    for (let i = 0; i < len; i++)\r\n      p.push(new Point64(arr[i * 2], arr[i * 2 + 1]));\r\n    return p;\r\n  }\r\n\r\n  static stripDuplicates(path: Path64, isClosedPath: boolean): Path64 {\r\n    const cnt = path.length;\r\n    const result = new Path64();\r\n    if (cnt === 0) return result;\r\n    let lastPt = path[0];\r\n    result.push(lastPt);\r\n    for (let i = 1; i < cnt; i++)\r\n      if (lastPt !== path[i]) {\r\n        lastPt = path[i];\r\n        result.push(lastPt);\r\n      }\r\n    if (isClosedPath && lastPt === result[0])\r\n      result.pop();\r\n    return result;\r\n  }\r\n\r\n  private static addPolyNodeToPaths(polyPath: PolyPathBase, paths: Paths64): void {\r\n    if (polyPath.polygon && polyPath.polygon.length > 0)\r\n      paths.push(polyPath.polygon);\r\n    for (let i = 0; i < polyPath.count; i++)\r\n      this.addPolyNodeToPaths(polyPath.children[i], paths);\r\n  }\r\n\r\n  public static polyTreeToPaths64(polyTree: PolyTree64): Paths64 {\r\n    const result: Paths64 = new Paths64();\r\n    for (let i = 0; i < polyTree.count; i++) {\r\n      Clipper.addPolyNodeToPaths(polyTree.children[i] as PolyPath64, result);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public static perpendicDistFromLineSqrd(pt: IPoint64, line1: IPoint64, line2: IPoint64): number {\r\n    const a = pt.x - line1.x;\r\n    const b = pt.y - line1.y;\r\n    const c = line2.x - line1.x;\r\n    const d = line2.y - line1.y;\r\n    if (c === 0 && d === 0) return 0;\r\n    return Clipper.sqr(a * d - c * b) / (c * c + d * d);\r\n  }\r\n\r\n  static rdp(path: Path64, begin: number, end: number, epsSqrd: number, flags: boolean[]): void {\r\n    let idx = 0;\r\n    let max_d = 0;\r\n\r\n    while (end > begin && path[begin] === path[end]) {\r\n      flags[end--] = false;\r\n    }\r\n    for (let i = begin + 1; i < end; i++) {\r\n      const d = Clipper.perpendicDistFromLineSqrd(path[i], path[begin], path[end]);\r\n      if (d <= max_d) continue;\r\n      max_d = d;\r\n      idx = i;\r\n    }\r\n\r\n    if (max_d <= epsSqrd) return;\r\n\r\n    flags[idx] = true;\r\n    if (idx > begin + 1) Clipper.rdp(path, begin, idx, epsSqrd, flags);\r\n    if (idx < end - 1) Clipper.rdp(path, idx, end, epsSqrd, flags);\r\n  }\r\n\r\n  public static ramerDouglasPeucker(path: Path64, epsilon: number): Path64 {\r\n    const len = path.length;\r\n    if (len < 5) return path;\r\n\r\n    const flags = new Array<boolean>(len).fill(false);\r\n    flags[0] = true;\r\n    flags[len - 1] = true;\r\n    Clipper.rdp(path, 0, len - 1, Clipper.sqr(epsilon), flags);\r\n\r\n    const result: Path64 = [];\r\n    for (let i = 0; i < len; i++) {\r\n      if (flags[i]) result.push(path[i]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public static ramerDouglasPeuckerPaths(paths: Paths64, epsilon: number): Paths64 {\r\n    const result: Paths64 = [];\r\n    for (const path of paths) {\r\n      result.push(Clipper.ramerDouglasPeucker(path, epsilon));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private static getNext(current: number, high: number, flags: boolean[]): number {\r\n    current++;\r\n    while (current <= high && flags[current]) current++;\r\n    if (current <= high) return current;\r\n    current = 0;\r\n    while (flags[current]) current++;\r\n    return current;\r\n  }\r\n\r\n  private static getPrior(current: number, high: number, flags: boolean[]): number {\r\n    if (current === 0) current = high;\r\n    else current--;\r\n    while (current > 0 && flags[current]) current--;\r\n    if (!flags[current]) return current;\r\n    current = high;\r\n    while (flags[current]) current--;\r\n    return current;\r\n  }\r\n\r\n  private static sqr(value: number): number {\r\n    return value * value;\r\n  }\r\n\r\n  public static simplifyPath(path: Path64, epsilon: number, isClosedPath: boolean = false): Path64 {\r\n    const len = path.length;\r\n    const high = len - 1;\r\n    const epsSqr = this.sqr(epsilon);\r\n    if (len < 4) return path;\r\n\r\n    const flags: boolean[] = new Array<boolean>(len).fill(false);\r\n    const dsq: number[] = new Array<number>(len).fill(0);\r\n    let prev = high;\r\n    let curr = 0;\r\n    let start: number, next: number, prior2: number, next2: number;\r\n\r\n    if (isClosedPath) {\r\n      dsq[0] = this.perpendicDistFromLineSqrd(path[0], path[high], path[1]);\r\n      dsq[high] = this.perpendicDistFromLineSqrd(path[high], path[0], path[high - 1]);\r\n    } else {\r\n      dsq[0] = Number.MAX_VALUE;\r\n      dsq[high] = Number.MAX_VALUE;\r\n    }\r\n\r\n    for (let i = 1; i < high; i++) {\r\n      dsq[i] = this.perpendicDistFromLineSqrd(path[i], path[i - 1], path[i + 1]);\r\n    }\r\n\r\n    for (; ;) {\r\n      if (dsq[curr] > epsSqr) {\r\n        start = curr;\r\n        do {\r\n          curr = this.getNext(curr, high, flags);\r\n        } while (curr !== start && dsq[curr] > epsSqr);\r\n        if (curr === start) break;\r\n      }\r\n\r\n      prev = this.getPrior(curr, high, flags);\r\n      next = this.getNext(curr, high, flags);\r\n      if (next === prev) break;\r\n\r\n      if (dsq[next] < dsq[curr]) {\r\n        flags[next] = true;\r\n        next = this.getNext(next, high, flags);\r\n        next2 = this.getNext(next, high, flags);\r\n        dsq[curr] = this.perpendicDistFromLineSqrd(path[curr], path[prev], path[next]);\r\n        if (next !== high || isClosedPath) {\r\n          dsq[next] = this.perpendicDistFromLineSqrd(path[next], path[curr], path[next2]);\r\n        }\r\n        curr = next;\r\n      } else {\r\n        flags[curr] = true;\r\n        curr = next;\r\n        next = this.getNext(next, high, flags);\r\n        prior2 = this.getPrior(prev, high, flags);\r\n        dsq[curr] = this.perpendicDistFromLineSqrd(path[curr], path[prev], path[next]);\r\n        if (prev !== 0 || isClosedPath) {\r\n          dsq[prev] = this.perpendicDistFromLineSqrd(path[prev], path[prior2], path[curr]);\r\n        }\r\n      }\r\n    }\r\n\r\n    const result: Path64 = [];\r\n    for (let i = 0; i < len; i++) {\r\n      if (!flags[i]) result.push(path[i]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public static simplifyPaths(paths: Paths64, epsilon: number, isClosedPaths: boolean = false): Paths64 {\r\n    const result: Paths64 = [];\r\n    for (const path of paths) {\r\n      result.push(this.simplifyPath(path, epsilon, isClosedPaths));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  //private static getNext(current: number, high: number, flags: boolean[]): number {\r\n  //  current++;\r\n  //  while (current <= high && flags[current]) current++;\r\n  //  return current;\r\n  //}\r\n\r\n  //private static getPrior(current: number, high: number, flags: boolean[]): number {\r\n  //  if (current === 0) return high;\r\n  //  current--;\r\n  //  while (current > 0 && flags[current]) current--;\r\n  //  return current;\r\n  //}\r\n\r\n\r\n  public static trimCollinear(path: Path64, isOpen: boolean = false): Path64 {\r\n    let len = path.length;\r\n    let i = 0;\r\n\r\n    if (!isOpen) {\r\n      while (i < len - 1 && InternalClipper.crossProduct(path[len - 1], path[i], path[i + 1]) === 0) i++;\r\n      while (i < len - 1 && InternalClipper.crossProduct(path[len - 2], path[len - 1], path[i]) === 0) len--;\r\n    }\r\n\r\n    if (len - i < 3) {\r\n      if (!isOpen || len < 2 || path[0] === path[1]) {\r\n        return [];\r\n      }\r\n      return path;\r\n    }\r\n\r\n    const result: Path64 = [];\r\n    let last = path[i];\r\n    result.push(last);\r\n\r\n    for (i++; i < len - 1; i++) {\r\n      if (InternalClipper.crossProduct(last, path[i], path[i + 1]) === 0) continue;\r\n      last = path[i];\r\n      result.push(last);\r\n    }\r\n\r\n    if (isOpen) {\r\n      result.push(path[len - 1]);\r\n    } else if (InternalClipper.crossProduct(last, path[len - 1], result[0]) !== 0) {\r\n      result.push(path[len - 1]);\r\n    } else {\r\n      while (result.length > 2 && InternalClipper.crossProduct(result[result.length - 1], result[result.length - 2], result[0]) === 0) {\r\n        result.pop();\r\n      }\r\n      if (result.length < 3) result.splice(0, result.length);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  public static pointInPolygon(pt: Point64, polygon: Path64): PointInPolygonResult {\r\n    return InternalClipper.pointInPolygon(pt, polygon);\r\n  }\r\n\r\n  public static ellipse(center: IPoint64, radiusX: number, radiusY: number = 0, steps: number = 0): Path64 {\r\n    if (radiusX <= 0) return [];\r\n    if (radiusY <= 0) radiusY = radiusX;\r\n    if (steps <= 2) steps = Math.ceil(Math.PI * Math.sqrt((radiusX + radiusY) / 2));\r\n\r\n    const si = Math.sin(2 * Math.PI / steps);\r\n    const co = Math.cos(2 * Math.PI / steps);\r\n    let dx = co, dy = si;\r\n    const result: Path64 = [{ x: center.x + radiusX, y: center.y }];\r\n    for (let i = 1; i < steps; ++i) {\r\n      result.push({ x: center.x + radiusX * dx, y: center.y + radiusY * dy });\r\n      const x = dx * co - dy * si;\r\n      dy = dy * co + dx * si;\r\n      dx = x;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private static showPolyPathStructure(pp: PolyPathBase, level: number): void {\r\n    const spaces = ' '.repeat(level * 2);\r\n    const caption = pp.isHole ? \"Hole \" : \"Outer \";\r\n    if (pp.count === 0) {\r\n      console.log(spaces + caption);\r\n    } else {\r\n      console.log(spaces + caption + `(${pp.count})`);\r\n      pp.forEach(child => this.showPolyPathStructure(child, level + 1));\r\n    }\r\n  }\r\n\r\n  public static showPolyTreeStructure(polytree: PolyTree64): void {\r\n    console.log(\"Polytree Root\");\r\n    polytree.forEach(child => this.showPolyPathStructure(child, 1));\r\n  }\r\n\r\n}\r\n","/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  27 August 2023                                                  *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  This is the main polygon clipping module                        *\r\n* Thanks    :  Special thanks to Thong Nguyen, Guus Kuiper, Phil Stopford,     *\r\n*           :  and Daniel Gosnell for their invaluable assistance with C#.     *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n\r\nimport { Clipper } from \"./clipper\";\r\nimport { ClipType, FillRule, IPoint64, InternalClipper, Path64, PathType, Paths64, Point64, Rect64 } from \"./core\";\r\n\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Engine.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\n\r\nexport enum PointInPolygonResult {\r\n  IsOn = 0,\r\n  IsInside = 1,\r\n  IsOutside = 2\r\n}\r\n\r\nexport enum VertexFlags {\r\n  None = 0,\r\n  OpenStart = 1,\r\n  OpenEnd = 2,\r\n  LocalMax = 4,\r\n  LocalMin = 8\r\n}\r\n\r\nclass Vertex {\r\n  readonly pt: IPoint64;\r\n  next: Vertex | undefined;\r\n  prev: Vertex | undefined;\r\n  flags: VertexFlags;\r\n\r\n  constructor(pt: IPoint64, flags: VertexFlags, prev: Vertex | undefined) {\r\n    this.pt = pt;\r\n    this.flags = flags;\r\n    this.next = undefined;\r\n    this.prev = prev;\r\n  }\r\n}\r\n\r\n\r\nclass LocalMinima {\r\n  readonly vertex: Vertex;\r\n  readonly polytype: PathType;\r\n  readonly isOpen: boolean;\r\n\r\n  constructor(vertex: Vertex, polytype: PathType, isOpen: boolean = false) {\r\n    this.vertex = vertex;\r\n    this.polytype = polytype;\r\n    this.isOpen = isOpen;\r\n  }\r\n\r\n  static equals(lm1: LocalMinima, lm2: LocalMinima): boolean {\r\n    return lm1.vertex === lm2.vertex;\r\n  }\r\n\r\n  static notEquals(lm1: LocalMinima, lm2: LocalMinima): boolean {\r\n    return lm1.vertex !== lm2.vertex;\r\n  }\r\n\r\n  //hashCode(): number {\r\n  //  return this.vertex.hashCode();\r\n  //}\r\n}\r\n\r\nclass IntersectNode {\r\n  readonly pt: IPoint64;\r\n  readonly edge1: Active;\r\n  readonly edge2: Active;\r\n\r\n  constructor(pt: IPoint64, edge1: Active, edge2: Active) {\r\n    this.pt = pt;\r\n    this.edge1 = edge1;\r\n    this.edge2 = edge2;\r\n  }\r\n}\r\n\r\nclass OutPt {\r\n  pt: IPoint64;\r\n  next: OutPt | undefined;\r\n  prev: OutPt;\r\n  outrec: OutRec;\r\n  horz: HorzSegment | undefined;\r\n\r\n  constructor(pt: IPoint64, outrec: OutRec) {\r\n    this.pt = pt;\r\n    this.outrec = outrec;\r\n    this.next = this;\r\n    this.prev = this;\r\n    this.horz = undefined;\r\n  }\r\n}\r\n\r\nexport enum JoinWith {\r\n  None,\r\n  Left,\r\n  Right\r\n}\r\n\r\nexport enum HorzPosition {\r\n  Bottom,\r\n  Middle,\r\n  Top\r\n}\r\n\r\n\r\nexport class OutRec {\r\n  idx: number;\r\n  owner: OutRec | undefined;\r\n  frontEdge: Active | undefined;\r\n  backEdge: Active | undefined;\r\n  pts: OutPt | undefined;\r\n  polypath: PolyPathBase | undefined;\r\n  bounds!: Rect64;\r\n  path!: Path64;\r\n  isOpen: boolean;\r\n  splits: number[] | undefined;\r\n  recursiveSplit: OutRec | undefined;\r\n  constructor(idx: number) {\r\n    this.idx = idx\r\n    this.isOpen = false\r\n  }\r\n}\r\n\r\nclass HorzSegment {\r\n  leftOp: OutPt //| undefined;\r\n  rightOp: OutPt | undefined;\r\n  leftToRight: boolean;\r\n\r\n  constructor(op: OutPt) {\r\n    this.leftOp = op;\r\n    this.rightOp = undefined;\r\n    this.leftToRight = true;\r\n  }\r\n}\r\n\r\nclass HorzJoin {\r\n  op1: OutPt | undefined;\r\n  op2: OutPt | undefined;\r\n\r\n  constructor(ltor: OutPt, rtol: OutPt) {\r\n    this.op1 = ltor;\r\n    this.op2 = rtol;\r\n  }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////\r\n// Important: UP and DOWN here are premised on Y-axis positive down\r\n// displays, which is the orientation used in Clipper's development.\r\n///////////////////////////////////////////////////////////////////\r\n\r\nexport class Active {\r\n  bot!: IPoint64\r\n  top!: IPoint64\r\n  curX!: number;// current (updated at every new scanline)\r\n  dx: number;\r\n  windDx!: number;// 1 or -1 depending on winding direction\r\n  windCount: number;\r\n  windCount2: number;// winding count of the opposite polytype\r\n  outrec: OutRec | undefined;\r\n\r\n  // AEL: 'active edge list' (Vatti's AET - active edge table)\r\n  //     a linked list of all edges (from left to right) that are present\r\n  //     (or 'active') within the current scanbeam (a horizontal 'beam' that\r\n  //     sweeps from bottom to top over the paths in the clipping operation).\r\n  prevInAEL: Active | undefined;\r\n  nextInAEL: Active | undefined;\r\n\r\n  // SEL: 'sorted edge list' (Vatti's ST - sorted table)\r\n  //     linked list used when sorting edges into their new positions at the\r\n  //     top of scanbeams, but also (re)used to process horizontals.\r\n  prevInSEL: Active | undefined;\r\n  nextInSEL: Active | undefined;\r\n  jump: Active | undefined;\r\n  vertexTop: Vertex | undefined\r\n  localMin!: LocalMinima // the bottom of an edge 'bound' (also Vatti)\r\n  isLeftBound: boolean\r\n  joinWith: JoinWith\r\n\r\n  constructor() {\r\n    this.dx = this.windCount = this.windCount2 = 0\r\n    this.isLeftBound = false\r\n    this.joinWith = JoinWith.None\r\n  }\r\n}\r\n\r\nexport class ClipperEngine {\r\n  static addLocMin(vert: Vertex, polytype: PathType, isOpen: boolean, minimaList: LocalMinima[]): void {\r\n    // make sure the vertex is added only once ...\r\n    if ((vert.flags & VertexFlags.LocalMin) !== VertexFlags.None) return;\r\n    vert.flags |= VertexFlags.LocalMin;\r\n\r\n    const lm = new LocalMinima(vert, polytype, isOpen);\r\n    minimaList.push(lm);\r\n  }\r\n\r\n  static addPathsToVertexList(paths: Path64[], polytype: PathType, isOpen: boolean, minimaList: LocalMinima[], vertexList: Vertex[]): void {\r\n    let totalVertCnt = 0;\r\n    for (const path of paths)\r\n      totalVertCnt += path.length;\r\n\r\n    for (const path of paths) {\r\n      let v0: Vertex | undefined = undefined;\r\n      let prev_v: Vertex | undefined = undefined;\r\n      let curr_v: Vertex | undefined = undefined;\r\n      for (const pt of path) {\r\n        if (!v0) {\r\n          v0 = new Vertex(pt, VertexFlags.None, undefined);\r\n          vertexList.push(v0);\r\n          prev_v = v0;\r\n        } else if (prev_v!.pt !== pt) {  // i.e., skips duplicates\r\n          curr_v = new Vertex(pt, VertexFlags.None, prev_v);\r\n          vertexList.push(curr_v);\r\n          prev_v!.next = curr_v;\r\n          prev_v = curr_v;\r\n        }\r\n      }\r\n      if (!prev_v || !prev_v.prev) continue;\r\n      if (!isOpen && prev_v.pt === v0!.pt) prev_v = prev_v.prev;\r\n      prev_v.next = v0;\r\n      v0!.prev = prev_v;\r\n      if (!isOpen && prev_v.next === prev_v) continue;\r\n\r\n      // OK, we have a valid path\r\n      let going_up = false\r\n\r\n      if (isOpen) {\r\n        curr_v = v0!.next;\r\n        let count = 0\r\n        while (curr_v !== v0 && curr_v!.pt.y === v0!.pt.y) {\r\n          curr_v = curr_v!.next;\r\n          if (count++ > totalVertCnt) {\r\n            console.warn('infinite loop detected')\r\n            break;\r\n          }\r\n        }\r\n        going_up = curr_v!.pt.y <= v0!.pt.y;\r\n        if (going_up) {\r\n          v0!.flags = VertexFlags.OpenStart;\r\n          this.addLocMin(v0!, polytype, true, minimaList);\r\n        } else {\r\n          v0!.flags = VertexFlags.OpenStart | VertexFlags.LocalMax;\r\n        }\r\n      } else { // closed path\r\n        prev_v = v0!.prev;\r\n        let count = 0\r\n        while (prev_v !== v0 && prev_v!.pt.y === v0!.pt.y) {\r\n          prev_v = prev_v!.prev;\r\n\r\n          if (count++ > totalVertCnt) {\r\n            console.warn('infinite loop detected')\r\n            break;\r\n          }\r\n        }\r\n        if (prev_v === v0) {\r\n          continue; // only open paths can be completely flat\r\n        }\r\n        going_up = prev_v!.pt.y > v0!.pt.y;\r\n      }\r\n\r\n      const going_up0 = going_up;\r\n      prev_v = v0;\r\n      curr_v = v0!.next;\r\n\r\n      let count = 0\r\n      while (curr_v !== v0) {\r\n        if (curr_v!.pt.y > prev_v!.pt.y && going_up) {\r\n          prev_v!.flags |= VertexFlags.LocalMax;\r\n          going_up = false;\r\n        } else if (curr_v!.pt.y < prev_v!.pt.y && !going_up) {\r\n          going_up = true;\r\n          this.addLocMin(prev_v!, polytype, isOpen, minimaList);\r\n        }\r\n        prev_v = curr_v;\r\n        curr_v = curr_v!.next;\r\n\r\n        if (count++ > totalVertCnt) {\r\n          console.warn('infinite loop detected')\r\n          break;\r\n        }\r\n\r\n      }\r\n\r\n      if (isOpen) {\r\n        prev_v!.flags |= VertexFlags.OpenEnd;\r\n        if (going_up) {\r\n          prev_v!.flags |= VertexFlags.LocalMax;\r\n        } else {\r\n          this.addLocMin(prev_v!, polytype, isOpen, minimaList);\r\n        }\r\n      } else if (going_up !== going_up0) {\r\n        if (going_up0) {\r\n          this.addLocMin(prev_v!, polytype, false, minimaList);\r\n        } else {\r\n          prev_v!.flags |= VertexFlags.LocalMax;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport class ReuseableDataContainer64 {\r\n  readonly _minimaList: LocalMinima[];\r\n  private readonly _vertexList: Vertex[];\r\n\r\n  constructor() {\r\n    this._minimaList = [];\r\n    this._vertexList = [];\r\n  }\r\n\r\n  public clear(): void {\r\n    this._minimaList.length = 0;\r\n    this._vertexList.length = 0;\r\n  }\r\n\r\n  public addPaths(paths: Paths64, pt: PathType, isOpen: boolean): void {\r\n    ClipperEngine.addPathsToVertexList(paths, pt, isOpen, this._minimaList, this._vertexList);\r\n  }\r\n}\r\n\r\nclass SimpleNavigableSet {\r\n  items: Array<number> = []\r\n\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  clear(): void { this.items.length = 0 }\r\n  isEmpty(): boolean { return this.items.length == 0 }\r\n\r\n  pollLast(): number | undefined {\r\n    return this.items.pop();\r\n  }\r\n\r\n  add(item: number) {\r\n    if (!this.items.includes(item)) {\r\n      this.items.push(item);\r\n      this.items.sort((a, b) => a - b);\r\n    }\r\n  }\r\n}\r\n\r\nexport class ClipperBase {\r\n  private _cliptype: ClipType = ClipType.None\r\n  private _fillrule: FillRule = FillRule.EvenOdd\r\n  private _actives?: Active;\r\n  private _sel?: Active;\r\n  private readonly _minimaList: LocalMinima[];\r\n  private readonly _intersectList: IntersectNode[];\r\n  private readonly _vertexList: Vertex[];\r\n  private readonly _outrecList: OutRec[];\r\n  private readonly _scanlineList: SimpleNavigableSet;\r\n  private readonly _horzSegList: HorzSegment[];\r\n  private readonly _horzJoinList: HorzJoin[];\r\n  private _currentLocMin: number = 0\r\n  private _currentBotY: number = 0\r\n  private _isSortedMinimaList: boolean = false\r\n  private _hasOpenPaths: boolean = false\r\n  protected _using_polytree: boolean = false\r\n  protected _succeeded: boolean = false\r\n  public preserveCollinear: boolean;\r\n  public reverseSolution: boolean = false\r\n\r\n  constructor() {\r\n    this._minimaList = [];\r\n    this._intersectList = [];\r\n    this._vertexList = [];\r\n    this._outrecList = [];\r\n    this._scanlineList = new SimpleNavigableSet()\r\n    this._horzSegList = [];\r\n    this._horzJoinList = [];\r\n    this.preserveCollinear = true;\r\n  }\r\n\r\n  private static isOdd(val: number): boolean {\r\n    return ((val & 1) !== 0);\r\n  }\r\n\r\n  private static isHotEdgeActive(ae: Active): boolean {\r\n    return ae.outrec !== undefined;\r\n  }\r\n\r\n  private static isOpen(ae: Active): boolean {\r\n    return ae.localMin.isOpen;\r\n  }\r\n\r\n  private static isOpenEndActive(ae: Active): boolean {\r\n    return ae.localMin.isOpen && ClipperBase.isOpenEnd(ae.vertexTop!);\r\n  }\r\n\r\n  private static isOpenEnd(v: Vertex): boolean {\r\n    return (v.flags & (VertexFlags.OpenStart | VertexFlags.OpenEnd)) !== VertexFlags.None;\r\n  }\r\n\r\n  private static getPrevHotEdge(ae: Active): Active | undefined {\r\n    let prev: Active | undefined = ae.prevInAEL;\r\n    while (prev && (ClipperBase.isOpen(prev) || !ClipperBase.isHotEdgeActive(prev)))\r\n      prev = prev.prevInAEL;\r\n    return prev;\r\n  }\r\n\r\n  private static isFront(ae: Active): boolean {\r\n    return ae === ae.outrec!.frontEdge;\r\n  }\r\n\r\n  /*******************************************************************************\r\n  *  Dx:                             0(90deg)                                    *\r\n  *                                  |                                           *\r\n  *               +inf (180deg) <--- o --. -inf (0deg)                          *\r\n  *******************************************************************************/\r\n\r\n  private static getDx(pt1: IPoint64, pt2: IPoint64): number {\r\n    const dy: number = pt2.y - pt1.y;\r\n    if (dy !== 0)\r\n      return (pt2.x - pt1.x) / dy;\r\n    if (pt2.x > pt1.x)\r\n      return Number.NEGATIVE_INFINITY;\r\n    return Number.POSITIVE_INFINITY;\r\n  }\r\n\r\n  private static topX(ae: Active, currentY: number): number {\r\n    if ((currentY === ae.top.y) || (ae.top.x === ae.bot.x)) return ae.top.x;\r\n    if (currentY === ae.bot.y) return ae.bot.x;\r\n    return ae.bot.x + Math.round(ae.dx * (currentY - ae.bot.y));\r\n  }\r\n\r\n  private static isHorizontal(ae: Active): boolean {\r\n    return (ae.top.y === ae.bot.y);\r\n  }\r\n\r\n  private static isHeadingRightHorz(ae: Active): boolean {\r\n    return (Number.NEGATIVE_INFINITY === ae.dx);\r\n  }\r\n\r\n  private static isHeadingLeftHorz(ae: Active): boolean {\r\n    return (Number.POSITIVE_INFINITY === ae.dx);\r\n  }\r\n\r\n  private static swapActives(ae1: Active, ae2: Active): void {\r\n    [ae2, ae1] = [ae1, ae2];\r\n  }\r\n\r\n  private static getPolyType(ae: Active): PathType {\r\n    return ae.localMin.polytype;\r\n  }\r\n\r\n  private static isSamePolyType(ae1: Active, ae2: Active): boolean {\r\n    return ae1.localMin.polytype === ae2.localMin.polytype;\r\n  }\r\n\r\n  private static setDx(ae: Active): void {\r\n    ae.dx = ClipperBase.getDx(ae.bot, ae.top);\r\n  }\r\n\r\n  private static nextVertex(ae: Active): Vertex {\r\n    if (ae.windDx > 0)\r\n      return ae.vertexTop!.next!;\r\n    return ae.vertexTop!.prev!;\r\n  }\r\n\r\n  private static prevPrevVertex(ae: Active): Vertex {\r\n    if (ae.windDx > 0)\r\n      return ae.vertexTop!.prev!.prev!;\r\n    return ae.vertexTop!.next!.next!;\r\n  }\r\n\r\n  private static isMaxima(vertex: Vertex): boolean {\r\n    return (vertex.flags & VertexFlags.LocalMax) !== VertexFlags.None;\r\n  }\r\n\r\n  private static isMaximaActive(ae: Active): boolean {\r\n    return ClipperBase.isMaxima(ae.vertexTop!);\r\n  }\r\n\r\n  private static getMaximaPair(ae: Active): Active | undefined {\r\n    let ae2: Active | undefined = ae.nextInAEL;\r\n    while (ae2) {\r\n      if (ae2.vertexTop === ae.vertexTop) return ae2; // Found!\r\n      ae2 = ae2.nextInAEL;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private static getCurrYMaximaVertex_Open(ae: Active): Vertex | undefined {\r\n    let result: Vertex | undefined = ae.vertexTop;\r\n    if (ae.windDx > 0) {\r\n      while (result!.next!.pt.y === result!.pt.y &&\r\n        ((result!.flags & (VertexFlags.OpenEnd |\r\n          VertexFlags.LocalMax)) === VertexFlags.None))\r\n        result = result!.next;\r\n    } else {\r\n      while (result!.prev!.pt.y === result!.pt.y &&\r\n        ((result!.flags & (VertexFlags.OpenEnd |\r\n          VertexFlags.LocalMax)) === VertexFlags.None))\r\n        result = result!.prev;\r\n    }\r\n    if (!ClipperBase.isMaxima(result!)) result = undefined; // not a maxima\r\n    return result;\r\n  }\r\n\r\n  private static getCurrYMaximaVertex(ae: Active): Vertex | undefined {\r\n    let result: Vertex | undefined = ae.vertexTop;\r\n    if (ae.windDx > 0) {\r\n      while (result!.next!.pt.y === result!.pt.y) result = result!.next;\r\n    } else {\r\n      while (result!.prev!.pt.y === result!.pt.y) result = result!.prev;\r\n    }\r\n    if (!ClipperBase.isMaxima(result!)) result = undefined; // not a maxima\r\n    return result;\r\n  }\r\n\r\n  private static setSides(outrec: OutRec, startEdge: Active, endEdge: Active): void {\r\n    outrec.frontEdge = startEdge;\r\n    outrec.backEdge = endEdge;\r\n  }\r\n\r\n  private static swapOutrecs(ae1: Active, ae2: Active): void {\r\n    const or1: OutRec | undefined = ae1.outrec;\r\n    const or2: OutRec | undefined = ae2.outrec;\r\n    if (or1 === or2) {\r\n      const ae: Active | undefined = or1!.frontEdge;\r\n      or1!.frontEdge = or1!.backEdge;\r\n      or1!.backEdge = ae;\r\n      return;\r\n    }\r\n\r\n    if (or1) {\r\n      if (ae1 === or1.frontEdge)\r\n        or1.frontEdge = ae2;\r\n      else\r\n        or1.backEdge = ae2;\r\n    }\r\n\r\n    if (or2) {\r\n      if (ae2 === or2.frontEdge)\r\n        or2.frontEdge = ae1;\r\n      else\r\n        or2.backEdge = ae1;\r\n    }\r\n\r\n    ae1.outrec = or2;\r\n    ae2.outrec = or1;\r\n  }\r\n\r\n  private static setOwner(outrec: OutRec, newOwner: OutRec): void {\r\n    while (newOwner.owner && !newOwner.owner.pts) {\r\n      newOwner.owner = newOwner.owner.owner;\r\n    }\r\n\r\n    //make sure that outrec isn't an owner of newOwner\r\n    let tmp: OutRec | undefined = newOwner;\r\n    while (tmp && tmp !== outrec)\r\n      tmp = tmp.owner;\r\n    if (tmp)\r\n      newOwner.owner = outrec.owner;\r\n    outrec.owner = newOwner;\r\n  }\r\n\r\n  private static area(op: OutPt): number {\r\n    // https://en.wikipedia.org/wiki/Shoelace_formula\r\n    let area = 0.0;\r\n    let op2 = op;\r\n    do {\r\n      area += (op2.prev.pt.y + op2.pt.y) *\r\n        (op2.prev.pt.x - op2.pt.x);\r\n      op2 = op2.next!;\r\n    } while (op2 !== op);\r\n    return area * 0.5;\r\n  }\r\n\r\n  private static areaTriangle(pt1: IPoint64, pt2: IPoint64, pt3: IPoint64): number {\r\n    return (pt3.y + pt1.y) * (pt3.x - pt1.x) +\r\n      (pt1.y + pt2.y) * (pt1.x - pt2.x) +\r\n      (pt2.y + pt3.y) * (pt2.x - pt3.x);\r\n  }\r\n\r\n  private static getRealOutRec(outRec: OutRec | undefined): OutRec | undefined {\r\n    while (outRec !== undefined && outRec.pts === undefined) {\r\n      outRec = outRec.owner;\r\n    }\r\n    return outRec;\r\n  }\r\n\r\n  private static isValidOwner(outRec: OutRec | undefined, testOwner: OutRec | undefined): boolean {\r\n    while (testOwner !== undefined && testOwner !== outRec)\r\n      testOwner = testOwner.owner;\r\n    return testOwner === undefined;\r\n  }\r\n\r\n  private static uncoupleOutRec(ae: Active): void {\r\n    const outrec = ae.outrec;\r\n    if (outrec === undefined) return;\r\n    outrec.frontEdge!.outrec = undefined;\r\n    outrec.backEdge!.outrec = undefined;\r\n    outrec.frontEdge = undefined;\r\n    outrec.backEdge = undefined;\r\n  }\r\n\r\n  private static outrecIsAscending(hotEdge: Active): boolean {\r\n    return (hotEdge === hotEdge.outrec!.frontEdge);\r\n  }\r\n\r\n  private static swapFrontBackSides(outrec: OutRec): void {\r\n    // while this proc. is needed for open paths\r\n    // it's almost never needed for closed paths\r\n    const ae2 = outrec.frontEdge!;\r\n    outrec.frontEdge = outrec.backEdge;\r\n    outrec.backEdge = ae2;\r\n    outrec.pts = outrec.pts!.next;\r\n  }\r\n\r\n  private static edgesAdjacentInAEL(inode: IntersectNode): boolean {\r\n    return (inode.edge1.nextInAEL === inode.edge2) || (inode.edge1.prevInAEL === inode.edge2);\r\n  }\r\n\r\n  protected clearSolutionOnly(): void {\r\n    while (this._actives) this.deleteFromAEL(this._actives);\r\n    this._scanlineList.clear()\r\n    this.disposeIntersectNodes();\r\n    this._outrecList.length = 0\r\n    this._horzSegList.length = 0\r\n    this._horzJoinList.length = 0\r\n  }\r\n\r\n  public clear(): void {\r\n    this.clearSolutionOnly();\r\n    this._minimaList.length = 0\r\n    this._vertexList.length = 0\r\n    this._currentLocMin = 0;\r\n    this._isSortedMinimaList = false;\r\n    this._hasOpenPaths = false;\r\n  }\r\n\r\n  protected reset(): void {\r\n    if (!this._isSortedMinimaList) {\r\n      this._minimaList.sort((locMin1, locMin2) => locMin2.vertex.pt.y - locMin1.vertex.pt.y);\r\n      this._isSortedMinimaList = true;\r\n    }\r\n\r\n    for (let i = this._minimaList.length - 1; i >= 0; i--) {\r\n      this._scanlineList.add(this._minimaList[i].vertex.pt.y);\r\n    }\r\n\r\n    this._currentBotY = 0;\r\n    this._currentLocMin = 0;\r\n    this._actives = undefined;\r\n    this._sel = undefined;\r\n    this._succeeded = true;\r\n  }\r\n\r\n  private insertScanline(y: number): void {\r\n    this._scanlineList.add(y)\r\n  }\r\n\r\n  private popScanline(): number | undefined {\r\n    return this._scanlineList.pollLast();\r\n  }\r\n\r\n  private hasLocMinAtY(y: number): boolean {\r\n    return (this._currentLocMin < this._minimaList.length && this._minimaList[this._currentLocMin].vertex.pt.y == y);\r\n  }\r\n\r\n  private popLocalMinima(): LocalMinima {\r\n    return this._minimaList[this._currentLocMin++];\r\n  }\r\n\r\n  private addLocMin(vert: Vertex, polytype: PathType, isOpen: boolean): void {\r\n    // make sure the vertex is added only once ...\r\n    if ((vert.flags & VertexFlags.LocalMin) != VertexFlags.None) return\r\n\r\n    vert.flags |= VertexFlags.LocalMin;\r\n\r\n    const lm = new LocalMinima(vert, polytype, isOpen);\r\n    this._minimaList.push(lm);\r\n  }\r\n\r\n  public addSubject(path: Path64): void {\r\n    this.addPath(path, PathType.Subject);\r\n  }\r\n\r\n  public addOpenSubject(path: Path64): void {\r\n    this.addPath(path, PathType.Subject, true);\r\n  }\r\n\r\n  public addClip(path: Path64): void {\r\n    this.addPath(path, PathType.Clip);\r\n  }\r\n\r\n  protected addPath(path: Path64, polytype: PathType, isOpen = false): void {\r\n    const tmp: Paths64 = [path];\r\n    this.addPaths(tmp, polytype, isOpen);\r\n  }\r\n\r\n  protected addPaths(paths: Paths64, polytype: PathType, isOpen = false): void {\r\n    if (isOpen) this._hasOpenPaths = true;\r\n    this._isSortedMinimaList = false;\r\n    ClipperEngine.addPathsToVertexList(paths, polytype, isOpen, this._minimaList, this._vertexList);\r\n  }\r\n\r\n  protected addReuseableData(reuseableData: ReuseableDataContainer64): void {\r\n    if (reuseableData._minimaList.length === 0) return;\r\n\r\n    this._isSortedMinimaList = false;\r\n    for (const lm of reuseableData._minimaList) {\r\n      this._minimaList.push(new LocalMinima(lm.vertex, lm.polytype, lm.isOpen));\r\n      if (lm.isOpen) this._hasOpenPaths = true;\r\n    }\r\n  }\r\n\r\n  private isContributingClosed(ae: Active): boolean {\r\n    switch (this._fillrule) {\r\n      case FillRule.Positive:\r\n        if (ae.windCount !== 1) return false;\r\n        break;\r\n      case FillRule.Negative:\r\n        if (ae.windCount !== -1) return false;\r\n        break;\r\n      case FillRule.NonZero:\r\n        if (Math.abs(ae.windCount) !== 1) return false;\r\n        break;\r\n    }\r\n\r\n    switch (this._cliptype) {\r\n      case ClipType.Intersection:\r\n        switch (this._fillrule) {\r\n          case FillRule.Positive: return ae.windCount2 > 0;\r\n          case FillRule.Negative: return ae.windCount2 < 0;\r\n          default: return ae.windCount2 !== 0;\r\n        }\r\n      case ClipType.Union:\r\n        switch (this._fillrule) {\r\n          case FillRule.Positive: return ae.windCount2 <= 0;\r\n          case FillRule.Negative: return ae.windCount2 >= 0;\r\n          default: return ae.windCount2 === 0;\r\n        }\r\n      case ClipType.Difference:\r\n        const result = this._fillrule === FillRule.Positive ? (ae.windCount2 <= 0) :\r\n          this._fillrule === FillRule.Negative ? (ae.windCount2 >= 0) :\r\n            (ae.windCount2 === 0);\r\n        return ClipperBase.getPolyType(ae) === PathType.Subject ? result : !result;\r\n\r\n      case ClipType.Xor:\r\n        return true;\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  private isContributingOpen(ae: Active): boolean {\r\n    let isInClip: boolean, isInSubj: boolean;\r\n    switch (this._fillrule) {\r\n      case FillRule.Positive:\r\n        isInSubj = ae.windCount > 0;\r\n        isInClip = ae.windCount2 > 0;\r\n        break;\r\n      case FillRule.Negative:\r\n        isInSubj = ae.windCount < 0;\r\n        isInClip = ae.windCount2 < 0;\r\n        break;\r\n      default:\r\n        isInSubj = ae.windCount !== 0;\r\n        isInClip = ae.windCount2 !== 0;\r\n        break;\r\n    }\r\n\r\n    switch (this._cliptype) {\r\n      case ClipType.Intersection:\r\n        return isInClip;\r\n      case ClipType.Union:\r\n        return !isInSubj && !isInClip;\r\n      default:\r\n        return !isInClip;\r\n    }\r\n  }\r\n\r\n  private setWindCountForClosedPathEdge(ae: Active): void {\r\n    let ae2: Active | undefined = ae.prevInAEL;\r\n    const pt: PathType = ClipperBase.getPolyType(ae);\r\n\r\n    while (ae2 !== undefined && (ClipperBase.getPolyType(ae2) !== pt || ClipperBase.isOpen(ae2))) {\r\n      ae2 = ae2.prevInAEL;\r\n    }\r\n\r\n    if (ae2 === undefined) {\r\n      ae.windCount = ae.windDx;\r\n      ae2 = this._actives;\r\n    } else if (this._fillrule === FillRule.EvenOdd) {\r\n      ae.windCount = ae.windDx;\r\n      ae.windCount2 = ae2.windCount2;\r\n      ae2 = ae2.nextInAEL;\r\n    } else {\r\n      // NonZero, positive, or negative filling here ...\r\n      // when e2's WindCnt is in the SAME direction as its WindDx,\r\n      // then polygon will fill on the right of 'e2' (and 'e' will be inside)\r\n      // nb: neither e2.WindCnt nor e2.WindDx should ever be 0.\r\n      if (ae2.windCount * ae2.windDx < 0) {\r\n        // opposite directions so 'ae' is outside 'ae2' ...\r\n        if (Math.abs(ae2.windCount) > 1) {\r\n          // outside prev poly but still inside another.\r\n          if (ae2.windDx * ae.windDx < 0)\r\n            // reversing direction so use the same WC\r\n            ae.windCount = ae2.windCount;\r\n          else\r\n            // otherwise keep 'reducing' the WC by 1 (i.e. towards 0) ...\r\n            ae.windCount = ae2.windCount + ae.windDx;\r\n        } else {\r\n          // now outside all polys of same polytype so set own WC ...\r\n          ae.windCount = (ClipperBase.isOpen(ae) ? 1 : ae.windDx);\r\n        }\r\n      } else {\r\n        // 'ae' must be inside 'ae2'\r\n        if (ae2.windDx * ae.windDx < 0)\r\n          // reversing direction so use the same WC\r\n          ae.windCount = ae2.windCount;\r\n        else\r\n          // otherwise keep 'increasing' the WC by 1 (i.e. away from 0) ...\r\n          ae.windCount = ae2.windCount + ae.windDx;\r\n      }\r\n\r\n      ae.windCount2 = ae2.windCount2;\r\n      ae2 = ae2.nextInAEL;  // i.e. get ready to calc WindCnt2\r\n\r\n    }\r\n\r\n    if (this._fillrule === FillRule.EvenOdd) {\r\n      while (ae2 !== ae) {\r\n        if (ClipperBase.getPolyType(ae2!) !== pt && !ClipperBase.isOpen(ae2!)) {\r\n          ae.windCount2 = (ae.windCount2 === 0 ? 1 : 0);\r\n        }\r\n        ae2 = ae2!.nextInAEL;\r\n      }\r\n    } else {\r\n      while (ae2 !== ae) {\r\n        if (ClipperBase.getPolyType(ae2!) !== pt && !ClipperBase.isOpen(ae2!)) {\r\n          ae.windCount2 += ae2!.windDx;\r\n        }\r\n        ae2 = ae2!.nextInAEL;\r\n      }\r\n    }\r\n  }\r\n\r\n  private setWindCountForOpenPathEdge(ae: Active) {\r\n    let ae2: Active | undefined = this._actives;\r\n    if (this._fillrule === FillRule.EvenOdd) {\r\n      let cnt1 = 0, cnt2 = 0;\r\n      while (ae2 !== ae) {\r\n        if (ClipperBase.getPolyType(ae2!) === PathType.Clip)\r\n          cnt2++;\r\n        else if (!ClipperBase.isOpen(ae2!))\r\n          cnt1++;\r\n        ae2 = ae2!.nextInAEL;\r\n      }\r\n\r\n      ae.windCount = (ClipperBase.isOdd(cnt1) ? 1 : 0);\r\n      ae.windCount2 = (ClipperBase.isOdd(cnt2) ? 1 : 0);\r\n    }\r\n    else {\r\n      while (ae2 !== ae) {\r\n        if (ClipperBase.getPolyType(ae2!) === PathType.Clip)\r\n          ae.windCount2 += ae2!.windDx;\r\n        else if (!ClipperBase.isOpen(ae2!))\r\n          ae.windCount += ae2!.windDx;\r\n        ae2 = ae2!.nextInAEL;\r\n      }\r\n    }\r\n  }\r\n\r\n  private static isValidAelOrder(resident: Active, newcomer: Active): boolean {\r\n    if (newcomer.curX !== resident.curX)\r\n      return newcomer.curX > resident.curX;\r\n\r\n    // get the turning direction  a1.top, a2.bot, a2.top\r\n    const d: number = InternalClipper.crossProduct(resident.top, newcomer.bot, newcomer.top);\r\n    if (d !== 0.0) return (d < 0);\r\n\r\n    // edges must be collinear to get here\r\n\r\n    // for starting open paths, place them according to\r\n    // the direction they're about to turn\r\n    if (!this.isMaximaActive(resident) && (resident.top.y > newcomer.top.y)) {\r\n      return InternalClipper.crossProduct(newcomer.bot,\r\n        resident.top, this.nextVertex(resident).pt) <= 0;\r\n    }\r\n\r\n    if (!this.isMaximaActive(newcomer) && (newcomer.top.y > resident.top.y)) {\r\n      return InternalClipper.crossProduct(newcomer.bot,\r\n        newcomer.top, this.nextVertex(newcomer).pt) >= 0;\r\n    }\r\n\r\n    const y: number = newcomer.bot.y;\r\n    const newcomerIsLeft: boolean = newcomer.isLeftBound;\r\n\r\n    if (resident.bot.y !== y || resident.localMin.vertex.pt.y !== y)\r\n      return newcomer.isLeftBound;\r\n    // resident must also have just been inserted\r\n    if (resident.isLeftBound !== newcomerIsLeft)\r\n      return newcomerIsLeft;\r\n    if (InternalClipper.crossProduct(this.prevPrevVertex(resident).pt,\r\n      resident.bot, resident.top) === 0) return true;\r\n    // compare turning direction of the alternate bound\r\n    return (InternalClipper.crossProduct(this.prevPrevVertex(resident).pt,\r\n      newcomer.bot, this.prevPrevVertex(newcomer).pt) > 0) === newcomerIsLeft;\r\n  }\r\n\r\n  private insertLeftEdge(ae: Active): void {\r\n    let ae2: Active;\r\n\r\n    if (!this._actives) {\r\n      ae.prevInAEL = undefined;\r\n      ae.nextInAEL = undefined;\r\n      this._actives = ae;\r\n    } else if (!ClipperBase.isValidAelOrder(this._actives, ae)) {\r\n      ae.prevInAEL = undefined;\r\n      ae.nextInAEL = this._actives;\r\n      this._actives.prevInAEL = ae;\r\n      this._actives = ae;\r\n    } else {\r\n      ae2 = this._actives;\r\n      while (ae2.nextInAEL && ClipperBase.isValidAelOrder(ae2.nextInAEL, ae))\r\n        ae2 = ae2.nextInAEL;\r\n      //don't separate joined edges\r\n      if (ae2.joinWith === JoinWith.Right) ae2 = ae2.nextInAEL!;\r\n      ae.nextInAEL = ae2.nextInAEL;\r\n      if (ae2.nextInAEL) ae2.nextInAEL.prevInAEL = ae;\r\n      ae.prevInAEL = ae2;\r\n      ae2.nextInAEL = ae;\r\n    }\r\n  }\r\n\r\n  private static insertRightEdge(ae: Active, ae2: Active): void {\r\n    ae2.nextInAEL = ae.nextInAEL;\r\n    if (ae.nextInAEL) ae.nextInAEL.prevInAEL = ae2;\r\n    ae2.prevInAEL = ae;\r\n    ae.nextInAEL = ae2;\r\n  }\r\n\r\n  private insertLocalMinimaIntoAEL(botY: number): void {\r\n    let localMinima: LocalMinima;\r\n    let leftBound: Active | undefined;\r\n    let rightBound: Active | undefined;\r\n\r\n    // Add any local minima (if any) at BotY ...\r\n    // NB horizontal local minima edges should contain locMin.vertex.prev\r\n    while (this.hasLocMinAtY(botY)) {\r\n      localMinima = this.popLocalMinima();\r\n\r\n      if ((localMinima.vertex.flags & VertexFlags.OpenStart) !== VertexFlags.None) {\r\n        leftBound = undefined;\r\n      } else {\r\n        leftBound = new Active()\r\n        leftBound.bot = localMinima.vertex.pt\r\n        leftBound.curX = localMinima.vertex.pt.x\r\n        leftBound.windDx = -1\r\n        leftBound.vertexTop = localMinima.vertex.prev\r\n        leftBound.top = localMinima.vertex.prev!.pt\r\n        leftBound.outrec = undefined\r\n        leftBound.localMin = localMinima\r\n\r\n        ClipperBase.setDx(leftBound);\r\n      }\r\n\r\n      if ((localMinima.vertex.flags & VertexFlags.OpenEnd) !== VertexFlags.None) {\r\n        rightBound = undefined;\r\n      } else {\r\n        rightBound = new Active()\r\n        rightBound.bot = localMinima.vertex.pt\r\n        rightBound.curX = localMinima.vertex.pt.x\r\n        rightBound.windDx = 1\r\n        rightBound.vertexTop = localMinima.vertex.next\r\n        rightBound.top = localMinima.vertex.next!.pt\r\n        rightBound.outrec = undefined\r\n        rightBound.localMin = localMinima\r\n\r\n        ClipperBase.setDx(rightBound);\r\n      }\r\n\r\n      if (leftBound && rightBound) {\r\n        if (ClipperBase.isHorizontal(leftBound)) {\r\n          if (ClipperBase.isHeadingRightHorz(leftBound)) {\r\n            [rightBound, leftBound] = [leftBound, rightBound]\r\n          }\r\n        } else if (ClipperBase.isHorizontal(rightBound)) {\r\n          if (ClipperBase.isHeadingLeftHorz(rightBound)) {\r\n            [rightBound, leftBound] = [leftBound, rightBound]\r\n          }\r\n        } else if (leftBound.dx < rightBound.dx) {\r\n          [rightBound, leftBound] = [leftBound, rightBound]\r\n        }\r\n        //so when leftBound has windDx == 1, the polygon will be oriented\r\n        //counter-clockwise in Cartesian coords (clockwise with inverted Y).\r\n      } else if (leftBound === undefined) {\r\n        leftBound = rightBound;\r\n        rightBound = undefined;\r\n      }\r\n\r\n      let contributing = false\r\n      leftBound!.isLeftBound = true;\r\n      this.insertLeftEdge(leftBound!);\r\n\r\n      if (ClipperBase.isOpen(leftBound!)) {\r\n        this.setWindCountForOpenPathEdge(leftBound!);\r\n        contributing = this.isContributingOpen(leftBound!);\r\n      } else {\r\n        this.setWindCountForClosedPathEdge(leftBound!);\r\n        contributing = this.isContributingClosed(leftBound!);\r\n      }\r\n\r\n      if (rightBound) {\r\n        rightBound.windCount = leftBound!.windCount;\r\n        rightBound.windCount2 = leftBound!.windCount2;\r\n        ClipperBase.insertRightEdge(leftBound!, rightBound);\r\n\r\n        if (contributing) {\r\n          this.addLocalMinPoly(leftBound!, rightBound, leftBound!.bot, true);\r\n          if (!ClipperBase.isHorizontal(leftBound!)) {\r\n            this.checkJoinLeft(leftBound!, leftBound!.bot);\r\n          }\r\n        }\r\n\r\n        while (rightBound.nextInAEL &&\r\n          ClipperBase.isValidAelOrder(rightBound.nextInAEL, rightBound)) {\r\n          this.intersectEdges(rightBound, rightBound.nextInAEL, rightBound.bot);\r\n          this.swapPositionsInAEL(rightBound, rightBound.nextInAEL);\r\n        }\r\n\r\n        if (ClipperBase.isHorizontal(rightBound)) {\r\n          this.pushHorz(rightBound);\r\n        } else {\r\n          this.checkJoinRight(rightBound, rightBound.bot);\r\n          this.insertScanline(rightBound.top.y);\r\n        }\r\n\r\n      } else if (contributing) {\r\n        this.startOpenPath(leftBound!, leftBound!.bot);\r\n      }\r\n\r\n      if (ClipperBase.isHorizontal(leftBound!)) {\r\n        this.pushHorz(leftBound!);\r\n      } else {\r\n        this.insertScanline(leftBound!.top.y);\r\n      }\r\n    }\r\n  }\r\n\r\n  private pushHorz(ae: Active): void {\r\n    ae.nextInSEL = this._sel;\r\n    this._sel = ae;\r\n  }\r\n\r\n  private popHorz(): Active | undefined {\r\n    const ae = this._sel;\r\n    if (this._sel === undefined) return undefined;\r\n    this._sel = this._sel.nextInSEL;\r\n    return ae;\r\n  }\r\n\r\n  private addLocalMinPoly(ae1: Active, ae2: Active, pt: IPoint64, isNew: boolean = false): OutPt {\r\n    const outrec: OutRec = this.newOutRec();\r\n    ae1.outrec = outrec;\r\n    ae2.outrec = outrec;\r\n\r\n    if (ClipperBase.isOpen(ae1)) {\r\n      outrec.owner = undefined;\r\n      outrec.isOpen = true;\r\n      if (ae1.windDx > 0)\r\n        ClipperBase.setSides(outrec, ae1, ae2);\r\n      else\r\n        ClipperBase.setSides(outrec, ae2, ae1);\r\n    } else {\r\n      outrec.isOpen = false;\r\n      const prevHotEdge = ClipperBase.getPrevHotEdge(ae1);\r\n\r\n      // e.windDx is the winding direction of the **input** paths\r\n      // and unrelated to the winding direction of output polygons.\r\n      // Output orientation is determined by e.outrec.frontE which is\r\n      // the ascending edge (see AddLocalMinPoly).\r\n      if (prevHotEdge) {\r\n        if (this._using_polytree)\r\n          ClipperBase.setOwner(outrec, prevHotEdge.outrec!);\r\n        outrec.owner = prevHotEdge.outrec;\r\n\r\n        if (ClipperBase.outrecIsAscending(prevHotEdge) === isNew)\r\n          ClipperBase.setSides(outrec, ae2, ae1);\r\n        else\r\n          ClipperBase.setSides(outrec, ae1, ae2);\r\n      } else {\r\n        outrec.owner = undefined;\r\n        if (isNew)\r\n          ClipperBase.setSides(outrec, ae1, ae2);\r\n        else\r\n          ClipperBase.setSides(outrec, ae2, ae1);\r\n      }\r\n    }\r\n\r\n    const op = new OutPt(pt, outrec);\r\n    outrec.pts = op;\r\n    return op;\r\n  }\r\n\r\n  private addLocalMaxPoly(ae1: Active, ae2: Active, pt: IPoint64): OutPt | undefined {\r\n    if (ClipperBase.isJoined(ae1)) this.split(ae1, pt);\r\n    if (ClipperBase.isJoined(ae2)) this.split(ae2, pt);\r\n\r\n    if (ClipperBase.isFront(ae1) === ClipperBase.isFront(ae2)) {\r\n      if (ClipperBase.isOpenEndActive(ae1))\r\n        ClipperBase.swapFrontBackSides(ae1.outrec!);\r\n      else if (ClipperBase.isOpenEndActive(ae2))\r\n        ClipperBase.swapFrontBackSides(ae2.outrec!);\r\n      else {\r\n        this._succeeded = false;\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    const result = ClipperBase.addOutPt(ae1, pt);\r\n    if (ae1.outrec === ae2.outrec) {\r\n      const outrec = ae1.outrec!;\r\n      outrec.pts = result;\r\n\r\n      if (this._using_polytree) {\r\n        const e = ClipperBase.getPrevHotEdge(ae1);\r\n        if (e === undefined)\r\n          outrec.owner = undefined;\r\n        else\r\n          ClipperBase.setOwner(outrec, e.outrec!);\r\n      }\r\n      ClipperBase.uncoupleOutRec(ae1);\r\n    } else if (ClipperBase.isOpen(ae1)) {\r\n      if (ae1.windDx < 0)\r\n        ClipperBase.joinOutrecPaths(ae1, ae2);\r\n      else\r\n        ClipperBase.joinOutrecPaths(ae2, ae1);\r\n    } else if (ae1.outrec!.idx < ae2.outrec!.idx)\r\n      ClipperBase.joinOutrecPaths(ae1, ae2);\r\n    else\r\n      ClipperBase.joinOutrecPaths(ae2, ae1);\r\n    return result;\r\n  }\r\n\r\n  private static joinOutrecPaths(ae1: Active, ae2: Active): void {\r\n    // join ae2 outrec path onto ae1 outrec path and then delete ae2 outrec path\r\n    // pointers. (NB Only very rarely do the joining ends share the same coords.)\r\n    const p1Start: OutPt = ae1.outrec!.pts!;\r\n    const p2Start: OutPt = ae2.outrec!.pts!;\r\n    const p1End: OutPt = p1Start.next!;\r\n    const p2End: OutPt = p2Start.next!;\r\n\r\n    if (ClipperBase.isFront(ae1)) {\r\n      p2End.prev = p1Start;\r\n      p1Start.next = p2End;\r\n      p2Start.next = p1End;\r\n      p1End.prev = p2Start;\r\n\r\n      ae1.outrec!.pts = p2Start;\r\n      // nb: if IsOpen(e1) then e1 & e2 must be a 'maximaPair'\r\n      ae1.outrec!.frontEdge = ae2.outrec!.frontEdge;\r\n      if (ae1.outrec!.frontEdge)\r\n        ae1.outrec!.frontEdge!.outrec = ae1.outrec;\r\n    } else {\r\n      p1End.prev = p2Start;\r\n      p2Start.next = p1End;\r\n      p1Start.next = p2End;\r\n      p2End.prev = p1Start;\r\n\r\n      ae1.outrec!.backEdge = ae2.outrec!.backEdge;\r\n      if (ae1.outrec!.backEdge)\r\n        ae1.outrec!.backEdge!.outrec = ae1.outrec;\r\n    }\r\n\r\n    // after joining, the ae2.OutRec must contains no vertices ...\r\n    ae2.outrec!.frontEdge = undefined;\r\n    ae2.outrec!.backEdge = undefined;\r\n    ae2.outrec!.pts = undefined;\r\n    ClipperBase.setOwner(ae2.outrec!, ae1.outrec!);\r\n\r\n    if (ClipperBase.isOpenEndActive(ae1)) {\r\n      ae2.outrec!.pts = ae1.outrec!.pts;\r\n      ae1.outrec!.pts = undefined;\r\n    }\r\n\r\n    // and ae1 and ae2 are maxima and are about to be dropped from the Actives list.\r\n    ae1.outrec = undefined;\r\n    ae2.outrec = undefined;\r\n  }\r\n\r\n  private static addOutPt(ae: Active, pt: IPoint64): OutPt {\r\n    const outrec: OutRec = ae.outrec!;\r\n    const toFront: boolean = ClipperBase.isFront(ae);\r\n    const opFront: OutPt = outrec.pts!;\r\n    const opBack: OutPt = opFront.next!;\r\n\r\n    if (toFront && (pt == opFront.pt)) return opFront;\r\n    else if (!toFront && (pt == opBack.pt)) return opBack;\r\n\r\n    const newOp = new OutPt(pt, outrec);\r\n    opBack.prev = newOp;\r\n    newOp.prev = opFront;\r\n    newOp.next = opBack;\r\n    opFront.next = newOp;\r\n\r\n    if (toFront) outrec.pts = newOp;\r\n\r\n    return newOp;\r\n  }\r\n\r\n  private newOutRec(): OutRec {\r\n    const result = new OutRec(this._outrecList.length);\r\n    this._outrecList.push(result);\r\n    return result;\r\n  }\r\n\r\n  private startOpenPath(ae: Active, pt: IPoint64): OutPt {\r\n    const outrec = this.newOutRec();\r\n    outrec.isOpen = true;\r\n    if (ae.windDx > 0) {\r\n      outrec.frontEdge = ae;\r\n      outrec.backEdge = undefined;\r\n    } else {\r\n      outrec.frontEdge = undefined;\r\n      outrec.backEdge = ae;\r\n    }\r\n\r\n    ae.outrec = outrec;\r\n    const op = new OutPt(pt, outrec);\r\n    outrec.pts = op;\r\n    return op;\r\n  }\r\n\r\n  private updateEdgeIntoAEL(ae: Active): void {\r\n    ae.bot = ae.top!;\r\n    ae.vertexTop = ClipperBase.nextVertex(ae);\r\n    ae.top = ae.vertexTop!.pt;\r\n    ae.curX = ae.bot.x;\r\n    ClipperBase.setDx(ae);\r\n\r\n    if (ClipperBase.isJoined(ae)) this.split(ae, ae.bot);\r\n\r\n    if (ClipperBase.isHorizontal(ae)) return;\r\n    this.insertScanline(ae.top.y);\r\n\r\n    this.checkJoinLeft(ae, ae.bot);\r\n    this.checkJoinRight(ae, ae.bot, true);\r\n  }\r\n\r\n  private static findEdgeWithMatchingLocMin(e: Active): Active | undefined {\r\n    let result: Active | undefined = e.nextInAEL;\r\n    while (result) {\r\n      if (result.localMin === e.localMin) return result;\r\n      if (!ClipperBase.isHorizontal(result) && e.bot !== result.bot) result = undefined;\r\n      else result = result.nextInAEL;\r\n    }\r\n\r\n    result = e.prevInAEL;\r\n    while (result) {\r\n      if (result.localMin === e.localMin) return result;\r\n      if (!ClipperBase.isHorizontal(result) && e.bot !== result.bot) return undefined;\r\n      result = result.prevInAEL;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private intersectEdges(ae1: Active, ae2: Active, pt: IPoint64): OutPt | undefined {\r\n    let resultOp: OutPt | undefined = undefined;\r\n\r\n    // MANAGE OPEN PATH INTERSECTIONS SEPARATELY ...\r\n    if (this._hasOpenPaths && (ClipperBase.isOpen(ae1) || ClipperBase.isOpen(ae2))) {\r\n      if (ClipperBase.isOpen(ae1) && ClipperBase.isOpen(ae2)) return undefined;\r\n      // the following line avoids duplicating quite a bit of code\r\n      if (ClipperBase.isOpen(ae2)) ClipperBase.swapActives(ae1, ae2);\r\n      if (ClipperBase.isJoined(ae2)) this.split(ae2, pt);\r\n\r\n      if (this._cliptype === ClipType.Union) {\r\n        if (!ClipperBase.isHotEdgeActive(ae2)) return undefined;\r\n      } else if (ae2.localMin.polytype === PathType.Subject)\r\n        return undefined;\r\n\r\n      switch (this._fillrule) {\r\n        case FillRule.Positive:\r\n          if (ae2.windCount !== 1) return undefined;\r\n          break;\r\n        case FillRule.Negative:\r\n          if (ae2.windCount !== -1) return undefined;\r\n          break;\r\n        default:\r\n          if (Math.abs(ae2.windCount) !== 1) return undefined;\r\n          break;\r\n      }\r\n\r\n      // toggle contribution ...\r\n      if (ClipperBase.isHotEdgeActive(ae1)) {\r\n        resultOp = ClipperBase.addOutPt(ae1, pt);\r\n        if (ClipperBase.isFront(ae1)) {\r\n          ae1.outrec!.frontEdge = undefined;\r\n        } else {\r\n          ae1.outrec!.backEdge = undefined;\r\n        }\r\n        ae1.outrec = undefined;\r\n\r\n        // horizontal edges can pass under open paths at a LocMins\r\n      } else if (pt === ae1.localMin.vertex.pt && !ClipperBase.isOpenEnd(ae1.localMin.vertex)) {\r\n        // find the other side of the LocMin and\r\n        // if it's 'hot' join up with it ...\r\n        const ae3: Active | undefined = ClipperBase.findEdgeWithMatchingLocMin(ae1);\r\n        if (ae3 && ClipperBase.isHotEdgeActive(ae3)) {\r\n          ae1.outrec = ae3.outrec;\r\n          if (ae1.windDx > 0) {\r\n            ClipperBase.setSides(ae3.outrec!, ae1, ae3);\r\n          } else {\r\n            ClipperBase.setSides(ae3.outrec!, ae3, ae1);\r\n          }\r\n          return ae3.outrec!.pts;\r\n        }\r\n        resultOp = this.startOpenPath(ae1, pt);\r\n      } else {\r\n        resultOp = this.startOpenPath(ae1, pt);\r\n      }\r\n\r\n      return resultOp;\r\n    }\r\n\r\n    // MANAGING CLOSED PATHS FROM HERE ON\r\n    if (ClipperBase.isJoined(ae1)) this.split(ae1, pt);\r\n    if (ClipperBase.isJoined(ae2)) this.split(ae2, pt);\r\n\r\n    // UPDATE WINDING COUNTS...\r\n    let oldE1WindCount: number;\r\n    let oldE2WindCount: number;\r\n\r\n    if (ae1.localMin.polytype === ae2.localMin.polytype) {\r\n      if (this._fillrule === FillRule.EvenOdd) {\r\n        oldE1WindCount = ae1.windCount;\r\n        ae1.windCount = ae2.windCount;\r\n        ae2.windCount = oldE1WindCount;\r\n      } else {\r\n        if (ae1.windCount + ae2.windDx === 0)\r\n          ae1.windCount = -ae1.windCount;\r\n        else\r\n          ae1.windCount += ae2.windDx;\r\n        if (ae2.windCount - ae1.windDx === 0)\r\n          ae2.windCount = -ae2.windCount;\r\n        else\r\n          ae2.windCount -= ae1.windDx;\r\n      }\r\n    } else {\r\n      if (this._fillrule !== FillRule.EvenOdd)\r\n        ae1.windCount2 += ae2.windDx;\r\n      else\r\n        ae1.windCount2 = (ae1.windCount2 === 0 ? 1 : 0);\r\n      if (this._fillrule !== FillRule.EvenOdd)\r\n        ae2.windCount2 -= ae1.windDx;\r\n      else\r\n        ae2.windCount2 = (ae2.windCount2 === 0 ? 1 : 0);\r\n    }\r\n\r\n    switch (this._fillrule) {\r\n      case FillRule.Positive:\r\n        oldE1WindCount = ae1.windCount;\r\n        oldE2WindCount = ae2.windCount;\r\n        break;\r\n      case FillRule.Negative:\r\n        oldE1WindCount = -ae1.windCount;\r\n        oldE2WindCount = -ae2.windCount;\r\n        break;\r\n      default:\r\n        oldE1WindCount = Math.abs(ae1.windCount);\r\n        oldE2WindCount = Math.abs(ae2.windCount);\r\n        break;\r\n    }\r\n\r\n    const e1WindCountIs0or1: boolean = oldE1WindCount === 0 || oldE1WindCount === 1;\r\n    const e2WindCountIs0or1: boolean = oldE2WindCount === 0 || oldE2WindCount === 1;\r\n\r\n    if ((!ClipperBase.isHotEdgeActive(ae1) && !e1WindCountIs0or1) || (!ClipperBase.isHotEdgeActive(ae2) && !e2WindCountIs0or1)) return undefined;\r\n\r\n    // NOW PROCESS THE INTERSECTION ...\r\n\r\n    // if both edges are 'hot' ...\r\n    if (ClipperBase.isHotEdgeActive(ae1) && ClipperBase.isHotEdgeActive(ae2)) {\r\n      if ((oldE1WindCount !== 0 && oldE1WindCount !== 1) ||\r\n        (oldE2WindCount !== 0 && oldE2WindCount !== 1) ||\r\n        (ae1.localMin.polytype !== ae2.localMin.polytype &&\r\n          this._cliptype !== ClipType.Xor)) {\r\n        resultOp = this.addLocalMaxPoly(ae1, ae2, pt);\r\n      } else if (ClipperBase.isFront(ae1) || (ae1.outrec === ae2.outrec)) {\r\n        // this 'else if' condition isn't strictly needed but\r\n        // it's sensible to split polygons that only touch at\r\n        // a common vertex (not at common edges).\r\n        resultOp = this.addLocalMaxPoly(ae1, ae2, pt);\r\n        this.addLocalMinPoly(ae1, ae2, pt);\r\n      } else {\r\n        // can't treat as maxima & minima\r\n        resultOp = ClipperBase.addOutPt(ae1, pt);\r\n        ClipperBase.addOutPt(ae2, pt);\r\n        ClipperBase.swapOutrecs(ae1, ae2);\r\n      }\r\n    }\r\n    // if one or the other edge is 'hot' ...\r\n    else if (ClipperBase.isHotEdgeActive(ae1)) {\r\n      resultOp = ClipperBase.addOutPt(ae1, pt);\r\n      ClipperBase.swapOutrecs(ae1, ae2);\r\n    } else if (ClipperBase.isHotEdgeActive(ae2)) {\r\n      resultOp = ClipperBase.addOutPt(ae2, pt);\r\n      ClipperBase.swapOutrecs(ae1, ae2);\r\n    }\r\n\r\n    // neither edge is 'hot'\r\n    else {\r\n      let e1Wc2: number;\r\n      let e2Wc2: number;\r\n\r\n      switch (this._fillrule) {\r\n        case FillRule.Positive:\r\n          e1Wc2 = ae1.windCount2;\r\n          e2Wc2 = ae2.windCount2;\r\n          break;\r\n        case FillRule.Negative:\r\n          e1Wc2 = -ae1.windCount2;\r\n          e2Wc2 = -ae2.windCount2;\r\n          break;\r\n        default:\r\n          e1Wc2 = Math.abs(ae1.windCount2);\r\n          e2Wc2 = Math.abs(ae2.windCount2);\r\n          break;\r\n      }\r\n\r\n      if (!ClipperBase.isSamePolyType(ae1, ae2)) {\r\n        resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n      } else if (oldE1WindCount === 1 && oldE2WindCount === 1) {\r\n        resultOp = undefined;\r\n\r\n        switch (this._cliptype) {\r\n          case ClipType.Union:\r\n            if (e1Wc2 > 0 && e2Wc2 > 0) return undefined;\r\n            resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n            break;\r\n\r\n          case ClipType.Difference:\r\n            if (((ClipperBase.getPolyType(ae1) === PathType.Clip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\r\n              ((ClipperBase.getPolyType(ae1) === PathType.Subject) && (e1Wc2 <= 0) && (e2Wc2 <= 0))) {\r\n              resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n            }\r\n            break;\r\n\r\n          case ClipType.Xor:\r\n            resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n            break;\r\n\r\n          default: // ClipType.Intersection:\r\n            if (e1Wc2 <= 0 || e2Wc2 <= 0) return undefined;\r\n            resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n            break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return resultOp;\r\n  }\r\n\r\n\r\n  private deleteFromAEL(ae: Active): void {\r\n    const prev: Active | undefined = ae.prevInAEL;\r\n    const next: Active | undefined = ae.nextInAEL;\r\n    if (!prev && !next && ae !== this._actives) return;  // already deleted\r\n\r\n    if (prev)\r\n      prev.nextInAEL = next;\r\n    else\r\n      this._actives = next;\r\n\r\n    if (next)\r\n      next.prevInAEL = prev;\r\n  }\r\n\r\n  private adjustCurrXAndCopyToSEL(topY: number): void {\r\n    let ae: Active | undefined = this._actives;\r\n    this._sel = ae;\r\n    while (ae) {\r\n      ae.prevInSEL = ae.prevInAEL;\r\n      ae.nextInSEL = ae.nextInAEL;\r\n      ae.jump = ae.nextInSEL;\r\n      if (ae.joinWith === JoinWith.Left)\r\n        ae.curX = ae.prevInAEL!.curX;  // This also avoids complications\r\n      else\r\n        ae.curX = ClipperBase.topX(ae, topY);\r\n      // NB don't update ae.curr.Y yet (see AddNewIntersectNode)\r\n      ae = ae.nextInAEL;\r\n    }\r\n  }\r\n\r\n  protected executeInternal(ct: ClipType, fillRule: FillRule): void {\r\n    if (ct === ClipType.None) return;\r\n    this._fillrule = fillRule;\r\n    this._cliptype = ct;\r\n    this.reset();\r\n\r\n    let y = this.popScanline()\r\n    if (y === undefined) return\r\n\r\n    while (this._succeeded) {\r\n      this.insertLocalMinimaIntoAEL(y)\r\n      let ae = this.popHorz()\r\n      while (ae) {\r\n        this.doHorizontal(ae)\r\n        ae = this.popHorz()\r\n      }\r\n\r\n      if (this._horzSegList.length > 0) {\r\n        this.convertHorzSegsToJoins();\r\n        this._horzSegList.length = 0\r\n      }\r\n      this._currentBotY = y;  // bottom of scanbeam\r\n\r\n      y = this.popScanline()\r\n      if (y === undefined) break;  // y new top of scanbeam\r\n\r\n      this.doIntersections(y);\r\n      this.doTopOfScanbeam(y);\r\n\r\n      ae = this.popHorz()\r\n      while (ae) {\r\n        this.doHorizontal(ae)\r\n        ae = this.popHorz()\r\n      }\r\n    }\r\n    if (this._succeeded) this.processHorzJoins();\r\n  }\r\n\r\n  private doIntersections(topY: number): void {\r\n    if (this.buildIntersectList(topY)) {\r\n      this.processIntersectList();\r\n      this.disposeIntersectNodes();\r\n    }\r\n  }\r\n\r\n  private disposeIntersectNodes(): void {\r\n    this._intersectList.length = 0\r\n  }\r\n\r\n  private addNewIntersectNode(ae1: Active, ae2: Active, topY: number): void {\r\n    const result = InternalClipper.getIntersectPt(ae1.bot, ae1.top, ae2.bot, ae2.top)\r\n    let ip: IPoint64 = result.ip\r\n    if (!result.success) {\r\n      ip = new Point64(ae1.curX, topY);\r\n    }\r\n\r\n    if (ip.y > this._currentBotY || ip.y < topY) {\r\n      const absDx1: number = Math.abs(ae1.dx);\r\n      const absDx2: number = Math.abs(ae2.dx);\r\n      if (absDx1 > 100 && absDx2 > 100) {\r\n        if (absDx1 > absDx2) {\r\n          ip = InternalClipper.getClosestPtOnSegment(ip, ae1.bot, ae1.top);\r\n        } else {\r\n          ip = InternalClipper.getClosestPtOnSegment(ip, ae2.bot, ae2.top);\r\n        }\r\n      } else if (absDx1 > 100) {\r\n        ip = InternalClipper.getClosestPtOnSegment(ip, ae1.bot, ae1.top);\r\n      } else if (absDx2 > 100) {\r\n        ip = InternalClipper.getClosestPtOnSegment(ip, ae2.bot, ae2.top);\r\n      } else {\r\n        if (ip.y < topY) {\r\n          ip.y = topY;\r\n        } else {\r\n          ip.y = this._currentBotY;\r\n        }\r\n        if (absDx1 < absDx2) {\r\n          ip.x = ClipperBase.topX(ae1, ip.y);\r\n        } else {\r\n          ip.x = ClipperBase.topX(ae2, ip.y);\r\n        }\r\n      }\r\n    }\r\n    const node: IntersectNode = new IntersectNode(ip, ae1, ae2);\r\n    this._intersectList.push(node);\r\n  }\r\n\r\n  private static extractFromSEL(ae: Active): Active | undefined {\r\n    const res: Active | undefined = ae.nextInSEL;\r\n    if (res) {\r\n      res.prevInSEL = ae.prevInSEL;\r\n    }\r\n    ae.prevInSEL!.nextInSEL = res;\r\n    return res;\r\n  }\r\n\r\n  private static insert1Before2InSEL(ae1: Active, ae2: Active): void {\r\n    ae1.prevInSEL = ae2.prevInSEL;\r\n    if (ae1.prevInSEL) {\r\n      ae1.prevInSEL.nextInSEL = ae1;\r\n    }\r\n    ae1.nextInSEL = ae2;\r\n    ae2.prevInSEL = ae1;\r\n  }\r\n\r\n  private buildIntersectList(topY: number): boolean {\r\n    if (!this._actives || !this._actives.nextInAEL) return false;\r\n\r\n    // Calculate edge positions at the top of the current scanbeam, and from this\r\n    // we will determine the intersections required to reach these new positions.\r\n    this.adjustCurrXAndCopyToSEL(topY);\r\n\r\n    // Find all edge intersections in the current scanbeam using a stable merge\r\n    // sort that ensures only adjacent edges are intersecting. Intersect info is\r\n    // stored in FIntersectList ready to be processed in ProcessIntersectList.\r\n    // Re merge sorts see https://stackoverflow.com/a/46319131/359538\r\n\r\n    let left: Active | undefined = this._sel,\r\n      right: Active | undefined,\r\n      lEnd: Active | undefined,\r\n      rEnd: Active | undefined,\r\n      currBase: Active | undefined,\r\n      prevBase: Active | undefined,\r\n      tmp: Active | undefined;\r\n\r\n    while (left!.jump) {\r\n      prevBase = undefined;\r\n      while (left && left.jump) {\r\n        currBase = left;\r\n        right = left.jump;\r\n        lEnd = right;\r\n        rEnd = right!.jump;\r\n        left.jump = rEnd;\r\n        while (left !== lEnd && right !== rEnd) {\r\n          if (right!.curX < left!.curX) {\r\n            tmp = right!.prevInSEL!;\r\n            for (; ;) {\r\n              this.addNewIntersectNode(tmp, right!, topY);\r\n              if (tmp === left) break;\r\n              tmp = tmp.prevInSEL!;\r\n            }\r\n\r\n            tmp = right;\r\n            right = ClipperBase.extractFromSEL(tmp!);\r\n            lEnd = right;\r\n            ClipperBase.insert1Before2InSEL(tmp!, left!);\r\n            if (left === currBase) {\r\n              currBase = tmp;\r\n              currBase!.jump = rEnd;\r\n              if (prevBase === undefined) this._sel = currBase;\r\n              else prevBase.jump = currBase;\r\n            }\r\n          } else {\r\n            left = left!.nextInSEL;\r\n          }\r\n        }\r\n\r\n        prevBase = currBase;\r\n        left = rEnd;\r\n      }\r\n      left = this._sel;\r\n    }\r\n\r\n    return this._intersectList.length > 0;\r\n  }\r\n\r\n  private processIntersectList(): void {\r\n    // We now have a list of intersections required so that edges will be\r\n    // correctly positioned at the top of the scanbeam. However, it's important\r\n    // that edge intersections are processed from the bottom up, but it's also\r\n    // crucial that intersections only occur between adjacent edges.\r\n\r\n    // First we do a quicksort so intersections proceed in a bottom up order ...\r\n    this._intersectList.sort((a, b) => {\r\n      if (a.pt.y === b.pt.y) {\r\n        if (a.pt.x === b.pt.x) return 0;\r\n        return (a.pt.x < b.pt.x) ? -1 : 1;\r\n      }\r\n      return (a.pt.y > b.pt.y) ? -1 : 1;\r\n    });\r\n\r\n    // Now as we process these intersections, we must sometimes adjust the order\r\n    // to ensure that intersecting edges are always adjacent ...\r\n    for (let i = 0; i < this._intersectList.length; ++i) {\r\n      if (!ClipperBase.edgesAdjacentInAEL(this._intersectList[i])) {\r\n        let j = i + 1;\r\n        while (!ClipperBase.edgesAdjacentInAEL(this._intersectList[j])) j++;\r\n        // swap\r\n        [this._intersectList[j], this._intersectList[i]] =\r\n          [this._intersectList[i], this._intersectList[j]];\r\n      }\r\n\r\n      const node = this._intersectList[i];\r\n      this.intersectEdges(node.edge1, node.edge2, node.pt);\r\n      this.swapPositionsInAEL(node.edge1, node.edge2);\r\n\r\n      node.edge1.curX = node.pt.x;\r\n      node.edge2.curX = node.pt.x;\r\n      this.checkJoinLeft(node.edge2, node.pt, true);\r\n      this.checkJoinRight(node.edge1, node.pt, true);\r\n    }\r\n  }\r\n\r\n  private swapPositionsInAEL(ae1: Active, ae2: Active): void {\r\n    // preconditon: ae1 must be immediately to the left of ae2\r\n    const next: Active | undefined = ae2.nextInAEL;\r\n    if (next) next.prevInAEL = ae1;\r\n    const prev: Active | undefined = ae1.prevInAEL;\r\n    if (prev) prev.nextInAEL = ae2;\r\n    ae2.prevInAEL = prev;\r\n    ae2.nextInAEL = ae1;\r\n    ae1.prevInAEL = ae2;\r\n    ae1.nextInAEL = next;\r\n    if (!ae2.prevInAEL) this._actives = ae2;\r\n  }\r\n\r\n  private static resetHorzDirection(horz: Active, vertexMax: Vertex | undefined): { isLeftToRight: boolean, leftX: number, rightX: number } {\r\n    let leftX, rightX\r\n\r\n    if (horz.bot.x === horz.top.x) {\r\n      // the horizontal edge is going nowhere ...\r\n      leftX = horz.curX;\r\n      rightX = horz.curX;\r\n      let ae: Active | undefined = horz.nextInAEL;\r\n      while (ae && ae.vertexTop !== vertexMax)\r\n        ae = ae.nextInAEL;\r\n      return { isLeftToRight: ae !== undefined, leftX, rightX }\r\n    }\r\n\r\n    if (horz.curX < horz.top.x) {\r\n      leftX = horz.curX;\r\n      rightX = horz.top.x;\r\n      return { isLeftToRight: true, leftX, rightX }\r\n    }\r\n    leftX = horz.top.x;\r\n    rightX = horz.curX;\r\n    return { isLeftToRight: false, leftX, rightX } // right to left\r\n  }\r\n\r\n  private static horzIsSpike(horz: Active): boolean {\r\n    const nextPt: IPoint64 = ClipperBase.nextVertex(horz).pt;\r\n    return (horz.bot.x < horz.top.x) !== (horz.top.x < nextPt.x);\r\n  }\r\n\r\n  private static trimHorz(horzEdge: Active, preserveCollinear: boolean): void {\r\n    let wasTrimmed = false;\r\n    let pt: IPoint64 = ClipperBase.nextVertex(horzEdge).pt;\r\n\r\n    while (pt.y === horzEdge.top.y) {\r\n      // always trim 180 deg. spikes (in closed paths)\r\n      // but otherwise break if preserveCollinear = true\r\n      if (preserveCollinear &&\r\n        (pt.x < horzEdge.top.x) !== (horzEdge.bot.x < horzEdge.top.x)) {\r\n        break;\r\n      }\r\n\r\n      horzEdge.vertexTop = ClipperBase.nextVertex(horzEdge);\r\n      horzEdge.top = pt;\r\n      wasTrimmed = true;\r\n      if (ClipperBase.isMaximaActive(horzEdge)) break;\r\n      pt = ClipperBase.nextVertex(horzEdge).pt;\r\n    }\r\n    if (wasTrimmed) ClipperBase.setDx(horzEdge); // +/-infinity\r\n  }\r\n\r\n  private addToHorzSegList(op: OutPt): void {\r\n    if (op.outrec.isOpen) return;\r\n    this._horzSegList.push(new HorzSegment(op));\r\n  }\r\n\r\n  private getLastOp(hotEdge: Active): OutPt {\r\n    const outrec: OutRec = hotEdge.outrec!;\r\n    return (hotEdge === outrec.frontEdge) ?\r\n      outrec.pts! : outrec.pts!.next!;\r\n  }\r\n\r\n  /*******************************************************************************\r\n  * Notes: Horizontal edges (HEs) at scanline intersections (i.e. at the top or    *\r\n  * bottom of a scanbeam) are processed as if layered.The order in which HEs     *\r\n  * are processed doesn't matter. HEs intersect with the bottom vertices of      *\r\n  * other HEs[#] and with non-horizontal edges [*]. Once these intersections     *\r\n  * are completed, intermediate HEs are 'promoted' to the next edge in their     *\r\n  * bounds, and they in turn may be intersected[%] by other HEs.                 *\r\n  *                                                                              *\r\n  * eg: 3 horizontals at a scanline:    /   |                     /           /  *\r\n  *              |                     /    |     (HE3)o ========%========== o   *\r\n  *              o ======= o(HE2)     /     |         /         /                *\r\n  *          o ============#=========*======*========#=========o (HE1)           *\r\n  *         /              |        /       |       /                            *\r\n  *******************************************************************************/\r\n  private doHorizontal(horz: Active): void {\r\n    let pt: IPoint64;\r\n    const horzIsOpen = ClipperBase.isOpen(horz);\r\n    const Y = horz.bot.y;\r\n\r\n    const vertex_max: Vertex | undefined = horzIsOpen ?\r\n      ClipperBase.getCurrYMaximaVertex_Open(horz) :\r\n      ClipperBase.getCurrYMaximaVertex(horz);\r\n\r\n    // remove 180 deg.spikes and also simplify\r\n    // consecutive horizontals when PreserveCollinear = true\r\n    if (vertex_max && !horzIsOpen && vertex_max !== horz.vertexTop)\r\n      ClipperBase.trimHorz(horz, this.preserveCollinear);\r\n\r\n    let { isLeftToRight, leftX, rightX } =\r\n      ClipperBase.resetHorzDirection(horz, vertex_max);\r\n\r\n    if (ClipperBase.isHotEdgeActive(horz)) {\r\n      const op = ClipperBase.addOutPt(horz, new Point64(horz.curX, Y));\r\n      this.addToHorzSegList(op);\r\n    }\r\n\r\n    for (; ;) {\r\n      // loops through consec. horizontal edges (if open)\r\n      let ae: Active | undefined = isLeftToRight ? horz.nextInAEL : horz.prevInAEL;\r\n\r\n      while (ae) {\r\n        if (ae.vertexTop === vertex_max) {\r\n          // do this first!!\r\n          if (ClipperBase.isHotEdgeActive(horz) && ClipperBase.isJoined(ae)) this.split(ae, ae.top);\r\n\r\n          if (ClipperBase.isHotEdgeActive(horz)) {\r\n            while (horz.vertexTop !== vertex_max) {\r\n              ClipperBase.addOutPt(horz, horz.top);\r\n              this.updateEdgeIntoAEL(horz);\r\n            }\r\n            if (isLeftToRight)\r\n              this.addLocalMaxPoly(horz, ae, horz.top);\r\n            else\r\n              this.addLocalMaxPoly(ae, horz, horz.top);\r\n          }\r\n          this.deleteFromAEL(ae);\r\n          this.deleteFromAEL(horz);\r\n          return;\r\n        }\r\n\r\n        // if horzEdge is a maxima, keep going until we reach\r\n        // its maxima pair, otherwise check for break conditions\r\n        if (vertex_max !== horz.vertexTop || ClipperBase.isOpenEndActive(horz)) {\r\n          // otherwise stop when 'ae' is beyond the end of the horizontal line\r\n          if ((isLeftToRight && ae.curX > rightX) || (!isLeftToRight && ae.curX < leftX)) break;\r\n\r\n          if (ae.curX === horz.top.x && !ClipperBase.isHorizontal(ae)) {\r\n            pt = ClipperBase.nextVertex(horz).pt;\r\n\r\n            // to maximize the possibility of putting open edges into\r\n            // solutions, we'll only break if it's past HorzEdge's end\r\n            if (ClipperBase.isOpen(ae) && !ClipperBase.isSamePolyType(ae, horz) && !ClipperBase.isHotEdgeActive(ae)) {\r\n              if ((isLeftToRight && (ClipperBase.topX(ae, pt.y) > pt.x)) || (!isLeftToRight && (ClipperBase.topX(ae, pt.y) < pt.x))) break;\r\n            }\r\n            // otherwise for edges at horzEdge's end, only stop when horzEdge's\r\n            // outslope is greater than e's slope when heading right or when\r\n            // horzEdge's outslope is less than e's slope when heading left.\r\n            else if ((isLeftToRight && (ClipperBase.topX(ae, pt.y) >= pt.x)) || (!isLeftToRight && (ClipperBase.topX(ae, pt.y) <= pt.x))) break;\r\n          }\r\n        }\r\n\r\n        pt = new Point64(ae.curX, Y);\r\n\r\n        if (isLeftToRight) {\r\n          this.intersectEdges(horz, ae, pt);\r\n          this.swapPositionsInAEL(horz, ae);\r\n          horz.curX = ae.curX;\r\n          ae = horz.nextInAEL;\r\n        } else {\r\n          this.intersectEdges(ae, horz, pt);\r\n          this.swapPositionsInAEL(ae, horz);\r\n          horz.curX = ae.curX;\r\n          ae = horz.prevInAEL;\r\n        }\r\n\r\n        if (ClipperBase.isHotEdgeActive(horz))\r\n          this.addToHorzSegList(this.getLastOp(horz));\r\n      } // we've reached the end of this horizontal\r\n\r\n      // check if we've finished looping\r\n      // through consecutive horizontals\r\n      if (horzIsOpen && ClipperBase.isOpenEndActive(horz)) { // ie open at top\r\n        if (ClipperBase.isHotEdgeActive(horz)) {\r\n          ClipperBase.addOutPt(horz, horz.top);\r\n          if (ClipperBase.isFront(horz))\r\n            horz.outrec!.frontEdge = undefined;\r\n          else\r\n            horz.outrec!.backEdge = undefined;\r\n          horz.outrec = undefined;\r\n        }\r\n        this.deleteFromAEL(horz);\r\n        return;\r\n      } else if (ClipperBase.nextVertex(horz).pt.y !== horz.top.y)\r\n        break;\r\n\r\n      // still more horizontals in bound to process ...\r\n      if (ClipperBase.isHotEdgeActive(horz)) {\r\n        ClipperBase.addOutPt(horz, horz.top);\r\n      }\r\n\r\n      this.updateEdgeIntoAEL(horz);\r\n\r\n      if (this.preserveCollinear && !horzIsOpen && ClipperBase.horzIsSpike(horz)) {\r\n        ClipperBase.trimHorz(horz, true);\r\n      }\r\n\r\n      const result = ClipperBase.resetHorzDirection(horz, vertex_max);\r\n      isLeftToRight = result.isLeftToRight\r\n      leftX = result.leftX\r\n      rightX = result.rightX\r\n    }\r\n\r\n    if (ClipperBase.isHotEdgeActive(horz)) {\r\n      const op = ClipperBase.addOutPt(horz, horz.top);\r\n      this.addToHorzSegList(op);\r\n    }\r\n\r\n    this.updateEdgeIntoAEL(horz);\r\n  }\r\n\r\n  private doTopOfScanbeam(y: number): void {\r\n    this._sel = undefined; // _sel is reused to flag horizontals (see pushHorz below)\r\n    let ae: Active | undefined = this._actives;\r\n\r\n    while (ae) {\r\n      // NB 'ae' will never be horizontal here\r\n      if (ae.top.y === y) {\r\n        ae.curX = ae.top.x;\r\n\r\n        if (ClipperBase.isMaximaActive(ae)) {\r\n          ae = this.doMaxima(ae); // TOP OF BOUND (MAXIMA)\r\n          continue;\r\n        }\r\n\r\n        // INTERMEDIATE VERTEX ...\r\n        if (ClipperBase.isHotEdgeActive(ae))\r\n          ClipperBase.addOutPt(ae, ae.top);\r\n\r\n        this.updateEdgeIntoAEL(ae);\r\n\r\n        if (ClipperBase.isHorizontal(ae))\r\n          this.pushHorz(ae); // horizontals are processed later\r\n      } else { // i.e. not the top of the edge\r\n        ae.curX = ClipperBase.topX(ae, y);\r\n      }\r\n\r\n      ae = ae.nextInAEL;\r\n    }\r\n  }\r\n\r\n  private doMaxima(ae: Active): Active | undefined {\r\n    const prevE: Active | undefined = ae.prevInAEL\r\n    let nextE: Active | undefined = ae.nextInAEL\r\n\r\n    if (ClipperBase.isOpenEndActive(ae)) {\r\n      if (ClipperBase.isHotEdgeActive(ae)) ClipperBase.addOutPt(ae, ae.top);\r\n      if (!ClipperBase.isHorizontal(ae)) {\r\n        if (ClipperBase.isHotEdgeActive(ae)) {\r\n          if (ClipperBase.isFront(ae))\r\n            ae.outrec!.frontEdge = undefined;\r\n          else\r\n            ae.outrec!.backEdge = undefined;\r\n          ae.outrec = undefined;\r\n        }\r\n        this.deleteFromAEL(ae);\r\n      }\r\n      return nextE;\r\n    }\r\n\r\n    const maxPair: Active | undefined = ClipperBase.getMaximaPair(ae);\r\n    if (!maxPair) return nextE; // eMaxPair is horizontal\r\n\r\n    if (ClipperBase.isJoined(ae)) this.split(ae, ae.top);\r\n    if (ClipperBase.isJoined(maxPair)) this.split(maxPair, maxPair.top);\r\n\r\n    // only non-horizontal maxima here.\r\n    // process any edges between maxima pair ...\r\n    while (nextE !== maxPair) {\r\n      this.intersectEdges(ae, nextE!, ae.top);\r\n      this.swapPositionsInAEL(ae, nextE!);\r\n      nextE = ae.nextInAEL\r\n    }\r\n\r\n    if (ClipperBase.isOpen(ae)) {\r\n      if (ClipperBase.isHotEdgeActive(ae))\r\n        this.addLocalMaxPoly(ae, maxPair, ae.top);\r\n      this.deleteFromAEL(maxPair);\r\n      this.deleteFromAEL(ae);\r\n      return (prevE ? prevE.nextInAEL : this._actives);\r\n    }\r\n\r\n    // here ae.nextInAel == ENext == EMaxPair ...\r\n    if (ClipperBase.isHotEdgeActive(ae))\r\n      this.addLocalMaxPoly(ae, maxPair, ae.top);\r\n\r\n    this.deleteFromAEL(ae);\r\n    this.deleteFromAEL(maxPair);\r\n    return (prevE ? prevE.nextInAEL : this._actives);\r\n  }\r\n\r\n  private static isJoined(e: Active): boolean {\r\n    return e.joinWith !== JoinWith.None;\r\n  }\r\n\r\n  private split(e: Active, currPt: IPoint64): void {\r\n    if (e.joinWith === JoinWith.Right) {\r\n      e.joinWith = JoinWith.None;\r\n      e.nextInAEL!.joinWith = JoinWith.None;\r\n      this.addLocalMinPoly(e, e.nextInAEL!, currPt, true);\r\n    } else {\r\n      e.joinWith = JoinWith.None;\r\n      e.prevInAEL!.joinWith = JoinWith.None;\r\n      this.addLocalMinPoly(e.prevInAEL!, e, currPt, true);\r\n    }\r\n  }\r\n\r\n  private checkJoinLeft(e: Active, pt: IPoint64, checkCurrX: boolean = false): void {\r\n    const prev = e.prevInAEL;\r\n    if (!prev || ClipperBase.isOpen(e) || ClipperBase.isOpen(prev) ||\r\n      !ClipperBase.isHotEdgeActive(e) || !ClipperBase.isHotEdgeActive(prev)) return;\r\n\r\n    if ((pt.y < e.top.y + 2 || pt.y < prev.top.y + 2) && // avoid trivial joins\r\n      ((e.bot.y > pt.y) || (prev.bot.y > pt.y))) return; // (#490)\r\n\r\n    if (checkCurrX) {\r\n      if (Clipper.perpendicDistFromLineSqrd(pt, prev.bot, prev.top) > 0.25) return;\r\n    } else if (e.curX !== prev.curX) return;\r\n    if (InternalClipper.crossProduct(e.top, pt, prev.top) !== 0) return;\r\n\r\n    if (e.outrec!.idx === prev.outrec!.idx)\r\n      this.addLocalMaxPoly(prev, e, pt);\r\n    else if (e.outrec!.idx < prev.outrec!.idx)\r\n      ClipperBase.joinOutrecPaths(e, prev);\r\n    else\r\n      ClipperBase.joinOutrecPaths(prev, e);\r\n    prev.joinWith = JoinWith.Right;\r\n    e.joinWith = JoinWith.Left;\r\n  }\r\n\r\n  private checkJoinRight(e: Active, pt: IPoint64, checkCurrX: boolean = false): void {\r\n    const next = e.nextInAEL;\r\n    if (ClipperBase.isOpen(e) || !ClipperBase.isHotEdgeActive(e) || ClipperBase.isJoined(e) ||\r\n      !next || ClipperBase.isOpen(next) || !ClipperBase.isHotEdgeActive(next)) return;\r\n\r\n    if ((pt.y < e.top.y + 2 || pt.y < next.top.y + 2) && // avoid trivial joins\r\n      ((e.bot.y > pt.y) || (next.bot.y > pt.y))) return; // (#490)\r\n\r\n    if (checkCurrX) {\r\n      if (Clipper.perpendicDistFromLineSqrd(pt, next.bot, next.top) > 0.25) return;\r\n    } else if (e.curX !== next.curX) return;\r\n    if (InternalClipper.crossProduct(e.top, pt, next.top) !== 0) return;\r\n\r\n    if (e.outrec!.idx === next.outrec!.idx)\r\n      this.addLocalMaxPoly(e, next, pt);\r\n    else if (e.outrec!.idx < next.outrec!.idx)\r\n      ClipperBase.joinOutrecPaths(e, next);\r\n    else\r\n      ClipperBase.joinOutrecPaths(next, e);\r\n    e.joinWith = JoinWith.Right;\r\n    next.joinWith = JoinWith.Left;\r\n  }\r\n\r\n  private static fixOutRecPts(outrec: OutRec): void {\r\n    let op = outrec.pts!;\r\n    do {\r\n      op!.outrec = outrec;\r\n      op = op.next!;\r\n    } while (op !== outrec.pts);\r\n  }\r\n\r\n  private static setHorzSegHeadingForward(hs: HorzSegment, opP: OutPt, opN: OutPt): boolean {\r\n    if (opP.pt.x === opN.pt.x) return false;\r\n    if (opP.pt.x < opN.pt.x) {\r\n      hs.leftOp = opP;\r\n      hs.rightOp = opN;\r\n      hs.leftToRight = true;\r\n    } else {\r\n      hs.leftOp = opN;\r\n      hs.rightOp = opP;\r\n      hs.leftToRight = false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private static updateHorzSegment(hs: HorzSegment): boolean {\r\n    const op = hs.leftOp;\r\n    const outrec = this.getRealOutRec(op.outrec)!;\r\n    const outrecHasEdges = outrec.frontEdge !== undefined;\r\n    const curr_y = op.pt.y;\r\n    let opP = op, opN = op;\r\n\r\n    if (outrecHasEdges) {\r\n      const opA = outrec.pts!, opZ = opA.next!;\r\n      while (opP !== opZ && opP.prev.pt.y === curr_y)\r\n        opP = opP.prev;\r\n      while (opN !== opA && opN.next!.pt.y === curr_y)\r\n        opN = opN.next!;\r\n    } else {\r\n      while (opP.prev !== opN && opP.prev.pt.y === curr_y)\r\n        opP = opP.prev;\r\n      while (opN.next !== opP && opN.next!.pt.y === curr_y)\r\n        opN = opN.next!;\r\n    }\r\n\r\n    const result = this.setHorzSegHeadingForward(hs, opP, opN) && hs.leftOp!.horz === undefined;\r\n\r\n    if (result)\r\n      hs.leftOp!.horz = hs;\r\n    else\r\n      hs.rightOp = undefined; // (for sorting)\r\n\r\n    return result;\r\n  }\r\n\r\n  private static duplicateOp(op: OutPt, insert_after: boolean): OutPt {\r\n    const result = new OutPt(op.pt, op.outrec);\r\n    if (insert_after) {\r\n      result.next = op.next;\r\n      result.next!.prev = result;\r\n      result.prev = op;\r\n      op.next = result;\r\n    } else {\r\n      result.prev = op.prev;\r\n      result.prev.next = result;\r\n      result.next = op;\r\n      op.prev = result;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private convertHorzSegsToJoins(): void {\r\n    let k = 0;\r\n    for (const hs of this._horzSegList) {\r\n      if (ClipperBase.updateHorzSegment(hs)) k++;\r\n    }\r\n    if (k < 2) return;\r\n    this._horzSegList.sort((hs1, hs2) => {\r\n      if (!hs1 || !hs2) return 0;\r\n      if (!hs1.rightOp) {\r\n        return !hs2.rightOp ? 0 : 1;\r\n      } else if (!hs2.rightOp)\r\n        return -1;\r\n      else\r\n        return hs1.leftOp!.pt.x - hs2.leftOp!.pt.x;\r\n    });\r\n\r\n    for (let i = 0; i < k - 1; i++) {\r\n      const hs1 = this._horzSegList[i];\r\n      // for each HorzSegment, find others that overlap\r\n      for (let j = i + 1; j < k; j++) {\r\n        const hs2 = this._horzSegList[j];\r\n        if (hs2.leftOp!.pt.x >= hs1.rightOp!.pt.x ||\r\n          hs2.leftToRight === hs1.leftToRight ||\r\n          hs2.rightOp!.pt.x <= hs1.leftOp!.pt.x) continue;\r\n\r\n        const curr_y = hs1.leftOp.pt.y;\r\n\r\n        if (hs1.leftToRight) {\r\n          while (hs1.leftOp.next!.pt.y === curr_y &&\r\n            hs1.leftOp.next!.pt.x <= hs2.leftOp.pt.x) {\r\n            hs1.leftOp = hs1.leftOp.next!;\r\n          }\r\n          while (hs2.leftOp.prev.pt.y === curr_y &&\r\n            hs2.leftOp.prev.pt.x <= hs1.leftOp.pt.x) {\r\n            hs2.leftOp = hs2.leftOp.prev;\r\n          }\r\n          const join = new HorzJoin(\r\n            ClipperBase.duplicateOp(hs1.leftOp, true),\r\n            ClipperBase.duplicateOp(hs2.leftOp, false)\r\n          );\r\n          this._horzJoinList.push(join);\r\n        } else {\r\n          while (hs1.leftOp.prev.pt.y === curr_y &&\r\n            hs1.leftOp.prev.pt.x <= hs2.leftOp.pt.x) {\r\n            hs1.leftOp = hs1.leftOp.prev;\r\n          }\r\n          while (hs2.leftOp.next!.pt.y === curr_y &&\r\n            hs2.leftOp.next!.pt.x <= hs1.leftOp.pt.x) {\r\n            hs2.leftOp = hs2.leftOp.next!;\r\n          }\r\n          const join = new HorzJoin(\r\n            ClipperBase.duplicateOp(hs2.leftOp, true),\r\n            ClipperBase.duplicateOp(hs1.leftOp, false)\r\n          );\r\n          this._horzJoinList.push(join);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static getCleanPath(op: OutPt): Path64 {\r\n    const result = new Path64();\r\n    let op2 = op;\r\n    while (op2.next !== op &&\r\n      ((op2.pt.x === op2.next!.pt.x && op2.pt.x === op2.prev.pt.x) ||\r\n        (op2.pt.y === op2.next!.pt.y && op2.pt.y === op2.prev.pt.y))) {\r\n      op2 = op2.next!;\r\n    }\r\n    result.push(op2.pt);\r\n    let prevOp = op2;\r\n    op2 = op2.next!;\r\n\r\n    while (op2 !== op) {\r\n      if ((op2.pt.x !== op2.next!.pt.x || op2.pt.x !== prevOp.pt.x) &&\r\n        (op2.pt.y !== op2.next!.pt.y || op2.pt.y !== prevOp.pt.y)) {\r\n        result.push(op2.pt);\r\n        prevOp = op2;\r\n      }\r\n      op2 = op2.next!;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private static pointInOpPolygon(pt: IPoint64, op: OutPt): PointInPolygonResult {\r\n    if (op === op.next || op.prev === op.next)\r\n      return PointInPolygonResult.IsOutside;\r\n\r\n    let op2 = op;\r\n    do {\r\n      if (op.pt.y !== pt.y) break;\r\n      op = op.next!;\r\n    } while (op !== op2);\r\n    if (op.pt.y === pt.y)  // not a proper polygon\r\n      return PointInPolygonResult.IsOutside;\r\n\r\n    let isAbove = op.pt.y < pt.y\r\n    const startingAbove = isAbove;\r\n    let val = 0;\r\n\r\n    op2 = op.next!;\r\n    while (op2 !== op) {\r\n      if (isAbove)\r\n        while (op2 !== op && op2.pt.y < pt.y) op2 = op2.next!;\r\n      else\r\n        while (op2 !== op && op2.pt.y > pt.y) op2 = op2.next!;\r\n      if (op2 === op) break;\r\n\r\n      if (op2.pt.y === pt.y) {\r\n        if (op2.pt.x === pt.x || (op2.pt.y === op2.prev.pt.y &&\r\n          (pt.x < op2.prev.pt.x) !== (pt.x < op2.pt.x)))\r\n          return PointInPolygonResult.IsOn;\r\n        op2 = op2.next!;\r\n        if (op2 === op) break;\r\n        continue;\r\n      }\r\n\r\n      if (op2.pt.x <= pt.x || op2.prev.pt.x <= pt.x) {\r\n        if (op2.prev.pt.x < pt.x && op2.pt.x < pt.x)\r\n          val = 1 - val;\r\n        else {\r\n          const d = InternalClipper.crossProduct(op2.prev.pt, op2.pt, pt);\r\n          if (d === 0) return PointInPolygonResult.IsOn;\r\n          if ((d < 0) === isAbove) val = 1 - val;\r\n        }\r\n      }\r\n      isAbove = !isAbove;\r\n      op2 = op2.next!;\r\n    }\r\n\r\n    if (isAbove !== startingAbove) {\r\n      const d = InternalClipper.crossProduct(op2.prev.pt, op2.pt, pt);\r\n      if (d === 0) return PointInPolygonResult.IsOn;\r\n      if ((d < 0) === isAbove) val = 1 - val;\r\n    }\r\n\r\n    if (val === 0) return PointInPolygonResult.IsOutside;\r\n    else return PointInPolygonResult.IsInside;\r\n  }\r\n\r\n  private static path1InsidePath2(op1: OutPt, op2: OutPt): boolean {\r\n    let result: PointInPolygonResult;\r\n    let outside_cnt = 0;\r\n    let op = op1;\r\n    do {\r\n      result = this.pointInOpPolygon(op.pt, op2);\r\n      if (result === PointInPolygonResult.IsOutside) ++outside_cnt;\r\n      else if (result === PointInPolygonResult.IsInside) --outside_cnt;\r\n      op = op.next!;\r\n    } while (op !== op1 && Math.abs(outside_cnt) < 2);\r\n    if (Math.abs(outside_cnt) > 1) return (outside_cnt < 0);\r\n\r\n    const mp = ClipperBase.getBoundsPath(this.getCleanPath(op1)).midPoint();\r\n    const path2 = this.getCleanPath(op2);\r\n    return InternalClipper.pointInPolygon(mp, path2) !== PointInPolygonResult.IsOutside;\r\n  }\r\n\r\n  private moveSplits(fromOr: OutRec, toOr: OutRec): void {\r\n    if (!fromOr.splits) return;\r\n    toOr.splits = toOr.splits || [];\r\n    for (const i of fromOr.splits) {\r\n      toOr.splits.push(i);\r\n    }\r\n    fromOr.splits = undefined;\r\n  }\r\n\r\n  private processHorzJoins(): void {\r\n    for (const j of this._horzJoinList) {\r\n      const or1 = ClipperBase.getRealOutRec(j.op1!.outrec)!;\r\n      let or2 = ClipperBase.getRealOutRec(j.op2!.outrec)!;\r\n\r\n      const op1b = j.op1!.next!;\r\n      const op2b = j.op2!.prev!;\r\n      j.op1!.next = j.op2!;\r\n      j.op2!.prev = j.op1!;\r\n      op1b.prev = op2b;\r\n      op2b.next = op1b;\r\n\r\n      if (or1 === or2) {\r\n        or2 = this.newOutRec();\r\n        or2.pts = op1b;\r\n        ClipperBase.fixOutRecPts(or2);\r\n\r\n        if (or1.pts!.outrec === or2) {\r\n          or1.pts = j.op1;\r\n          or1.pts!.outrec = or1;\r\n        }\r\n\r\n        if (this._using_polytree) {\r\n          if (ClipperBase.path1InsidePath2(or1.pts!, or2.pts)) {\r\n            const tmp = or1.pts;\r\n            or1.pts = or2.pts;\r\n            or2.pts = tmp;\r\n            ClipperBase.fixOutRecPts(or1);\r\n            ClipperBase.fixOutRecPts(or2);\r\n            or2.owner = or1.owner;\r\n          } else if (ClipperBase.path1InsidePath2(or2.pts, or1.pts!)) {\r\n            or2.owner = or1;\r\n          } else {\r\n            or2.owner = or1.owner;\r\n          }\r\n\r\n          or1.splits = or1.splits || [];\r\n          or1.splits.push(or2.idx);\r\n        } else {\r\n          or2.owner = or1;\r\n        }\r\n      } else {\r\n        or2.pts = undefined;\r\n        if (this._using_polytree) {\r\n          ClipperBase.setOwner(or2, or1);\r\n          this.moveSplits(or2, or1);\r\n        } else {\r\n          or2.owner = or1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static ptsReallyClose(pt1: IPoint64, pt2: IPoint64): boolean {\r\n    return (Math.abs(pt1.x - pt2.x) < 2) && (Math.abs(pt1.y - pt2.y) < 2);\r\n  }\r\n\r\n  private static isVerySmallTriangle(op: OutPt): boolean {\r\n    return op.next!.next === op.prev &&\r\n      (this.ptsReallyClose(op.prev.pt, op.next!.pt) ||\r\n        this.ptsReallyClose(op.pt, op.next!.pt) ||\r\n        this.ptsReallyClose(op.pt, op.prev.pt));\r\n  }\r\n\r\n\r\n  private static isValidClosedPath(op: OutPt | undefined): boolean {\r\n    return op !== undefined && op.next !== op &&\r\n      (op.next !== op.prev || !this.isVerySmallTriangle(op));\r\n  }\r\n\r\n  private static disposeOutPt(op: OutPt): OutPt | undefined {\r\n    const result = op.next === op ? undefined : op.next;\r\n    op.prev.next = op.next;\r\n    op.next!.prev = op.prev;\r\n    return result;\r\n  }\r\n\r\n  private cleanCollinear(outrec: OutRec | undefined): void {\r\n    outrec = ClipperBase.getRealOutRec(outrec);\r\n\r\n    if (outrec === undefined || outrec.isOpen) return;\r\n\r\n    if (!ClipperBase.isValidClosedPath(outrec.pts)) {\r\n      outrec.pts = undefined;\r\n      return;\r\n    }\r\n\r\n    let startOp: OutPt = outrec.pts!;\r\n    let op2: OutPt | undefined = startOp;\r\n    for (; ;) {\r\n      // NB if preserveCollinear == true, then only remove 180 deg. spikes\r\n      if (InternalClipper.crossProduct(op2!.prev.pt, op2!.pt, op2!.next!.pt) === 0 &&\r\n        (op2!.pt === op2!.prev.pt || op2!.pt === op2!.next!.pt || !this.preserveCollinear ||\r\n          InternalClipper.dotProduct(op2!.prev.pt, op2!.pt, op2!.next!.pt) < 0)) {\r\n\r\n        if (op2 === outrec.pts) {\r\n          outrec.pts = op2!.prev;\r\n        }\r\n\r\n        op2 = ClipperBase.disposeOutPt(op2!);\r\n        if (!ClipperBase.isValidClosedPath(op2)) {\r\n          outrec.pts = undefined;\r\n          return;\r\n        }\r\n        startOp = op2!;\r\n        continue;\r\n      }\r\n      op2 = op2!.next;\r\n      if (op2 === startOp) break;\r\n    }\r\n    this.fixSelfIntersects(outrec);\r\n  }\r\n\r\n  private doSplitOp(outrec: OutRec, splitOp: OutPt): void {\r\n    // splitOp.prev <=> splitOp &&\r\n    // splitOp.next <=> splitOp.next.next are intersecting\r\n    const prevOp: OutPt = splitOp.prev;\r\n    const nextNextOp: OutPt = splitOp.next!.next!;\r\n    outrec.pts = prevOp;\r\n\r\n    const ip: IPoint64 = InternalClipper.getIntersectPoint(\r\n      prevOp.pt, splitOp.pt, splitOp.next!.pt, nextNextOp.pt).ip;\r\n\r\n    const area1: number = ClipperBase.area(prevOp);\r\n    const absArea1: number = Math.abs(area1);\r\n\r\n    if (absArea1 < 2) {\r\n      outrec.pts = undefined;\r\n      return;\r\n    }\r\n\r\n    const area2: number = ClipperBase.areaTriangle(ip, splitOp.pt, splitOp.next!.pt);\r\n    const absArea2: number = Math.abs(area2);\r\n\r\n    // de-link splitOp and splitOp.next from the path\r\n    // while inserting the intersection point\r\n    if (ip === prevOp.pt || ip === nextNextOp.pt) {\r\n      nextNextOp.prev = prevOp;\r\n      prevOp.next = nextNextOp;\r\n    } else {\r\n      const newOp2 = new OutPt(ip, outrec);\r\n      newOp2.prev = prevOp;\r\n      newOp2.next = nextNextOp;\r\n      nextNextOp.prev = newOp2;\r\n      prevOp.next = newOp2;\r\n    }\r\n\r\n    // nb: area1 is the path's area *before* splitting, whereas area2 is\r\n    // the area of the triangle containing splitOp & splitOp.next.\r\n    // So the only way for these areas to have the same sign is if\r\n    // the split triangle is larger than the path containing prevOp or\r\n    // if there's more than one self=intersection.\r\n    if (absArea2 > 1 &&\r\n      (absArea2 > absArea1 || (area2 > 0) === (area1 > 0))) {\r\n\r\n      const newOutRec: OutRec = this.newOutRec();\r\n      newOutRec.owner = outrec.owner;\r\n      splitOp.outrec = newOutRec;\r\n      splitOp.next!.outrec = newOutRec;\r\n\r\n      const newOp: OutPt = new OutPt(ip, newOutRec);\r\n      newOp.prev = splitOp.next!;\r\n      newOp.next = splitOp;\r\n      newOutRec.pts = newOp;\r\n      splitOp.prev = newOp;\r\n      splitOp.next!.next = newOp;\r\n\r\n      if (this._using_polytree) {\r\n        if (ClipperBase.path1InsidePath2(prevOp, newOp)) {\r\n          newOutRec.splits = newOutRec.splits || [];\r\n          newOutRec.splits.push(outrec.idx);\r\n        } else {\r\n          outrec.splits = outrec.splits || [];\r\n          outrec.splits.push(newOutRec.idx);\r\n        }\r\n      }\r\n    }\r\n    // else { splitOp = undefined; splitOp.next = undefined; }\r\n  }\r\n\r\n  private fixSelfIntersects(outrec: OutRec): void {\r\n    let op2: OutPt = outrec.pts!;\r\n    for (; ;) {\r\n      if (op2.prev === op2.next!.next) break;\r\n      if (InternalClipper.segsIntersect(op2.prev.pt, op2.pt, op2.next!.pt, op2.next!.next!.pt)) {\r\n        this.doSplitOp(outrec, op2);\r\n        if (!outrec.pts) return;\r\n        op2 = outrec.pts;\r\n        continue;\r\n      } else {\r\n        op2 = op2.next!;\r\n      }\r\n      if (op2 === outrec.pts) break;\r\n    }\r\n  }\r\n\r\n  static buildPath(op: OutPt | undefined, reverse: boolean, isOpen: boolean, path: Path64): boolean {\r\n    if (op === undefined || op.next === op || (!isOpen && op.next === op.prev)) return false;\r\n    path.length = 0\r\n\r\n    let lastPt: IPoint64;\r\n    let op2: OutPt;\r\n    if (reverse) {\r\n      lastPt = op.pt;\r\n      op2 = op.prev;\r\n    } else {\r\n      op = op.next!;\r\n      lastPt = op.pt;\r\n      op2 = op.next!;\r\n    }\r\n    path.push(lastPt);\r\n\r\n    while (op2 !== op) {\r\n      if (op2.pt !== lastPt) {\r\n        lastPt = op2.pt;\r\n        path.push(lastPt);\r\n      }\r\n      if (reverse) {\r\n        op2 = op2.prev;\r\n      } else {\r\n        op2 = op2.next!;\r\n      }\r\n    }\r\n\r\n    if (path.length === 3 && this.isVerySmallTriangle(op2)) return false;\r\n    else return true;\r\n  }\r\n\r\n  protected buildPaths(solutionClosed: Paths64, solutionOpen: Paths64): boolean {\r\n    solutionClosed.length = 0\r\n    solutionOpen.length = 0\r\n\r\n    let i = 0;\r\n    while (i < this._outrecList.length) {\r\n      const outrec = this._outrecList[i++];\r\n      if (!outrec.pts) continue;\r\n\r\n      const path = new Path64();\r\n      if (outrec.isOpen) {\r\n        if (ClipperBase.buildPath(outrec.pts, this.reverseSolution, true, path)) {\r\n          solutionOpen.push(path);\r\n        }\r\n      } else {\r\n        this.cleanCollinear(outrec);\r\n        // closed paths should always return a Positive orientation\r\n        // except when reverseSolution == true\r\n        if (ClipperBase.buildPath(outrec.pts, this.reverseSolution, false, path)) {\r\n          solutionClosed.push(path);\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private static getBoundsPath(path: Path64): Rect64 {\r\n    if (path.length === 0) return new Rect64();\r\n    const result = Clipper.InvalidRect64;\r\n    for (const pt of path) {\r\n      if (pt.x < result.left) result.left = pt.x;\r\n      if (pt.x > result.right) result.right = pt.x;\r\n      if (pt.y < result.top) result.top = pt.y;\r\n      if (pt.y > result.bottom) result.bottom = pt.y;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private checkBounds(outrec: OutRec): boolean {\r\n    if (outrec.pts === undefined) return false;\r\n    if (!outrec.bounds.isEmpty()) return true;\r\n    this.cleanCollinear(outrec);\r\n    if (outrec.pts === undefined || !ClipperBase.buildPath(outrec.pts, this.reverseSolution, false, outrec.path))\r\n      return false;\r\n    outrec.bounds = ClipperBase.getBoundsPath(outrec.path);\r\n    return true;\r\n  }\r\n\r\n  private checkSplitOwner(outrec: OutRec, splits: number[] | undefined): boolean {\r\n    for (const i of splits!) {\r\n      const split: OutRec | undefined = ClipperBase.getRealOutRec(this._outrecList[i]);\r\n      if (split === undefined || split === outrec || split.recursiveSplit === outrec) continue;\r\n      split.recursiveSplit = outrec; //#599\r\n      if (split!.splits !== undefined && this.checkSplitOwner(outrec, split.splits)) return true;\r\n      if (ClipperBase.isValidOwner(outrec, split) &&\r\n        this.checkBounds(split) &&\r\n        split.bounds.containsRect(outrec.bounds) &&\r\n        ClipperBase.path1InsidePath2(outrec.pts!, split.pts!)) {\r\n        outrec.owner = split; //found in split\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private recursiveCheckOwners(outrec: OutRec, polypath: PolyPathBase): void {\r\n    // pre-condition: outrec will have valid bounds\r\n    // post-condition: if a valid path, outrec will have a polypath\r\n\r\n    if (outrec.polypath !== undefined || outrec.bounds.isEmpty()) return;\r\n\r\n    while (outrec.owner !== undefined) {\r\n      if (outrec.owner.splits !== undefined &&\r\n        this.checkSplitOwner(outrec, outrec.owner.splits)) break;\r\n      else if (outrec.owner.pts !== undefined && this.checkBounds(outrec.owner) &&\r\n        ClipperBase.path1InsidePath2(outrec.pts!, outrec.owner.pts!)) break;\r\n      outrec.owner = outrec.owner.owner;\r\n    }\r\n\r\n    if (outrec.owner !== undefined) {\r\n      if (outrec.owner.polypath === undefined)\r\n        this.recursiveCheckOwners(outrec.owner, polypath);\r\n      outrec.polypath = outrec.owner.polypath!.addChild(outrec.path);\r\n    } else {\r\n      outrec.polypath = polypath.addChild(outrec.path);\r\n    }\r\n  }\r\n\r\n  protected buildTree(polytree: PolyPathBase, solutionOpen: Paths64): void {\r\n    polytree.clear();\r\n    solutionOpen.length = 0\r\n\r\n    let i = 0;\r\n    while (i < this._outrecList.length) {\r\n      const outrec: OutRec = this._outrecList[i++];\r\n      if (outrec.pts === undefined) continue;\r\n\r\n      if (outrec.isOpen) {\r\n        const open_path = new Path64();\r\n        if (ClipperBase.buildPath(outrec.pts, this.reverseSolution, true, open_path))\r\n          solutionOpen.push(open_path);\r\n        continue;\r\n      }\r\n      if (this.checkBounds(outrec))\r\n        this.recursiveCheckOwners(outrec, polytree);\r\n    }\r\n  }\r\n\r\n  public getBounds(): Rect64 {\r\n    const bounds = Clipper.InvalidRect64;\r\n    for (const t of this._vertexList) {\r\n      let v = t;\r\n      do {\r\n        if (v.pt.x < bounds.left) bounds.left = v.pt.x;\r\n        if (v.pt.x > bounds.right) bounds.right = v.pt.x;\r\n        if (v.pt.y < bounds.top) bounds.top = v.pt.y;\r\n        if (v.pt.y > bounds.bottom) bounds.bottom = v.pt.y;\r\n        v = v.next!;\r\n      } while (v !== t);\r\n    }\r\n    return bounds.isEmpty() ? new Rect64(0, 0, 0, 0) : bounds;\r\n  }\r\n\r\n}\r\n\r\n\r\nexport class Clipper64 extends ClipperBase {\r\n\r\n  override addPath(path: Path64, polytype: PathType, isOpen: boolean = false): void {\r\n    super.addPath(path, polytype, isOpen);\r\n  }\r\n\r\n  addReusableData(reusableData: ReuseableDataContainer64): void {\r\n    super.addReuseableData(reusableData);\r\n  }\r\n\r\n  override addPaths(paths: Paths64, polytype: PathType, isOpen: boolean = false): void {\r\n    super.addPaths(paths, polytype, isOpen);\r\n  }\r\n\r\n  addSubjectPaths(paths: Paths64): void {\r\n    this.addPaths(paths, PathType.Subject);\r\n  }\r\n\r\n  addOpenSubjectPaths(paths: Paths64): void {\r\n    this.addPaths(paths, PathType.Subject, true);\r\n  }\r\n\r\n  addClipPaths(paths: Paths64): void {\r\n    this.addPaths(paths, PathType.Clip);\r\n  }\r\n\r\n  execute(clipType: ClipType, fillRule: FillRule, solutionClosed: Paths64, solutionOpen = new Paths64()): boolean {\r\n    solutionClosed.length = 0\r\n    solutionOpen.length = 0\r\n    try {\r\n      this.executeInternal(clipType, fillRule);\r\n      this.buildPaths(solutionClosed, solutionOpen);\r\n    } catch (error) {\r\n      this._succeeded = false;\r\n    }\r\n\r\n    this.clearSolutionOnly();\r\n    return this._succeeded;\r\n  }\r\n\r\n\r\n  executePolyTree(clipType: ClipType, fillRule: FillRule, polytree: PolyTree64, openPaths = new Paths64()): boolean {\r\n    polytree.clear();\r\n    openPaths.length = 0\r\n    this._using_polytree = true;\r\n    try {\r\n      this.executeInternal(clipType, fillRule);\r\n      this.buildTree(polytree, openPaths);\r\n    } catch (error) {\r\n      this._succeeded = false;\r\n    }\r\n\r\n    this.clearSolutionOnly();\r\n    return this._succeeded;\r\n  }\r\n\r\n}\r\n\r\nexport abstract class PolyPathBase {\r\n  protected _parent?: PolyPathBase;\r\n  children: Array<PolyPathBase> = [];\r\n  public polygon?: Path64;\r\n\r\n  get isHole(): boolean {\r\n    return this.getIsHole();\r\n  }\r\n\r\n  constructor(parent?: PolyPathBase) {\r\n    this._parent = parent;\r\n  }\r\n\r\n  private getLevel(): number {\r\n    let result = 0;\r\n    let pp: PolyPathBase | undefined = this._parent;\r\n    while (pp !== undefined) {\r\n      ++result;\r\n      pp = pp._parent;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  get level(): number {\r\n    return this.getLevel();\r\n  }\r\n\r\n  private getIsHole(): boolean {\r\n    const lvl = this.getLevel();\r\n    return lvl !== 0 && (lvl & 1) === 0;\r\n  }\r\n\r\n  get count(): number {\r\n    return this.children.length;\r\n  }\r\n\r\n  abstract addChild(p: Path64): PolyPathBase;\r\n\r\n  clear(): void {\r\n    this.children.length = 0\r\n  }\r\n\r\n  forEach = this.children.forEach\r\n\r\n} // end of PolyPathBase class\r\n\r\nexport class PolyPath64 extends PolyPathBase {\r\n\r\n  constructor(parent?: PolyPathBase) {\r\n    super(parent);\r\n  }\r\n\r\n  addChild(p: Path64): PolyPathBase {\r\n    const newChild = new PolyPath64(this);\r\n    (newChild as PolyPath64).polygon = p;\r\n    this.children.push(newChild);\r\n    return newChild;\r\n  }\r\n\r\n  get(index: number): PolyPath64 {\r\n    if (index < 0 || index >= this.children.length) {\r\n      throw new Error(\"InvalidOperationException\");\r\n    }\r\n    return this.children[index] as PolyPath64;\r\n  }\r\n\r\n  child(index: number): PolyPath64 {\r\n    if (index < 0 || index >= this.children.length) {\r\n      throw new Error(\"InvalidOperationException\");\r\n    }\r\n    return this.children[index] as PolyPath64;\r\n  }\r\n\r\n  area(): number {\r\n    let result = this.polygon ? Clipper.area(this.polygon) : 0;\r\n    for (const polyPathBase of this.children) {\r\n      const child = polyPathBase as PolyPath64;\r\n      result += child.area();\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n\r\nexport class PolyTree64 extends PolyPath64 { }\r\n\r\n\r\nexport class ClipperLibException extends Error {\r\n  constructor(description: string) {\r\n    super(description);\r\n  }\r\n}\r\n","/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  26 July 2023                                                    *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  Core structures and functions for the Clipper Library           *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n\r\nimport { PointInPolygonResult } from \"./engine\";\r\n\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\n\r\n// Note: all clipping operations except for Difference are commutative.\r\nexport enum ClipType {\r\n  None,\r\n  Intersection,\r\n  Union,\r\n  Difference,\r\n  Xor\r\n}\r\n\r\nexport enum PathType {\r\n  Subject,\r\n  Clip\r\n}\r\n\r\n// By far the most widely used filling rules for polygons are EvenOdd\r\n// and NonZero, sometimes called Alternate and Winding respectively.\r\n// https://en.wikipedia.org/wiki/Nonzero-rule\r\nexport enum FillRule {\r\n  EvenOdd,\r\n  NonZero,\r\n  Positive,\r\n  Negative\r\n}\r\n\r\n// PointInPolygon\r\nexport enum PipResult {\r\n  Inside,\r\n  Outside,\r\n  OnEdge\r\n}\r\n\r\nexport interface IPoint64 {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport class Path64 extends Array<IPoint64> { }\r\n\r\nexport class Paths64 extends Array<Path64> { }\r\n\r\n\r\n\r\nexport class Rect64 {\r\n  public left: number;\r\n  public top: number;\r\n  public right: number;\r\n  public bottom: number;\r\n\r\n  constructor(lOrIsValidOrRec?: number | boolean | Rect64, t?: number, r?: number, b?: number) {\r\n    if (typeof lOrIsValidOrRec === 'boolean') {\r\n      if (lOrIsValidOrRec) {\r\n        this.left = 0;\r\n        this.top = 0;\r\n        this.right = 0;\r\n        this.bottom = 0;\r\n      } else {\r\n        this.left = Number.MAX_SAFE_INTEGER;\r\n        this.top = Number.MAX_SAFE_INTEGER;\r\n        this.right = Number.MIN_SAFE_INTEGER;\r\n        this.bottom = Number.MIN_SAFE_INTEGER;\r\n      }\r\n    } else if (typeof lOrIsValidOrRec === 'number') {\r\n      this.left = lOrIsValidOrRec;\r\n      this.top = t as number;\r\n      this.right = r as number;\r\n      this.bottom = b as number;\r\n    } else {\r\n      this.left = lOrIsValidOrRec!.left;\r\n      this.top = lOrIsValidOrRec!.top;\r\n      this.right = lOrIsValidOrRec!.right;\r\n      this.bottom = lOrIsValidOrRec!.bottom;\r\n    }\r\n  }\r\n\r\n  public get width(): number {\r\n    return this.right - this.left;\r\n  }\r\n\r\n  public set width(value: number) {\r\n    this.right = this.left + value;\r\n  }\r\n\r\n  public get height(): number {\r\n    return this.bottom - this.top;\r\n  }\r\n\r\n  public set height(value: number) {\r\n    this.bottom = this.top + value;\r\n  }\r\n\r\n  public isEmpty(): boolean {\r\n    return this.bottom <= this.top || this.right <= this.left;\r\n  }\r\n\r\n  public midPoint(): Point64 {\r\n    return new Point64((this.left + this.right) / 2, (this.top + this.bottom) / 2);\r\n  }\r\n\r\n  public contains(pt: IPoint64): boolean {\r\n    return pt.x > this.left && pt.x < this.right && pt.y > this.top && pt.y < this.bottom;\r\n  }\r\n\r\n  public containsRect(rec: Rect64): boolean {\r\n    return rec.left >= this.left && rec.right <= this.right && rec.top >= this.top && rec.bottom <= this.bottom;\r\n  }\r\n\r\n  public intersects(rec: Rect64): boolean {\r\n    return (Math.max(this.left, rec.left) <= Math.min(this.right, rec.right)) &&\r\n      (Math.max(this.top, rec.top) <= Math.min(this.bottom, rec.bottom));\r\n  }\r\n\r\n  public asPath(): Path64 {\r\n    const result = new Path64();\r\n    result.push(new Point64(this.left, this.top));\r\n    result.push(new Point64(this.right, this.top));\r\n    result.push(new Point64(this.right, this.bottom));\r\n    result.push(new Point64(this.left, this.bottom));\r\n    return result;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\nexport class Point64 implements IPoint64 {\r\n  public x: number;\r\n  public y: number;\r\n\r\n  constructor(xOrPt?: number | Point64, yOrScale?: number) {\r\n    if (typeof xOrPt === 'number' && typeof yOrScale === 'number') {\r\n      this.x = Math.round(xOrPt);\r\n      this.y = Math.round(yOrScale);\r\n    } else  {\r\n      const pt = xOrPt as Point64\r\n      if (yOrScale !== undefined) {\r\n        this.x = Math.round(pt.x * yOrScale);\r\n        this.y = Math.round(pt.y * yOrScale);\r\n      } else {\r\n        this.x = pt.x;\r\n        this.y = pt.y;\r\n      }\r\n    //} else {\r\n    //  const pt = xOrPt as Point64\r\n    //  this.x = Math.round((<IPoint64>xOrPt).x * (yOrScale || 1));\r\n    //  this.y = Math.round((<IPoint64>xOrPt).y * (yOrScale || 1));\r\n    }\r\n  }\r\n\r\n  public static equals(lhs: Point64, rhs: Point64): boolean {\r\n    return lhs.x === rhs.x && lhs.y === rhs.y;\r\n  }\r\n\r\n  public static notEquals(lhs: Point64, rhs: Point64): boolean {\r\n    return lhs.x !== rhs.x || lhs.y !== rhs.y;\r\n  }\r\n\r\n  public static add(lhs: Point64, rhs: Point64): Point64 {\r\n    return new Point64(lhs.x + rhs.x, lhs.y + rhs.y);\r\n  }\r\n\r\n  public static subtract(lhs: Point64, rhs: Point64): Point64 {\r\n    return new Point64(lhs.x - rhs.x, lhs.y - rhs.y);\r\n  }\r\n\r\n  public toString(): string {\r\n    return `${this.x},${this.y} `;\r\n  }\r\n\r\n  public equals(obj: Point64): boolean {\r\n    if (obj instanceof Point64) {\r\n      return Point64.equals(this, obj);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //  public getHashCode(): number {\r\n  //    return this.X ^ this.Y;  // Simple XOR-based hash combination. Adjust if needed.\r\n  //  }\r\n}\r\n\r\nexport class InternalClipper {\r\n  static readonly MaxInt64: number = 9223372036854775807;\r\n  static readonly MaxCoord: number = InternalClipper.MaxInt64 / 4;\r\n  static readonly max_coord: number = InternalClipper.MaxCoord;\r\n  static readonly min_coord: number = -InternalClipper.MaxCoord;\r\n  static readonly Invalid64: number = InternalClipper.MaxInt64;\r\n\r\n  static readonly defaultArcTolerance: number = 0.25;\r\n  static readonly floatingPointTolerance: number = 1E-12;\r\n  static readonly defaultMinimumEdgeLength: number = 0.1;\r\n\r\n  private static readonly precision_range_error: string = \"Error: Precision is out of range.\";\r\n\r\n  static checkPrecision(precision: number): void {\r\n    if (precision < -8 || precision > 8)\r\n      throw new Error(this.precision_range_error);\r\n  }\r\n\r\n  static isAlmostZero(value: number): boolean {\r\n    return (Math.abs(value) <= this.floatingPointTolerance);\r\n  }\r\n\r\n  static crossProduct(pt1: IPoint64, pt2: IPoint64, pt3: IPoint64): number {\r\n    return ((pt2.x - pt1.x) * (pt3.y - pt2.y) - (pt2.y - pt1.y) * (pt3.x - pt2.x));\r\n  }\r\n\r\n  static dotProduct(pt1: IPoint64, pt2: IPoint64, pt3: IPoint64): number {\r\n    return ((pt2.x - pt1.x) * (pt3.x - pt2.x) + (pt2.y - pt1.y) * (pt3.y - pt2.y));\r\n  }\r\n\r\n  static checkCastInt64(val: number): number {\r\n    if ((val >= this.max_coord) || (val <= this.min_coord)) return this.Invalid64;\r\n    return Math.round(val);\r\n  }\r\n\r\n\r\n  public static getIntersectPt(ln1a: IPoint64, ln1b: IPoint64, ln2a: IPoint64, ln2b: IPoint64): { ip: IPoint64, success: boolean } {\r\n    const dy1 = ln1b.y - ln1a.y;\r\n    const dx1 = ln1b.x - ln1a.x;\r\n    const dy2 = ln2b.y - ln2a.y;\r\n    const dx2 = ln2b.x - ln2a.x;\r\n    const det = dy1 * dx2 - dy2 * dx1;\r\n\r\n    let ip: IPoint64;\r\n\r\n    if (det === 0.0) {\r\n      ip = new Point64(0, 0);\r\n      return { ip, success: false };\r\n    }\r\n\r\n    const t = ((ln1a.x - ln2a.x) * dy2 - (ln1a.y - ln2a.y) * dx2) / det;\r\n    if (t <= 0.0) ip = ln1a;\r\n    else if (t >= 1.0) ip = ln1b;\r\n    else ip = new Point64(ln1a.x + t * dx1, ln1a.y + t * dy1);\r\n    return { ip, success: true };\r\n  }\r\n\r\n  public static getIntersectPoint(ln1a: IPoint64, ln1b: IPoint64, ln2a: IPoint64, ln2b: IPoint64): { ip: IPoint64, success: boolean } {\r\n    const dy1 = ln1b.y - ln1a.y;\r\n    const dx1 = ln1b.x - ln1a.x;\r\n    const dy2 = ln2b.y - ln2a.y;\r\n    const dx2 = ln2b.x - ln2a.x;\r\n    const det = dy1 * dx2 - dy2 * dx1;\r\n\r\n    let ip: IPoint64;\r\n\r\n    if (det === 0.0) {\r\n      ip = new Point64(0, 0);\r\n      return { ip, success: false };\r\n    }\r\n\r\n    const t = ((ln1a.x - ln2a.x) * dy2 - (ln1a.y - ln2a.y) * dx2) / det;\r\n    if (t <= 0.0) ip = ln1a;\r\n    else if (t >= 1.0) ip = ln2a;\r\n    else ip = new Point64(ln1a.x + t * dx1, ln1a.y + t * dy1);\r\n    return { ip, success: true };\r\n  }\r\n\r\n  public static segsIntersect(seg1a: IPoint64, seg1b: IPoint64, seg2a: IPoint64, seg2b: IPoint64, inclusive: boolean = false): boolean {\r\n    if (inclusive) {\r\n      const res1 = InternalClipper.crossProduct(seg1a, seg2a, seg2b);\r\n      const res2 = InternalClipper.crossProduct(seg1b, seg2a, seg2b);\r\n      if (res1 * res2 > 0) return false;\r\n      const res3 = InternalClipper.crossProduct(seg2a, seg1a, seg1b);\r\n      const res4 = InternalClipper.crossProduct(seg2b, seg1a, seg1b);\r\n      if (res3 * res4 > 0) return false;\r\n      return (res1 !== 0 || res2 !== 0 || res3 !== 0 || res4 !== 0);\r\n    } else {\r\n      return (InternalClipper.crossProduct(seg1a, seg2a, seg2b) * InternalClipper.crossProduct(seg1b, seg2a, seg2b) < 0) &&\r\n        (InternalClipper.crossProduct(seg2a, seg1a, seg1b) * InternalClipper.crossProduct(seg2b, seg1a, seg1b) < 0);\r\n    }\r\n  }\r\n\r\n  public static getClosestPtOnSegment(offPt: IPoint64, seg1: IPoint64, seg2: IPoint64): IPoint64 {\r\n    if (seg1.x === seg2.x && seg1.y === seg2.y) return seg1;\r\n    const dx = seg2.x - seg1.x;\r\n    const dy = seg2.y - seg1.y;\r\n    let q = ((offPt.x - seg1.x) * dx + (offPt.y - seg1.y) * dy) / ((dx * dx) + (dy * dy));\r\n    if (q < 0) q = 0; else if (q > 1) q = 1;\r\n    return new Point64(seg1.x + Math.round(q * dx), seg1.y + Math.round(q * dy));\r\n  }\r\n\r\n  public static pointInPolygon(pt: IPoint64, polygon: Path64): PointInPolygonResult {\r\n    const len = polygon.length;\r\n    let start = 0;\r\n\r\n    if (len < 3) return PointInPolygonResult.IsOutside;\r\n\r\n    while (start < len && polygon[start].y === pt.y) start++;\r\n    if (start === len) return PointInPolygonResult.IsOutside;\r\n\r\n    let d: number = 0;\r\n    let isAbove = polygon[start].y < pt.y;\r\n    const startingAbove = isAbove;\r\n    let val = 0;\r\n    let i = start + 1;\r\n    let end = len;\r\n\r\n    for (; ;) {\r\n      if (i === end) {\r\n        if (end === 0 || start === 0) break;\r\n        end = start;\r\n        i = 0;\r\n      }\r\n\r\n      if (isAbove) {\r\n        while (i < end && polygon[i].y < pt.y) i++;\r\n        if (i === end) continue;\r\n      } else {\r\n        while (i < end && polygon[i].y > pt.y) i++;\r\n        if (i === end) continue;\r\n      }\r\n\r\n      const curr = polygon[i];\r\n      const prev = i > 0 ? polygon[i - 1] : polygon[len - 1];\r\n\r\n      if (curr.y === pt.y) {\r\n        if (curr.x === pt.x || (curr.y === prev.y && (pt.x < prev.x !== pt.x < curr.x))) return PointInPolygonResult.IsOn;\r\n        i++;\r\n        if (i === start) break;\r\n        continue;\r\n      }\r\n\r\n      if (pt.x < curr.x && pt.x < prev.x) {\r\n        // we're only interested in edges crossing on the left\r\n      } else if (pt.x > prev.x && pt.x > curr.x) {\r\n        val = 1 - val; // toggle val\r\n      } else {\r\n        d = InternalClipper.crossProduct(prev, curr, pt);\r\n        if (d === 0) return PointInPolygonResult.IsOn;\r\n        if ((d < 0) === isAbove) val = 1 - val;\r\n      }\r\n      isAbove = !isAbove;\r\n      i++;\r\n    }\r\n\r\n    if (isAbove !== startingAbove) {\r\n      if (i === len) i = 0;\r\n      else d = InternalClipper.crossProduct(polygon[i - 1], polygon[i], pt);\r\n      if (d === 0) return PointInPolygonResult.IsOn;\r\n      if ((d < 0) === isAbove) val = 1 - val;\r\n    }\r\n\r\n    if (val === 0) return PointInPolygonResult.IsOutside;\r\n    return PointInPolygonResult.IsInside;\r\n  }\r\n}\r\n","/*\n * Public API Surface of clipper2-js\n */\n\nexport * from './lib/core';\nexport * from './lib/clipper';\nexport * from './lib/engine';\nexport * from './lib/minkowski';\nexport * from './lib/offset';\nexport * from './lib/rectclip';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n","const DIRECTION_EPSILON = 1e-3;\nconst DIST_EPSILON = 1e2;\n\nfunction sameDirection( p0, p1, p2 ) {\n\n\tconst dx1 = p1.x - p0.x;\n\tconst dy1 = p1.y - p0.y;\n\n\tconst dx2 = p2.x - p1.x;\n\tconst dy2 = p2.y - p1.y;\n\n\tconst s1 = dx1 / dy1;\n\tconst s2 = dx2 / dy2;\n\n\treturn Math.abs( s1 - s2 ) < DIRECTION_EPSILON;\n\n}\n\nfunction areClose( p0, p1 ) {\n\n\tconst dx = p1.x - p0.x;\n\tconst dy = p1.y - p0.y;\n\treturn Math.sqrt( dx * dx + dy * dy ) < DIST_EPSILON;\n\n}\n\nfunction areEqual( p0, p1 ) {\n\n\treturn p0.x === p1.x && p0.y === p1.y;\n\n}\n\nexport function compressPoints( points ) {\n\n\tfor ( let k = 0; k < points.length; k ++ ) {\n\n\t\t// remove points that are equal or very close to each other\n\t\tconst v = points[ k ];\n\t\twhile ( true ) {\n\n\t\t\tconst k1 = k + 1;\n\t\t\tif (\n\t\t\t\tpoints.length > k1 &&\n\t\t\t\t(\n\t\t\t\t\tareEqual( v, points[ k1 ] ) ||\n\t\t\t\t\tareClose( v, points[ k1 ] )\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tpoints.splice( k1, 1 );\n\n\t\t\t} else {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\n\t\t}\n\n\t\t// join lines that are almost the same direction\n\t\twhile ( true ) {\n\n\t\t\tconst k1 = k + 1;\n\t\t\tconst k2 = k + 2;\n\t\t\tif (\n\t\t\t\tpoints.length > k2 &&\n\t\t\t\tsameDirection( v, points[ k1 ], points[ k2 ] )\n\t\t\t) {\n\n\t\t\t\tpoints.splice( k + 1, 1 );\n\n\t\t\t} else {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { Line3, Ray } from 'three';\n\nfunction xzToXzCopy( v, target ) {\n\n\ttarget.x = v.x;\n\ttarget.y = v.z;\n\n}\n\nfunction epsEquals( a, b ) {\n\n\treturn Math.abs( a - b ) <= 500;\n\n}\n\nfunction vectorEpsEquals( v0, v1 ) {\n\n\treturn epsEquals( v0.x, v1.x ) &&\n\t\tepsEquals( v0.y, v1.y ) &&\n\t\tepsEquals( v0.z, v1.z );\n\n}\n\nexport function triangleIsInsidePaths( tri, paths ) {\n\n\tconst indices = [ 'a', 'b', 'c' ];\n\tconst edges = [ new Line3(), new Line3(), new Line3() ];\n\tconst line = new Line3();\n\tconst ray = new Line3();\n\tray.start\n\t\t.set( 0, 0, 0 )\n\t\t.addScaledVector( tri.a, 1 / 3 )\n\t\t.addScaledVector( tri.b, 1 / 3 )\n\t\t.addScaledVector( tri.c, 1 / 3 );\n\n\txzToXzCopy( ray.start, ray.start );\n\tray.end.copy( ray.start );\n\tray.end.y += 1e10;\n\n\t// get all triangle edges\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst i1 = ( i + 1 ) % 3;\n\t\tconst p0 = tri[ indices[ i ] ];\n\t\tconst p1 = tri[ indices[ i1 ] ];\n\n\t\tconst edge = edges[ i ];\n\t\txzToXzCopy( p0, edge.start );\n\t\txzToXzCopy( p1, edge.end );\n\n\t}\n\n\tlet crossCount = 0;\n\tfor ( let p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\tconst points = paths[ p ];\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst i1 = ( i + 1 ) % l;\n\t\t\tline.start.copy( points[ i ] );\n\t\t\tline.start.z = 0;\n\n\t\t\tline.end.copy( points[ i1 ] );\n\t\t\tline.end.z = 0;\n\n\t\t\tif ( lineCrossesLine( ray, line ) ) {\n\n\t\t\t\tcrossCount ++;\n\n\t\t\t}\n\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tconst edge = edges[ e ];\n\t\t\t\tif (\n\t\t\t\t\tlineCrossesLine( edge, line ) ||\n\t\t\t\t\tvectorEpsEquals( edge.start, line.start ) ||\n\t\t\t\t\tvectorEpsEquals( edge.end, line.end ) ||\n\t\t\t\t\tvectorEpsEquals( edge.end, line.start ) ||\n\t\t\t\t\tvectorEpsEquals( edge.start, line.end )\n\t\t\t\t) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn crossCount % 2 === 1;\n\n}\n\n// https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\nfunction lineCrossesLine( l1, l2 ) {\n\n\tfunction ccw( A, B, C ) {\n\n\t\treturn ( C.y - A.y ) * ( B.x - A.x ) > ( B.y - A.y ) * ( C.x - A.x );\n\n\t}\n\n\tconst A = l1.start;\n\tconst B = l1.end;\n\n\tconst C = l2.start;\n\tconst D = l2.end;\n\n\treturn ccw( A, C, D ) !== ccw( B, C, D ) && ccw( A, B, C ) !== ccw( A, B, D );\n\n}\n","import { Triangle } from 'three';\nimport { getTriCount } from './geometryUtils.js';\n\nconst _tri = new Triangle();\nexport function getSizeSortedTriList( geometry ) {\n\n\tconst index = geometry.index;\n\tconst posAttr = geometry.attributes.position;\n\tconst triCount = getTriCount( geometry );\n\n\treturn new Array( triCount )\n\t\t.fill()\n\t\t.map( ( v, i ) => {\n\n\t\t\tlet i0 = i * 3 + 0;\n\t\t\tlet i1 = i * 3 + 1;\n\t\t\tlet i2 = i * 3 + 2;\n\t\t\tif ( index ) {\n\n\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t}\n\n\t\t\t_tri.a.fromBufferAttribute( posAttr, i0 );\n\t\t\t_tri.b.fromBufferAttribute( posAttr, i1 );\n\t\t\t_tri.c.fromBufferAttribute( posAttr, i2 );\n\n\t\t\t_tri.a.y = 0;\n\t\t\t_tri.b.y = 0;\n\t\t\t_tri.c.y = 0;\n\n\t\t\t// get the projected area of the triangle to sort largest triangles first\n\t\t\treturn {\n\t\t\t\tarea: _tri.getArea(),\n\t\t\t\tindex: i,\n\t\t\t};\n\n\t\t} )\n\t\t.sort( ( a, b ) => {\n\n\t\t\t// sort the triangles largest to smallest\n\t\t\treturn b.area - a.area;\n\n\t\t} )\n\t\t.map( o => {\n\n\t\t\t// map to the triangle index\n\t\t\treturn o.index;\n\n\t\t} );\n\n}\n","export function getTriCount( geometry ) {\n\n\tconst { index } = geometry;\n\tconst posAttr = geometry.attributes.position;\n\treturn index ? index.count / 3 : posAttr.count / 3;\n\n}\n"],"names":["JoinType","EndType","Location","PointInPolygonResult","VertexFlags","JoinWith","HorzPosition","ClipType","PathType","FillRule","PipResult","$0b6dbf71c0c0eea1$export$738d8b3921c27063","$0b6dbf71c0c0eea1$export$38f58f6965412d86","$0b6dbf71c0c0eea1$var$Location","$0b6dbf71c0c0eea1$export$20896d302a4e5029","$0b6dbf71c0c0eea1$export$6bbe4490a892c1c5","$0b6dbf71c0c0eea1$export$290b84559c467a5c","$0b6dbf71c0c0eea1$export$c8278727b7a5228b","$0b6dbf71c0c0eea1$export$9e3ecdefb2438757","$0b6dbf71c0c0eea1$export$1ede5f4f7cadbc19","$0b6dbf71c0c0eea1$export$f26b42c94e8a4f95","$0b6dbf71c0c0eea1$export$6a3f4acf2fce52a0","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","importScripts","$e06gU","$0b6dbf71c0c0eea1$export$d7b4df78e16216b1","minkowskiInternal","pattern","path","isSum","isClosed","delta","patLen","length","pathLen","tmp","pathPt","path2","basePt","push","x","y","result","g","h","i","j","quad","$0b6dbf71c0c0eea1$export$47d6d5d06ccbc908","isPositive","reversePath","sum","Union","undefined","NonZero","diff","$0b6dbf71c0c0eea1$var$Group","constructor","paths","joinType","endType","Polygon","inPaths","outPath","outPaths","pathsReversed","$0b6dbf71c0c0eea1$export$f7b22d527d83f4ad","xOrPt","yOrScale","toString","precision","toFixed","equals","lhs","rhs","$0b6dbf71c0c0eea1$export$9bad362b29d84293","isAlmostZero","notEquals","obj","negate","$0b6dbf71c0c0eea1$export$8cbc02e4273c0b24","miterLimit","arcTolerance","preserveCollinear","reverseSolution","_groupList","_normals","_solution","MiterLimit","ArcTolerance","MergeGroups","PreserveCollinear","ReverseSolution","clear","addPath","pp","addPaths","executeInternal","Math","abs","group","_delta","_mitLimSqr","sqr","doGroupOffset","value","execute","solution","c","$0b6dbf71c0c0eea1$export$389255fe4ace408b","addSubjectPaths","Negative","Positive","executePolytree","polytree","executePolyTree","getUnitNormal","pt1","pt2","dx","dy","f","sqrt","executeCallback","deltaCallback","DeltaCallback","getBoundsAndLowestPolyIdx","rec","$0b6dbf71c0c0eea1$export$e7ab2e89a2fb5a6f","lpX","Number","MIN_SAFE_INTEGER","index","pt","bottom","top","right","left","translatePoint","reflectPoint","pivot","almostZero","epsilon","hypotenuse","pow","normalizeVector","vec","inverseHypot","getAvgUnitVector","vec1","vec2","intersectPoint","pt1a","pt1b","pt2a","pt2b","m2","b2","m1","b1","getPerpendic","norm","$0b6dbf71c0c0eea1$export$d379afd9763b528f","_groupDelta","getPerpendicD","doSquare","k","absDelta","ptQ","pt3","pt4","doMiter","cosA","q","doRound","angle","arcTol","log10","defaultArcTolerance","stepsPer360","PI","acos","_stepSin","sin","_stepCos","cos","_stepsPerRad","offsetVec","steps","ceil","buildNormals","cnt","crossProduct","dotProduct","offsetPoint","sinA","Tolerance","_joinType","Miter","Square","atan2","offsetPolygon","area","rect","getBounds","width","prev","offsetOpenJoined","offsetOpenPath","highI","_endType","Butt","Round","isJoined","Joined","p","stripDuplicates","ellipse","d","r","asPath","$0b6dbf71c0c0eea1$export$a6dea2fac1e0b407","ownerIdx","$0b6dbf71c0c0eea1$export$ada4127871f05d7b","currIdx","mp","midPoint","rectPath","results","edges","Array","fill","map","add","startingNewPath","next","prevOp","path1ContainsPath2","path1","ioCount","pip","pointInPolygon","IsInside","IsOutside","isClockwise","curr","prevPt","currPt","rectMidPoint","areOpposites","headingClockwise","getAdjacentLocation","loc","unlinkOp","op","unlinkOpBack","getEdgesForPt","isHeadingClockwise","edgeIdx","hasHorzOverlap","left1","right1","left2","right2","hasVertOverlap","top1","bottom1","top2","bottom2","addToEdge","edge","uncoupleEdge","op2","setNewOwner","newIdx","addCorner","addCornerByRef","getLocation","success","inside","getIntersection","p2","ip","segsIntersect","getIntersectPt","getNextLocation","context","isEmpty","startLocs","firstCross","crossingLoc","startingLoc","prevCrossLoc","isClockw","ip2","pathBounds","containsRect","loc2","intersects","checkEdges","tidyEdgePair","getPath","edgeSet1","edgeSet2","combinedSet","idx","cw","ccw","p1","p1a","p2a","isHorz","cwIsTowardLarger","opIsLarger","op2IsLarger","jLim","isRejoining","new_idx","$0b6dbf71c0c0eea1$export$b12670b10302a8b7","$0b6dbf71c0c0eea1$export$b1d67b8e0b9a10d2","$0b6dbf71c0c0eea1$export$3a7c4895ca9e3ca9","InvalidRect64","invalidRect64","Intersect","subject","clip","fillRule","BooleanOp","Intersection","EvenOdd","Difference","Xor","clipType","Subject","Clip","InflatePaths","co","RectClipPaths","rc","RectClip","RectClipLinesPaths","RectClipLines","MinkowskiSum","MinkowskiDiff","a","areaPaths","poly","path64ToString","paths64ToString","offsetPath","scalePoint64","scale","round","scalePath","scalePaths","translatePath","translatePaths","reverse","reversePaths","t","MAX_SAFE_INTEGER","getBoundsPaths","makePath","arr","len","isClosedPath","lastPt","pop","addPolyNodeToPaths","polyPath","polygon","count","children","polyTreeToPaths64","polyTree","perpendicDistFromLineSqrd","line1","line2","b","rdp","begin","end","epsSqrd","flags","max_d","ramerDouglasPeucker","ramerDouglasPeuckerPaths","getNext","current","high","getPrior","simplifyPath","start","prior2","next2","epsSqr","dsq","MAX_VALUE","simplifyPaths","isClosedPaths","trimCollinear","isOpen","last","splice","center","radiusX","radiusY","si","showPolyPathStructure","level","spaces","repeat","caption","isHole","console","log","forEach","child","showPolyTreeStructure","$0b6dbf71c0c0eea1$var$Vertex","$0b6dbf71c0c0eea1$var$LocalMinima","vertex","polytype","lm1","lm2","$0b6dbf71c0c0eea1$var$IntersectNode","edge1","edge2","$0b6dbf71c0c0eea1$var$OutPt","outrec","horz","$0b6dbf71c0c0eea1$export$1e0666df669b1ceb","$0b6dbf71c0c0eea1$var$HorzSegment","leftOp","rightOp","leftToRight","$0b6dbf71c0c0eea1$var$HorzJoin","ltor","rtol","op1","$0b6dbf71c0c0eea1$export$c3c7cbf43a3f0561","windCount","windCount2","isLeftBound","joinWith","None","$0b6dbf71c0c0eea1$export$467e9e338ef38141","addLocMin","vert","minimaList","LocalMin","lm","addPathsToVertexList","vertexList","totalVertCnt","v0","prev_v","curr_v","going_up","warn","OpenStart","LocalMax","going_up0","OpenEnd","$0b6dbf71c0c0eea1$var$SimpleNavigableSet","items","pollLast","item","includes","sort","$0b6dbf71c0c0eea1$export$33da2edff2b544f3","_cliptype","_fillrule","_currentLocMin","_currentBotY","_isSortedMinimaList","_hasOpenPaths","_using_polytree","_succeeded","_minimaList","_intersectList","_vertexList","_outrecList","_scanlineList","_horzSegList","_horzJoinList","isOdd","val","isHotEdgeActive","ae","localMin","isOpenEndActive","isOpenEnd","vertexTop","v","getPrevHotEdge","prevInAEL","isFront","frontEdge","getDx","NEGATIVE_INFINITY","POSITIVE_INFINITY","topX","currentY","bot","isHorizontal","isHeadingRightHorz","isHeadingLeftHorz","swapActives","ae1","ae2","getPolyType","isSamePolyType","setDx","nextVertex","windDx","prevPrevVertex","isMaxima","isMaximaActive","getMaximaPair","nextInAEL","getCurrYMaximaVertex_Open","getCurrYMaximaVertex","setSides","startEdge","endEdge","backEdge","swapOutrecs","or1","or2","setOwner","newOwner","owner","pts","areaTriangle","getRealOutRec","outRec","isValidOwner","testOwner","uncoupleOutRec","outrecIsAscending","hotEdge","swapFrontBackSides","edgesAdjacentInAEL","inode","clearSolutionOnly","_actives","deleteFromAEL","disposeIntersectNodes","reset","locMin1","locMin2","_sel","insertScanline","popScanline","hasLocMinAtY","popLocalMinima","addSubject","addOpenSubject","addClip","addReuseableData","reuseableData","isContributingClosed","isContributingOpen","isInClip","isInSubj","setWindCountForClosedPathEdge","setWindCountForOpenPathEdge","cnt1","cnt2","isValidAelOrder","resident","newcomer","curX","newcomerIsLeft","insertLeftEdge","Right","insertRightEdge","insertLocalMinimaIntoAEL","botY","localMinima","leftBound","rightBound","contributing","addLocalMinPoly","checkJoinLeft","intersectEdges","swapPositionsInAEL","pushHorz","checkJoinRight","startOpenPath","nextInSEL","popHorz","isNew","newOutRec","prevHotEdge","addLocalMaxPoly","split","addOutPt","e","joinOutrecPaths","p1Start","p2Start","p1End","p2End","toFront","opFront","opBack","newOp","updateEdgeIntoAEL","findEdgeWithMatchingLocMin","oldE1WindCount","oldE2WindCount","resultOp","ae3","e1WindCountIs0or1","e2WindCountIs0or1","e1Wc2","e2Wc2","adjustCurrXAndCopyToSEL","topY","prevInSEL","jump","Left","ct","doHorizontal","convertHorzSegsToJoins","doIntersections","doTopOfScanbeam","processHorzJoins","buildIntersectList","processIntersectList","addNewIntersectNode","absDx1","absDx2","getClosestPtOnSegment","node","extractFromSEL","res","insert1Before2InSEL","lEnd","rEnd","currBase","prevBase","resetHorzDirection","vertexMax","leftX","rightX","isLeftToRight","horzIsSpike","nextPt","trimHorz","horzEdge","wasTrimmed","addToHorzSegList","getLastOp","horzIsOpen","Y","vertex_max","doMaxima","prevE","nextE","maxPair","checkCurrX","fixOutRecPts","setHorzSegHeadingForward","hs","opP","opN","updateHorzSegment","outrecHasEdges","curr_y","opA","opZ","duplicateOp","insert_after","hs1","hs2","join","getCleanPath","pointInOpPolygon","isAbove","startingAbove","IsOn","path1InsidePath2","outside_cnt","getBoundsPath","moveSplits","fromOr","toOr","splits","op1b","op2b","ptsReallyClose","isVerySmallTriangle","isValidClosedPath","disposeOutPt","cleanCollinear","startOp","fixSelfIntersects","doSplitOp","splitOp","nextNextOp","getIntersectPoint","area1","absArea1","area2","absArea2","newOp2","buildPath","buildPaths","solutionClosed","solutionOpen","checkBounds","bounds","checkSplitOwner","recursiveSplit","recursiveCheckOwners","polypath","addChild","buildTree","open_path","addReusableData","reusableData","addOpenSubjectPaths","addClipPaths","error","openPaths","lOrIsValidOrRec","height","contains","max","min","subtract","checkPrecision","precision_range_error","floatingPointTolerance","checkCastInt64","max_coord","min_coord","Invalid64","ln1a","ln1b","ln2a","ln2b","dy1","dx1","dy2","dx2","det","seg1a","seg1b","seg2a","seg2b","inclusive","res1","res2","res3","res4","offPt","seg1","seg2","$60fc547e70fa748b$var$xzToXzCopy","target","z","$60fc547e70fa748b$var$epsEquals","$60fc547e70fa748b$var$vectorEpsEquals","v1","$60fc547e70fa748b$var$lineCrossesLine","l1","l2","A","B","C","D","MaxInt64","MaxCoord","defaultMinimumEdgeLength","$2683a3650d27fd1c$export$c56c51fae37b2d63","geometry","posAttr","attributes","position","$00d3e1a2b175655e$var$_tri","Triangle","$b7cc2dc72cc279b6$var$UP_VECTOR","Vector3","$b7cc2dc72cc279b6$var$_tri","$b7cc2dc72cc279b6$var$_normal","$b7cc2dc72cc279b6$var$_center","$b7cc2dc72cc279b6$var$_vec","$b7cc2dc72cc279b6$var$convertPathToGeometry","vector2s","points","flatMap","Vector2","holesShapes","filter","ShapeUtils","isClockWise","Shape","solidShapes","shape","holes","ShapeGeometry","rotateX","array","$b7cc2dc72cc279b6$var$convertPathToLineSegments","l","i1","p0","BufferGeometry","setFromPoints","$b7cc2dc72cc279b6$export$8f233aafe78e44af","iterationTime","intScalar","doubleSided","sortTriangles","output","generateAsync","options","Promise","resolve","reject","signal","task","generate","run","aborted","done","requestAnimationFrame","onProgress","power","extendMultiplier","triCount","overallPath","triList","i0","i2","getX","fromBufferAttribute","getArea","o","handle","getGeometry","time","performance","now","ti","getNormal","dot","copy","multiplyScalar","subVectors","normalize","addScaledVector","tri","indices","Line3","line","ray","set","crossCount","pl","k1","$00adfa846be5871c$var$areEqual","$00adfa846be5871c$var$areClose","k2","$00adfa846be5871c$var$sameDirection","s1","progress","onmessage","data","prevTime","buffers","setIndex","BufferAttribute","setAttribute","generator","currTime","postMessage","posArr","indexArr","buffer"],"version":3,"file":"silhouetteAsync.worker.f555f2b4.js.map"}