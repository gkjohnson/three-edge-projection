(()=>{var t,e,i,s,r,n,o,l,a,h,p,c,u,d,f,x,g,y,v,P,w,L,m="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},E={},I={},_=m.parcelRequire6c98;null==_&&((_=function(t){if(t in E)return E[t].exports;if(t in I){var e=I[t];delete I[t];var i={id:t,exports:{}};return E[t]=i,e.call(i.exports,i,i.exports),i.exports}var s=Error("Cannot find module '"+t+"'");throw s.code="MODULE_NOT_FOUND",s}).register=function(t,e){I[t]=e},m.parcelRequire6c98=_),importScripts("./projectionAsync.worker.d112c604.js");var b=_("e06gU");class O{static minkowskiInternal(t,e,i,s){let r=s?0:1,n=t.length,o=e.length,l=[];for(let s of e){let e=[];if(i)for(let i of t)e.push({x:s.x+i.x,y:s.y+i.y});else for(let i of t)e.push({x:s.x-i.x,y:s.y-i.y});l.push(e)}let a=[],h=s?o-1:0,p=n-1;for(let t=r;t<o;t++){for(let e=0;e<n;e++){let i=[l[h][p],l[t][p],l[t][e],l[h][e]];R.isPositive(i)?a.push(i):a.push(R.reversePath(i)),p=e}h=t}return a}static sum(t,e,i){return R.Union(this.minkowskiInternal(t,e,!0,i),void 0,w.NonZero)}static diff(t,e,i){return R.Union(this.minkowskiInternal(t,e,!1,i),void 0,w.NonZero)}}(t=c||(c={}))[t.Square=0]="Square",t[t.Round=1]="Round",t[t.Miter=2]="Miter",(e=u||(u={}))[e.Polygon=0]="Polygon",e[e.Joined=1]="Joined",e[e.Butt=2]="Butt",e[e.Square=3]="Square",e[e.Round=4]="Round";class A{constructor(t,e,i=u.Polygon){this.inPaths=[...t],this.joinType=e,this.endType=i,this.outPath=[],this.outPaths=[],this.pathsReversed=!1}}class M{constructor(t,e){"number"==typeof t&&"number"==typeof e?(this.x=t,this.y=e):t instanceof M?void 0!==e?(this.x=t.x*e,this.y=t.y*e):(this.x=t.x,this.y=t.y):(this.x=t.x*(e||1),this.y=t.y*(e||1))}toString(t=2){return`${this.x.toFixed(t)},${this.y.toFixed(t)}`}static equals(t,e){return $.isAlmostZero(t.x-e.x)&&$.isAlmostZero(t.y-e.y)}static notEquals(t,e){return!$.isAlmostZero(t.x-e.x)||!$.isAlmostZero(t.y-e.y)}equals(t){return t instanceof M&&M.equals(this,t)}negate(){this.x=-this.x,this.y=-this.y}}class S{constructor(t=2,e=0,i=!1,s=!1){this._groupList=[],this._normals=[],this._solution=[],this.MiterLimit=t,this.ArcTolerance=e,this.MergeGroups=!0,this.PreserveCollinear=i,this.ReverseSolution=s}clear(){this._groupList=[]}addPath(t,e,i){if(0===t.length)return;let s=[t];this.addPaths(s,e,i)}addPaths(t,e,i){0!==t.length&&this._groupList.push(new A(t,e,i))}executeInternal(t){if(this._solution=[],0!==this._groupList.length){if(.5>Math.abs(t))for(let t of this._groupList)for(let e of t.inPaths)this._solution.push(e);else for(let e of(this._delta=t,this._mitLimSqr=this.MiterLimit<=1?2:2/this.sqr(this.MiterLimit),this._groupList))this.doGroupOffset(e)}}sqr(t){return t*t}execute(t,e){if(e.length=0,this.executeInternal(t),0===this._groupList.length)return;let i=new U;i.preserveCollinear=this.PreserveCollinear,i.reverseSolution=this.ReverseSolution!==this._groupList[0].pathsReversed,i.addSubjectPaths(this._solution),this._groupList[0].pathsReversed?i.execute(v.Union,w.Negative,e):i.execute(v.Union,w.Positive,e)}executePolytree(t,e){if(e.clear(),this.executeInternal(t),0===this._groupList.length)return;let i=new U;i.preserveCollinear=this.PreserveCollinear,i.reverseSolution=this.ReverseSolution!==this._groupList[0].pathsReversed,i.addSubjectPaths(this._solution),this._groupList[0].pathsReversed?i.executePolyTree(v.Union,w.Negative,e):i.executePolyTree(v.Union,w.Positive,e)}static getUnitNormal(t,e){let i=e.x-t.x,s=e.y-t.y;if(0===i&&0===s)return new M(0,0);let r=1/Math.sqrt(i*i+s*s);return i*=r,s*=r,new M(s,-i)}executeCallback(t,e){this.DeltaCallback=t,this.execute(1,e)}static getBoundsAndLowestPolyIdx(t){let e=new G(!1),i=Number.MIN_SAFE_INTEGER,s=-1;for(let r=0;r<t.length;r++)for(let n of t[r])n.y>=e.bottom?(n.y>e.bottom||n.x<i)&&(s=r,i=n.x,e.bottom=n.y):n.y<e.top&&(e.top=n.y),n.x>e.right?e.right=n.x:n.x<e.left&&(e.left=n.x);return{index:s,rec:e}}static translatePoint(t,e,i){return new M(t.x+e,t.y+i)}static reflectPoint(t,e){return new M(e.x+(e.x-t.x),e.y+(e.y-t.y))}static almostZero(t,e=.001){return Math.abs(t)<e}static hypotenuse(t,e){return Math.sqrt(Math.pow(t,2)+Math.pow(e,2))}static normalizeVector(t){let e=this.hypotenuse(t.x,t.y);if(this.almostZero(e))return new M(0,0);let i=1/e;return new M(t.x*i,t.y*i)}static getAvgUnitVector(t,e){return this.normalizeVector(new M(t.x+e.x,t.y+e.y))}static intersectPoint(t,e,i,s){if($.isAlmostZero(t.x-e.x)){if($.isAlmostZero(i.x-s.x))return new M(0,0);let e=(s.y-i.y)/(s.x-i.x),r=i.y-e*i.x;return new M(t.x,e*t.x+r)}if($.isAlmostZero(i.x-s.x)){let s=(e.y-t.y)/(e.x-t.x),r=t.y-s*t.x;return new M(i.x,s*i.x+r)}{let r=(e.y-t.y)/(e.x-t.x),n=t.y-r*t.x,o=(s.y-i.y)/(s.x-i.x),l=i.y-o*i.x;if($.isAlmostZero(r-o))return new M(0,0);let a=(l-n)/(r-o);return new M(a,r*a+n)}}getPerpendic(t,e){return new Y(t.x+e.x*this._groupDelta,t.y+e.y*this._groupDelta)}getPerpendicD(t,e){return new M(t.x+e.x*this._groupDelta,t.y+e.y*this._groupDelta)}doSquare(t,e,i,s){let r;r=i===s?new M(this._normals[i].y,-this._normals[i].x):S.getAvgUnitVector(new M(-this._normals[s].y,this._normals[s].x),new M(this._normals[i].y,-this._normals[i].x));let n=Math.abs(this._groupDelta),o=new M(e[i].x,e[i].y);o=S.translatePoint(o,n*r.x,n*r.y);let l=S.translatePoint(o,this._groupDelta*r.y,-(this._groupDelta*r.x)),a=S.translatePoint(o,-(this._groupDelta*r.y),this._groupDelta*r.x),h=this.getPerpendicD(e[s],this._normals[s]);if(i===s){let e=new M(h.x+r.x*this._groupDelta,h.y+r.y*this._groupDelta),i=S.intersectPoint(l,a,h,e);t.outPath.push(new Y(S.reflectPoint(i,o).x,S.reflectPoint(i,o).y)),t.outPath.push(new Y(i.x,i.y))}else{let r=this.getPerpendicD(e[i],this._normals[s]),n=S.intersectPoint(l,a,h,r);t.outPath.push(new Y(n.x,n.y)),t.outPath.push(new Y(S.reflectPoint(n,o).x,S.reflectPoint(n,o).y))}}doMiter(t,e,i,s,r){let n=this._groupDelta/(r+1);t.outPath.push(new Y(e[i].x+(this._normals[s].x+this._normals[i].x)*n,e[i].y+(this._normals[s].y+this._normals[i].y)*n))}doRound(t,e,i,s,r){if(void 0!==this.DeltaCallback){let t=Math.abs(this._groupDelta),e=this.ArcTolerance>.01?this.ArcTolerance:Math.log10(2+t)*$.defaultArcTolerance,i=Math.PI/Math.acos(1-e/t);this._stepSin=Math.sin(2*Math.PI/i),this._stepCos=Math.cos(2*Math.PI/i),this._groupDelta<0&&(this._stepSin=-this._stepSin),this._stepsPerRad=i/(2*Math.PI)}let n=e[i],o=new M(this._normals[s].x*this._groupDelta,this._normals[s].y*this._groupDelta);if(i===s&&o.negate(),t.outPath.push(new Y(n.x+o.x,n.y+o.y)),r>-Math.PI+.01){let e=Math.ceil(this._stepsPerRad*Math.abs(r));for(let i=1;i<e;i++)o=new M(o.x*this._stepCos-this._stepSin*o.y,o.x*this._stepSin+o.y*this._stepCos),t.outPath.push(new Y(n.x+o.x,n.y+o.y))}t.outPath.push(this.getPerpendic(n,this._normals[i]))}buildNormals(t){let e=t.length;this._normals=[],this._normals.length=e;for(let i=0;i<e-1;i++)this._normals.push(S.getUnitNormal(t[i],t[i+1]));this._normals.push(S.getUnitNormal(t[e-1],t[0]))}crossProduct(t,e){return t.y*e.x-e.y*t.x}dotProduct(t,e){return t.x*e.x+t.y*e.y}offsetPoint(t,e,i,s){let r=this.crossProduct(this._normals[i],this._normals[s]),n=this.dotProduct(this._normals[i],this._normals[s]);if(r>1?n=1:r<-1&&(n=-1),void 0!==this.DeltaCallback&&(this._groupDelta=this.DeltaCallback(e,this._normals,i,s),t.pathsReversed&&(this._groupDelta=-this._groupDelta)),Math.abs(this._groupDelta)<S.Tolerance){t.outPath.push(e[i]);return}n>.999?this.doMiter(t,e,i,s,n):n>-.99&&r*this._groupDelta<0?(t.outPath.push(this.getPerpendic(e[i],this._normals[s])),t.outPath.push(e[i]),t.outPath.push(this.getPerpendic(e[i],this._normals[i]))):this._joinType===c.Miter?n>this._mitLimSqr-1?this.doMiter(t,e,i,s,n):this.doSquare(t,e,i,s):n>.99||this._joinType===c.Square?this.doSquare(t,e,i,s):this.doRound(t,e,i,s,Math.atan2(r,n)),s=i}offsetPolygon(t,e){let i=R.area(e);if(i<0!=this._groupDelta<0){let t=R.getBounds(e);if(2*Math.abs(this._groupDelta)>t.width)return}t.outPath=[];let s=e.length,r=s-1;for(let i=0;i<s;i++)this.offsetPoint(t,e,i,r);t.outPaths.push(t.outPath)}offsetOpenJoined(t,e){this.offsetPolygon(t,e),e=R.reversePath(e),this.buildNormals(e),this.offsetPolygon(t,e)}offsetOpenPath(t,e){t.outPath=[];let i=e.length-1;if(void 0!==this.DeltaCallback&&(this._groupDelta=this.DeltaCallback(e,this._normals,0,0)),Math.abs(this._groupDelta)<S.Tolerance)t.outPath.push(e[0]);else switch(this._endType){case u.Butt:t.outPath.push(new Y(e[0].x-this._normals[0].x*this._groupDelta,e[0].y-this._normals[0].y*this._groupDelta)),t.outPath.push(this.getPerpendic(e[0],this._normals[0]));break;case u.Round:this.doRound(t,e,0,0,Math.PI);break;default:this.doSquare(t,e,0,0)}for(let s=1;s<i;s++)this.offsetPoint(t,e,s,0);for(let t=i;t>0;t--)this._normals[t]=new M(-this._normals[t-1].x,-this._normals[t-1].y);if(this._normals[0]=this._normals[i],void 0!==this.DeltaCallback&&(this._groupDelta=this.DeltaCallback(e,this._normals,i,i)),Math.abs(this._groupDelta)<S.Tolerance)t.outPath.push(e[i]);else switch(this._endType){case u.Butt:t.outPath.push(new Y(e[i].x-this._normals[i].x*this._groupDelta,e[i].y-this._normals[i].y*this._groupDelta)),t.outPath.push(this.getPerpendic(e[i],this._normals[i]));break;case u.Round:this.doRound(t,e,i,i,Math.PI);break;default:this.doSquare(t,e,i,i)}for(let s=i;s>0;s--)this.offsetPoint(t,e,s,0);t.outPaths.push(t.outPath)}doGroupOffset(t){if(t.endType==u.Polygon){let{index:e}=S.getBoundsAndLowestPolyIdx(t.inPaths);if(e<0)return;let i=R.area(t.inPaths[e]);t.pathsReversed=i<0,t.pathsReversed?this._groupDelta=-this._delta:this._groupDelta=this._delta}else t.pathsReversed=!1,this._groupDelta=.5*Math.abs(this._delta);let e=Math.abs(this._groupDelta);if(this._joinType=t.joinType,this._endType=t.endType,!this.DeltaCallback&&(t.joinType==c.Round||t.endType==u.Round)){let t=this.ArcTolerance>.01?this.ArcTolerance:Math.log10(2+e)*$.defaultArcTolerance,i=Math.PI/Math.acos(1-t/e);this._stepSin=Math.sin(2*Math.PI/i),this._stepCos=Math.cos(2*Math.PI/i),this._groupDelta<0&&(this._stepSin=-this._stepSin),this._stepsPerRad=i/(2*Math.PI)}let i=t.endType==u.Joined||t.endType==u.Polygon;for(let s of t.inPaths){let r=R.stripDuplicates(s,i),n=r.length;if(0!==n&&(!(n<3)||this._endType!=u.Polygon)){if(1==n){if(t.outPath=[],t.endType==u.Round)t.outPath=R.ellipse(r[0],e,e);else{let e=Math.ceil(this._groupDelta),i=new G(r[0].x-e,r[0].y-e,r[0].x-e,r[0].y-e);t.outPath=i.asPath()}t.outPaths.push(t.outPath)}else 2==n&&t.endType==u.Joined&&(t.joinType==c.Round?this._endType=u.Round:this._endType=u.Square),this.buildNormals(r),this._endType==u.Polygon?this.offsetPolygon(t,r):this._endType==u.Joined?this.offsetOpenJoined(t,r):this.offsetOpenPath(t,r)}}this._solution.push(...t.outPaths),t.outPaths=[]}}S.Tolerance=1e-12;class C{constructor(t){this.pt=t,this.ownerIdx=0}}(i=d||(d={}))[i.left=0]="left",i[i.top=1]="top",i[i.right=2]="right",i[i.bottom=3]="bottom",i[i.inside=4]="inside";class k{constructor(t){this.currIdx=-1,this.rect=t,this.mp=t.midPoint(),this.rectPath=t.asPath(),this.results=[],this.edges=Array(8).fill(void 0).map(()=>[])}add(t,e=!1){let i,s=this.results.length;if(0===s||e)i=new C(t),this.results.push(i),i.ownerIdx=s,i.prev=i,i.next=i;else{s--;let e=this.results[s];if(e.pt===t)return e;(i=new C(t)).ownerIdx=s,i.next=e.next,e.next.prev=i,e.next=i,i.prev=e,this.results[s]=i}return i}static path1ContainsPath2(t,e){let i=0;for(let s of e){let e=$.pointInPolygon(s,t);switch(e){case f.IsInside:i--;break;case f.IsOutside:i++}if(Math.abs(i)>1)break}return i<=0}static isClockwise(t,e,i,s,r){return this.areOpposites(t,e)?0>$.crossProduct(i,r,s):this.headingClockwise(t,e)}static areOpposites(t,e){return 2===Math.abs(t-e)}static headingClockwise(t,e){return(t+1)%4===e}static getAdjacentLocation(t,e){return(t+(e?1:3))%4}static unlinkOp(t){if(t.next!==t)return t.prev.next=t.next,t.next.prev=t.prev,t.next}static unlinkOpBack(t){if(t.next!==t)return t.prev.next=t.next,t.next.prev=t.prev,t.prev}static getEdgesForPt(t,e){let i=0;return t.x===e.left?i=1:t.x===e.right&&(i=4),t.y===e.top?i+=2:t.y===e.bottom&&(i+=8),i}static isHeadingClockwise(t,e,i){switch(i){case 0:return e.y<t.y;case 1:return e.x>t.x;case 2:return e.y>t.y;default:return e.x<t.x}}static hasHorzOverlap(t,e,i,s){return t.x<s.x&&e.x>i.x}static hasVertOverlap(t,e,i,s){return t.y<s.y&&e.y>i.y}static addToEdge(t,e){e.edge||(e.edge=t,t.push(e))}static uncoupleEdge(t){if(t.edge){for(let e=0;e<t.edge.length;e++){let i=t.edge[e];if(i===t){t.edge[e]=void 0;break}}t.edge=void 0}}static setNewOwner(t,e){t.ownerIdx=e;let i=t.next;for(;i!==t;)i.ownerIdx=e,i=i.next}addCorner(t,e){k.headingClockwise(t,e)?this.add(this.rectPath[t]):this.add(this.rectPath[e])}addCornerByRef(t,e){e?(this.add(this.rectPath[t]),t=k.getAdjacentLocation(t,!0)):(t=k.getAdjacentLocation(t,!1),this.add(this.rectPath[t]))}static getLocation(t,e){return e.x===t.left&&e.y>=t.top&&e.y<=t.bottom?{success:!1,loc:d.left}:e.x===t.right&&e.y>=t.top&&e.y<=t.bottom?{success:!1,loc:d.right}:e.y===t.top&&e.x>=t.left&&e.x<=t.right?{success:!1,loc:d.top}:e.y===t.bottom&&e.x>=t.left&&e.x<=t.right?{success:!1,loc:d.bottom}:{success:!0,loc:e.x<t.left?d.left:e.x>t.right?d.right:e.y<t.top?d.top:e.y>t.bottom?d.bottom:d.inside}}static getIntersection(t,e,i,s){let r=new Y;switch(s){case d.left:if($.segsIntersect(e,i,t[0],t[3],!0))r=$.getIntersectPt(e,i,t[0],t[3]).ip;else if(e.y<t[0].y&&$.segsIntersect(e,i,t[0],t[1],!0))r=$.getIntersectPt(e,i,t[0],t[1]).ip,s=d.top;else{if(!$.segsIntersect(e,i,t[2],t[3],!0))return{success:!1,loc:s,ip:r};r=$.getIntersectPt(e,i,t[2],t[3]).ip,s=d.bottom}break;case d.right:if($.segsIntersect(e,i,t[1],t[2],!0))r=$.getIntersectPt(e,i,t[1],t[2]).ip;else if(e.y<t[0].y&&$.segsIntersect(e,i,t[0],t[1],!0))r=$.getIntersectPt(e,i,t[0],t[1]).ip,s=d.top;else{if(!$.segsIntersect(e,i,t[2],t[3],!0))return{success:!1,loc:s,ip:r};r=$.getIntersectPt(e,i,t[2],t[3]).ip,s=d.bottom}break;case d.top:if($.segsIntersect(e,i,t[0],t[1],!0))r=$.getIntersectPt(e,i,t[0],t[1]).ip;else if(e.x<t[0].x&&$.segsIntersect(e,i,t[0],t[3],!0))r=$.getIntersectPt(e,i,t[0],t[3]).ip,s=d.left;else{if(!(e.x>t[1].x&&$.segsIntersect(e,i,t[1],t[2],!0)))return{success:!1,loc:s,ip:r};r=$.getIntersectPt(e,i,t[1],t[2]).ip,s=d.right}break;case d.bottom:if($.segsIntersect(e,i,t[2],t[3],!0))r=$.getIntersectPt(e,i,t[2],t[3]).ip;else if(e.x<t[3].x&&$.segsIntersect(e,i,t[0],t[3],!0))r=$.getIntersectPt(e,i,t[0],t[3]).ip,s=d.left;else{if(!(e.x>t[2].x&&$.segsIntersect(e,i,t[1],t[2],!0)))return{success:!1,loc:s,ip:r};r=$.getIntersectPt(e,i,t[1],t[2]).ip,s=d.right}break;case d.inside:if($.segsIntersect(e,i,t[0],t[3],!0))r=$.getIntersectPt(e,i,t[0],t[3]).ip,s=d.left;else if($.segsIntersect(e,i,t[0],t[1],!0))r=$.getIntersectPt(e,i,t[0],t[1]).ip,s=d.top;else if($.segsIntersect(e,i,t[1],t[2],!0))r=$.getIntersectPt(e,i,t[1],t[2]).ip,s=d.right;else{if(!$.segsIntersect(e,i,t[2],t[3],!0))return{success:!1,loc:s,ip:r};r=$.getIntersectPt(e,i,t[2],t[3]).ip,s=d.bottom}}return{success:!0,loc:s,ip:r}}getNextLocation(t,e){switch(e.loc){case d.left:for(;e.i<=e.highI&&t[e.i].x<=this.rect.left;)e.i++;if(e.i>e.highI)break;t[e.i].x>=this.rect.right?e.loc=d.right:t[e.i].y<=this.rect.top?e.loc=d.top:t[e.i].y>=this.rect.bottom?e.loc=d.bottom:e.loc=d.inside;break;case d.top:for(;e.i<=e.highI&&t[e.i].y<=this.rect.top;)e.i++;if(e.i>e.highI)break;t[e.i].y>=this.rect.bottom?e.loc=d.bottom:t[e.i].x<=this.rect.left?e.loc=d.left:t[e.i].x>=this.rect.right?e.loc=d.right:e.loc=d.inside;break;case d.right:for(;e.i<=e.highI&&t[e.i].x>=this.rect.right;)e.i++;if(e.i>e.highI)break;t[e.i].x<=this.rect.left?e.loc=d.left:t[e.i].y<=this.rect.top?e.loc=d.top:t[e.i].y>=this.rect.bottom?e.loc=d.bottom:e.loc=d.inside;break;case d.bottom:for(;e.i<=e.highI&&t[e.i].y>=this.rect.bottom;)e.i++;if(e.i>e.highI)break;t[e.i].y<=this.rect.top?e.loc=d.top:t[e.i].x<=this.rect.left?e.loc=d.left:t[e.i].x>=this.rect.right?e.loc=d.right:e.loc=d.inside;break;case d.inside:for(;e.i<=e.highI;){if(t[e.i].x<this.rect.left)e.loc=d.left;else if(t[e.i].x>this.rect.right)e.loc=d.right;else if(t[e.i].y>this.rect.bottom)e.loc=d.bottom;else if(t[e.i].y<this.rect.top)e.loc=d.top;else{this.add(t[e.i]),e.i++;continue}break}}}executeInternal(t){let e;if(t.length<3||this.rect.isEmpty())return;let i=[],s=d.inside,r=s,n=s,o=t.length-1,l=k.getLocation(this.rect,t[o]),a=l.loc;if(!l.success){for(e=o-1;e>=0&&!l.success;)e--,n=(l=k.getLocation(this.rect,t[e])).loc;if(e<0){for(let e of t)this.add(e);return}n==d.inside&&(a=d.inside)}let h=a;for(e=0;e<=o;){n=a;let l=r;if(this.getNextLocation(t,{loc:a,i:e,highI:o}),e>o)break;let h=0==e?t[o]:t[e-1];r=a;let p=k.getIntersection(this.rectPath,t[e],h,r),c=p.ip;if(!p.success){if(l==d.inside){let s=k.isClockwise(n,a,h,t[e],this.mp);do i.push(n),n=k.getAdjacentLocation(n,s);while(n!=a)r=l}else if(n!=d.inside&&n!=a){let i=k.isClockwise(n,a,h,t[e],this.mp);do this.addCornerByRef(n,i);while(n!=a)}++e;continue}if(a==d.inside){if(s==d.inside)s=r,i.push(n);else if(n!=r){let i=k.isClockwise(n,r,h,t[e],this.mp);do this.addCornerByRef(n,i);while(n!=r)}}else if(n!=d.inside){a=n,p=k.getIntersection(this.rectPath,h,t[e],a);let o=p.ip;if(l!=d.inside&&l!=a&&this.addCorner(l,a),s==d.inside&&(s=a,i.push(n)),a=r,this.add(o),c==o){a=k.getLocation(this.rect,t[e]).loc,this.addCorner(r,a),r=a;continue}}else a=r,s==d.inside&&(s=r);this.add(c)}if(s==d.inside){if(h!=d.inside&&this.pathBounds.containsRect(this.rect)&&k.path1ContainsPath2(t,this.rectPath))for(let t=0;t<4;t++)this.add(this.rectPath[t]),k.addToEdge(this.edges[2*t],this.results[0])}else if(a!=d.inside&&(a!=s||i.length>2)){if(i.length>0){for(let t of(n=a,i))n!=t&&(this.addCornerByRef(n,k.headingClockwise(n,t)),n=t);a=n}a!=s&&this.addCornerByRef(a,k.headingClockwise(a,s))}}execute(t){let e=[];if(this.rect.isEmpty())return e;for(let i of t)if(!(i.length<3)){if(this.pathBounds=R.getBounds(i),!this.rect.intersects(this.pathBounds))continue;if(this.rect.containsRect(this.pathBounds)){e.push(i);continue}this.executeInternal(i),this.checkEdges();for(let t=0;t<4;++t)this.tidyEdgePair(t,this.edges[2*t],this.edges[2*t+1]);for(let t of this.results){let i=this.getPath(t);i.length>0&&e.push(i)}this.results.length=0;for(let t=0;t<8;t++)this.edges[t].length=0}return e}checkEdges(){for(let t=0;t<this.results.length;t++){let e=this.results[t],i=e;if(void 0===e)continue;do if(0===$.crossProduct(i.prev.pt,i.pt,i.next.pt)){if(i===e){if(void 0===(i=k.unlinkOpBack(i)))break;e=i.prev}else if(void 0===(i=k.unlinkOpBack(i)))break}else i=i.next;while(i!==e)if(void 0===i){this.results[t]=void 0;continue}this.results[t]=i;let s=k.getEdgesForPt(e.prev.pt,this.rect);i=e;do{let t=k.getEdgesForPt(i.pt,this.rect);if(0!==t&&void 0===i.edge){let e=s&t;for(let t=0;t<4;++t)(e&1<<t)!=0&&(k.isHeadingClockwise(i.prev.pt,i.pt,t)?k.addToEdge(this.edges[2*t],i):k.addToEdge(this.edges[2*t+1],i))}s=t,i=i.next}while(i!==e)}}tidyEdgePair(t,e,i){let s,r,n,o,l,a;if(0===i.length)return;let h=1===t||3===t,p=1===t||2===t,c=0,u=0;for(;c<e.length;){let t,d;if(!(s=e[c])||s.next===s.prev){e[c++]=void 0,u=0;continue}let f=i.length;for(;u<f&&(!i[u]||i[u].next===i[u].prev);)++u;if(u===f){++c,u=0;continue}if(p?(s=e[c].prev,n=e[c],r=i[u],o=i[u].prev):(s=e[c],n=e[c].prev,r=i[u].prev,o=i[u]),h&&!k.hasHorzOverlap(s.pt,n.pt,r.pt,o.pt)||!h&&!k.hasVertOverlap(s.pt,n.pt,r.pt,o.pt)){++u;continue}let x=e[c].ownerIdx!==i[u].ownerIdx;if(x&&(this.results[r.ownerIdx]=void 0,k.setNewOwner(r,s.ownerIdx)),p?(s.next=r,r.prev=s,n.prev=o,o.next=n):(s.prev=r,r.next=s,n.next=o,o.prev=n),!x){let t=this.results.length;this.results.push(n),k.setNewOwner(n,t)}p?(l=r,a=n):(l=s,a=o),this.results[l.ownerIdx]=l,this.results[a.ownerIdx]=a,h?(t=l.pt.x>l.prev.pt.x,d=a.pt.x>a.prev.pt.x):(t=l.pt.y>l.prev.pt.y,d=a.pt.y>a.prev.pt.y),l.next===l.prev||l.pt===l.prev.pt?d===p?(e[c]=a,i[u++]=void 0):(i[u]=a,e[c++]=void 0):a.next===a.prev||a.pt===a.prev.pt?t===p?(e[c]=l,i[u++]=void 0):(i[u]=l,e[c++]=void 0):t===d?t===p?(e[c]=l,k.uncoupleEdge(a),k.addToEdge(e,a),i[u++]=void 0):(e[c++]=void 0,i[u]=a,k.uncoupleEdge(l),k.addToEdge(i,l),u=0):(t===p?e[c]=l:i[u]=l,d===p?e[c]=a:i[u]=a)}}getPath(t){let e=new W;if(!t||t.prev===t.next)return e;let i=t.next;for(;i&&i!==t;)0===$.crossProduct(i.prev.pt,i.pt,i.next.pt)?(t=i.prev,i=k.unlinkOp(i)):i=i.next;if(!i)return new W;for(e.push(t.pt),i=t.next;i!==t;)e.push(i.pt),i=i.next;return e}}class T extends k{constructor(t){super(t)}execute(t){let e=new Z;if(this.rect.isEmpty())return e;for(let i of t)if(!(i.length<2)&&(this.pathBounds=R.getBounds(i),this.rect.intersects(this.pathBounds))){for(let t of(this.executeInternal(i),this.results)){let i=this.getPath(t);i.length>0&&e.push(i)}this.results.length=0;for(let t=0;t<8;t++)this.edges[t].length=0}return e}getPath(t){let e=new W;if(!t||t===t.next)return e;t=t.next,e.push(t.pt);let i=t.next;for(;i!==t;)e.push(i.pt),i=i.next;return e}executeInternal(t){if(this.results=[],t.length<2||this.rect.isEmpty())return;let e=d.inside,i=1,s=t.length-1,r=T.getLocation(this.rect,t[0]),n=r.loc;if(!r.success){for(;i<=s&&!r.success;)i++,e=(r=T.getLocation(this.rect,t[i])).loc;if(i>s)for(let e of t)this.add(e);e==d.inside&&(n=d.inside),i=1}for(n==d.inside&&this.add(t[0]);i<=s&&(e=n,this.getNextLocation(t,{loc:n,i:i,highI:s}),!(i>s));){let s=t[i-1],r=n,o=T.getIntersection(this.rectPath,t[i],s,r),l=o.ip;if(r=o.loc,!o.success){i++;continue}if(n==d.inside)this.add(l,!0);else if(e!==d.inside){r=e,o=T.getIntersection(this.rectPath,s,t[i],r);let n=o.ip;r=o.loc,this.add(n),this.add(l)}else this.add(l)}}}class R{static get InvalidRect64(){return R.invalidRect64||(R.invalidRect64=new G(!1)),this.invalidRect64}static Intersect(t,e,i){return this.BooleanOp(v.Intersection,t,e,i)}static Union(t,e,i=w.EvenOdd){return this.BooleanOp(v.Union,t,e,i)}static Difference(t,e,i){return this.BooleanOp(v.Difference,t,e,i)}static Xor(t,e,i){return this.BooleanOp(v.Xor,t,e,i)}static BooleanOp(t,e,i,s=w.EvenOdd){let r=new Z;if(!e)return r;let n=new U;return n.addPaths(e,P.Subject),i&&n.addPaths(i,P.Clip),n.execute(t,s,r),r}static InflatePaths(t,e,i,s,r=2){let n=new S(r);n.addPaths(t,i,s);let o=new Z;return n.execute(e,o),o}static RectClipPaths(t,e){if(t.isEmpty()||0===e.length)return new Z;let i=new k(t);return i.execute(e)}static RectClip(t,e){if(t.isEmpty()||0===e.length)return new Z;let i=new Z;return i.push(e),this.RectClipPaths(t,i)}static RectClipLinesPaths(t,e){if(t.isEmpty()||0===e.length)return new Z;let i=new T(t);return i.execute(e)}static RectClipLines(t,e){if(t.isEmpty()||0===e.length)return new Z;let i=new Z;return i.push(e),this.RectClipLinesPaths(t,i)}static MinkowskiSum(t,e,i){return O.sum(t,e,i)}static MinkowskiDiff(t,e,i){return O.diff(t,e,i)}static area(t){let e=0,i=t.length;if(i<3)return 0;let s=t[i-1];for(let i of t)e+=(s.y+i.y)*(s.x-i.x),s=i;return .5*e}static areaPaths(t){let e=0;for(let i of t)e+=this.area(i);return e}static isPositive(t){return this.area(t)>=0}static path64ToString(t){let e="";for(let i of t)e+=i.toString();return e+"\n"}static paths64ToString(t){let e="";for(let i of t)e+=this.path64ToString(i);return e}static offsetPath(t,e,i){let s=new W;for(let r of t)s.push(new Y(r.x+e,r.y+i));return s}static scalePoint64(t,e){let i=new Y(Math.round(t.x*e),Math.round(t.y*e));return i}static scalePath(t,e){if($.isAlmostZero(e-1))return t;let i=[];for(let s of t)i.push({x:s.x*e,y:s.y*e});return i}static scalePaths(t,e){if($.isAlmostZero(e-1))return t;let i=[];for(let s of t)i.push(this.scalePath(s,e));return i}static translatePath(t,e,i){let s=[];for(let r of t)s.push({x:r.x+e,y:r.y+i});return s}static translatePaths(t,e,i){let s=[];for(let r of t)s.push(this.translatePath(r,e,i));return s}static reversePath(t){return[...t].reverse()}static reversePaths(t){let e=[];for(let i of t)e.push(this.reversePath(i));return e}static getBounds(t){let e=R.InvalidRect64;for(let i of t)i.x<e.left&&(e.left=i.x),i.x>e.right&&(e.right=i.x),i.y<e.top&&(e.top=i.y),i.y>e.bottom&&(e.bottom=i.y);return e.left===Number.MAX_SAFE_INTEGER?new G(0,0,0,0):e}static getBoundsPaths(t){let e=R.InvalidRect64;for(let i of t)for(let t of i)t.x<e.left&&(e.left=t.x),t.x>e.right&&(e.right=t.x),t.y<e.top&&(e.top=t.y),t.y>e.bottom&&(e.bottom=t.y);return e.left===Number.MAX_SAFE_INTEGER?new G(0,0,0,0):e}static makePath(t){let e=t.length/2,i=new W;for(let s=0;s<e;s++)i.push(new Y(t[2*s],t[2*s+1]));return i}static stripDuplicates(t,e){let i=t.length,s=new W;if(0===i)return s;let r=t[0];s.push(r);for(let e=1;e<i;e++)r!==t[e]&&(r=t[e],s.push(r));return e&&r===s[0]&&s.pop(),s}static addPolyNodeToPaths(t,e){t.polygon&&t.polygon.length>0&&e.push(t.polygon);for(let i=0;i<t.count;i++)this.addPolyNodeToPaths(t.children[i],e)}static polyTreeToPaths64(t){let e=new Z;for(let i=0;i<t.count;i++)R.addPolyNodeToPaths(t.children[i],e);return e}static perpendicDistFromLineSqrd(t,e,i){let s=t.x-e.x,r=t.y-e.y,n=i.x-e.x,o=i.y-e.y;return 0===n&&0===o?0:R.sqr(s*o-n*r)/(n*n+o*o)}static rdp(t,e,i,s,r){let n=0,o=0;for(;i>e&&t[e]===t[i];)r[i--]=!1;for(let s=e+1;s<i;s++){let r=R.perpendicDistFromLineSqrd(t[s],t[e],t[i]);r<=o||(o=r,n=s)}!(o<=s)&&(r[n]=!0,n>e+1&&R.rdp(t,e,n,s,r),n<i-1&&R.rdp(t,n,i,s,r))}static ramerDouglasPeucker(t,e){let i=t.length;if(i<5)return t;let s=Array(i).fill(!1);s[0]=!0,s[i-1]=!0,R.rdp(t,0,i-1,R.sqr(e),s);let r=[];for(let e=0;e<i;e++)s[e]&&r.push(t[e]);return r}static ramerDouglasPeuckerPaths(t,e){let i=[];for(let s of t)i.push(R.ramerDouglasPeucker(s,e));return i}static getNext(t,e,i){for(t++;t<=e&&i[t];)t++;if(t<=e)return t;for(t=0;i[t];)t++;return t}static getPrior(t,e,i){for(0===t?t=e:t--;t>0&&i[t];)t--;if(!i[t])return t;for(t=e;i[t];)t--;return t}static sqr(t){return t*t}static simplifyPath(t,e,i=!1){let s,r,n,o;let l=t.length,a=l-1,h=this.sqr(e);if(l<4)return t;let p=Array(l).fill(!1),c=Array(l).fill(0),u=a,d=0;i?(c[0]=this.perpendicDistFromLineSqrd(t[0],t[a],t[1]),c[a]=this.perpendicDistFromLineSqrd(t[a],t[0],t[a-1])):(c[0]=Number.MAX_VALUE,c[a]=Number.MAX_VALUE);for(let e=1;e<a;e++)c[e]=this.perpendicDistFromLineSqrd(t[e],t[e-1],t[e+1]);for(;;){if(c[d]>h){s=d;do d=this.getNext(d,a,p);while(d!==s&&c[d]>h)if(d===s)break}if(u=this.getPrior(d,a,p),(r=this.getNext(d,a,p))===u)break;c[r]<c[d]?(p[r]=!0,r=this.getNext(r,a,p),o=this.getNext(r,a,p),c[d]=this.perpendicDistFromLineSqrd(t[d],t[u],t[r]),(r!==a||i)&&(c[r]=this.perpendicDistFromLineSqrd(t[r],t[d],t[o])),d=r):(p[d]=!0,d=r,r=this.getNext(r,a,p),n=this.getPrior(u,a,p),c[d]=this.perpendicDistFromLineSqrd(t[d],t[u],t[r]),(0!==u||i)&&(c[u]=this.perpendicDistFromLineSqrd(t[u],t[n],t[d])))}let f=[];for(let e=0;e<l;e++)p[e]||f.push(t[e]);return f}static simplifyPaths(t,e,i=!1){let s=[];for(let r of t)s.push(this.simplifyPath(r,e,i));return s}static trimCollinear(t,e=!1){let i=t.length,s=0;if(!e){for(;s<i-1&&0===$.crossProduct(t[i-1],t[s],t[s+1]);)s++;for(;s<i-1&&0===$.crossProduct(t[i-2],t[i-1],t[s]);)i--}if(i-s<3)return!e||i<2||t[0]===t[1]?[]:t;let r=[],n=t[s];for(r.push(n),s++;s<i-1;s++)0!==$.crossProduct(n,t[s],t[s+1])&&(n=t[s],r.push(n));if(e)r.push(t[i-1]);else if(0!==$.crossProduct(n,t[i-1],r[0]))r.push(t[i-1]);else{for(;r.length>2&&0===$.crossProduct(r[r.length-1],r[r.length-2],r[0]);)r.pop();r.length<3&&r.splice(0,r.length)}return r}static pointInPolygon(t,e){return $.pointInPolygon(t,e)}static ellipse(t,e,i=0,s=0){if(e<=0)return[];i<=0&&(i=e),s<=2&&(s=Math.ceil(Math.PI*Math.sqrt((e+i)/2)));let r=Math.sin(2*Math.PI/s),n=Math.cos(2*Math.PI/s),o=n,l=r,a=[{x:t.x+e,y:t.y}];for(let h=1;h<s;++h){a.push({x:t.x+e*o,y:t.y+i*l});let s=o*n-l*r;l=l*n+o*r,o=s}return a}static showPolyPathStructure(t,e){let i=" ".repeat(2*e),s=t.isHole?"Hole ":"Outer ";0===t.count?console.log(i+s):(console.log(i+s+`(${t.count})`),t.forEach(t=>this.showPolyPathStructure(t,e+1)))}static showPolyTreeStructure(t){console.log("Polytree Root"),t.forEach(t=>this.showPolyPathStructure(t,1))}}(s=f||(f={}))[s.IsOn=0]="IsOn",s[s.IsInside=1]="IsInside",s[s.IsOutside=2]="IsOutside",(r=x||(x={}))[r.None=0]="None",r[r.OpenStart=1]="OpenStart",r[r.OpenEnd=2]="OpenEnd",r[r.LocalMax=4]="LocalMax",r[r.LocalMin=8]="LocalMin";class D{constructor(t,e,i){this.pt=t,this.flags=e,this.next=void 0,this.prev=i}}class N{constructor(t,e,i=!1){this.vertex=t,this.polytype=e,this.isOpen=i}static equals(t,e){return t.vertex===e.vertex}static notEquals(t,e){return t.vertex!==e.vertex}}class H{constructor(t,e,i){this.pt=t,this.edge1=e,this.edge2=i}}class z{constructor(t,e){this.pt=t,this.outrec=e,this.next=this,this.prev=this,this.horz=void 0}}(n=g||(g={}))[n.None=0]="None",n[n.Left=1]="Left",n[n.Right=2]="Right",(o=y||(y={}))[o.Bottom=0]="Bottom",o[o.Middle=1]="Middle",o[o.Top=2]="Top";class X{constructor(t){this.idx=t,this.isOpen=!1}}class B{constructor(t){this.leftOp=t,this.rightOp=void 0,this.leftToRight=!0}}class j{constructor(t,e){this.op1=t,this.op2=e}}class F{constructor(){this.dx=this.windCount=this.windCount2=0,this.isLeftBound=!1,this.joinWith=g.None}}class V{static addLocMin(t,e,i,s){if((t.flags&x.LocalMin)!==x.None)return;t.flags|=x.LocalMin;let r=new N(t,e,i);s.push(r)}static addPathsToVertexList(t,e,i,s,r){let n=0;for(let e of t)n+=e.length;for(let o of t){let t,l,a;for(let e of o)t?l.pt!==e&&(a=new D(e,x.None,l),r.push(a),l.next=a,l=a):(t=new D(e,x.None,void 0),r.push(t),l=t);if(!l||!l.prev||(i||l.pt!==t.pt||(l=l.prev),l.next=t,t.prev=l,!i&&l.next===l))continue;let h=!1;if(i){a=t.next;let i=0;for(;a!==t&&a.pt.y===t.pt.y;)if(a=a.next,i++>n){console.warn("infinite loop detected");break}(h=a.pt.y<=t.pt.y)?(t.flags=x.OpenStart,this.addLocMin(t,e,!0,s)):t.flags=x.OpenStart|x.LocalMax}else{l=t.prev;let e=0;for(;l!==t&&l.pt.y===t.pt.y;)if(l=l.prev,e++>n){console.warn("infinite loop detected");break}if(l===t)continue;h=l.pt.y>t.pt.y}let p=h;l=t,a=t.next;let c=0;for(;a!==t;)if(a.pt.y>l.pt.y&&h?(l.flags|=x.LocalMax,h=!1):a.pt.y<l.pt.y&&!h&&(h=!0,this.addLocMin(l,e,i,s)),l=a,a=a.next,c++>n){console.warn("infinite loop detected");break}i?(l.flags|=x.OpenEnd,h?l.flags|=x.LocalMax:this.addLocMin(l,e,i,s)):h!==p&&(p?this.addLocMin(l,e,!1,s):l.flags|=x.LocalMax)}}}class q{constructor(){this.items=[],this.items=[]}clear(){this.items.length=0}isEmpty(){return 0==this.items.length}pollLast(){return this.items.pop()}add(t){this.items.includes(t)||(this.items.push(t),this.items.sort((t,e)=>t-e))}}class J{constructor(){this._cliptype=v.None,this._fillrule=w.EvenOdd,this._currentLocMin=0,this._currentBotY=0,this._isSortedMinimaList=!1,this._hasOpenPaths=!1,this._using_polytree=!1,this._succeeded=!1,this.reverseSolution=!1,this._minimaList=[],this._intersectList=[],this._vertexList=[],this._outrecList=[],this._scanlineList=new q,this._horzSegList=[],this._horzJoinList=[],this.preserveCollinear=!0}static isOdd(t){return(1&t)!=0}static isHotEdgeActive(t){return void 0!==t.outrec}static isOpen(t){return t.localMin.isOpen}static isOpenEndActive(t){return t.localMin.isOpen&&J.isOpenEnd(t.vertexTop)}static isOpenEnd(t){return(t.flags&(x.OpenStart|x.OpenEnd))!==x.None}static getPrevHotEdge(t){let e=t.prevInAEL;for(;e&&(J.isOpen(e)||!J.isHotEdgeActive(e));)e=e.prevInAEL;return e}static isFront(t){return t===t.outrec.frontEdge}static getDx(t,e){let i=e.y-t.y;return 0!==i?(e.x-t.x)/i:e.x>t.x?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY}static topX(t,e){return e===t.top.y||t.top.x===t.bot.x?t.top.x:e===t.bot.y?t.bot.x:t.bot.x+Math.round(t.dx*(e-t.bot.y))}static isHorizontal(t){return t.top.y===t.bot.y}static isHeadingRightHorz(t){return Number.NEGATIVE_INFINITY===t.dx}static isHeadingLeftHorz(t){return Number.POSITIVE_INFINITY===t.dx}static swapActives(t,e){[e,t]=[t,e]}static getPolyType(t){return t.localMin.polytype}static isSamePolyType(t,e){return t.localMin.polytype===e.localMin.polytype}static setDx(t){t.dx=J.getDx(t.bot,t.top)}static nextVertex(t){return t.windDx>0?t.vertexTop.next:t.vertexTop.prev}static prevPrevVertex(t){return t.windDx>0?t.vertexTop.prev.prev:t.vertexTop.next.next}static isMaxima(t){return(t.flags&x.LocalMax)!==x.None}static isMaximaActive(t){return J.isMaxima(t.vertexTop)}static getMaximaPair(t){let e=t.nextInAEL;for(;e;){if(e.vertexTop===t.vertexTop)return e;e=e.nextInAEL}}static getCurrYMaximaVertex_Open(t){let e=t.vertexTop;if(t.windDx>0)for(;e.next.pt.y===e.pt.y&&(e.flags&(x.OpenEnd|x.LocalMax))===x.None;)e=e.next;else for(;e.prev.pt.y===e.pt.y&&(e.flags&(x.OpenEnd|x.LocalMax))===x.None;)e=e.prev;return J.isMaxima(e)||(e=void 0),e}static getCurrYMaximaVertex(t){let e=t.vertexTop;if(t.windDx>0)for(;e.next.pt.y===e.pt.y;)e=e.next;else for(;e.prev.pt.y===e.pt.y;)e=e.prev;return J.isMaxima(e)||(e=void 0),e}static setSides(t,e,i){t.frontEdge=e,t.backEdge=i}static swapOutrecs(t,e){let i=t.outrec,s=e.outrec;if(i===s){let t=i.frontEdge;i.frontEdge=i.backEdge,i.backEdge=t;return}i&&(t===i.frontEdge?i.frontEdge=e:i.backEdge=e),s&&(e===s.frontEdge?s.frontEdge=t:s.backEdge=t),t.outrec=s,e.outrec=i}static setOwner(t,e){for(;e.owner&&!e.owner.pts;)e.owner=e.owner.owner;let i=e;for(;i&&i!==t;)i=i.owner;i&&(e.owner=t.owner),t.owner=e}static area(t){let e=0,i=t;do e+=(i.prev.pt.y+i.pt.y)*(i.prev.pt.x-i.pt.x),i=i.next;while(i!==t)return .5*e}static areaTriangle(t,e,i){return(i.y+t.y)*(i.x-t.x)+(t.y+e.y)*(t.x-e.x)+(e.y+i.y)*(e.x-i.x)}static getRealOutRec(t){for(;void 0!==t&&void 0===t.pts;)t=t.owner;return t}static isValidOwner(t,e){for(;void 0!==e&&e!==t;)e=e.owner;return void 0===e}static uncoupleOutRec(t){let e=t.outrec;void 0!==e&&(e.frontEdge.outrec=void 0,e.backEdge.outrec=void 0,e.frontEdge=void 0,e.backEdge=void 0)}static outrecIsAscending(t){return t===t.outrec.frontEdge}static swapFrontBackSides(t){let e=t.frontEdge;t.frontEdge=t.backEdge,t.backEdge=e,t.pts=t.pts.next}static edgesAdjacentInAEL(t){return t.edge1.nextInAEL===t.edge2||t.edge1.prevInAEL===t.edge2}clearSolutionOnly(){for(;this._actives;)this.deleteFromAEL(this._actives);this._scanlineList.clear(),this.disposeIntersectNodes(),this._outrecList.length=0,this._horzSegList.length=0,this._horzJoinList.length=0}clear(){this.clearSolutionOnly(),this._minimaList.length=0,this._vertexList.length=0,this._currentLocMin=0,this._isSortedMinimaList=!1,this._hasOpenPaths=!1}reset(){this._isSortedMinimaList||(this._minimaList.sort((t,e)=>e.vertex.pt.y-t.vertex.pt.y),this._isSortedMinimaList=!0);for(let t=this._minimaList.length-1;t>=0;t--)this._scanlineList.add(this._minimaList[t].vertex.pt.y);this._currentBotY=0,this._currentLocMin=0,this._actives=void 0,this._sel=void 0,this._succeeded=!0}insertScanline(t){this._scanlineList.add(t)}popScanline(){return this._scanlineList.pollLast()}hasLocMinAtY(t){return this._currentLocMin<this._minimaList.length&&this._minimaList[this._currentLocMin].vertex.pt.y==t}popLocalMinima(){return this._minimaList[this._currentLocMin++]}addLocMin(t,e,i){if((t.flags&x.LocalMin)!=x.None)return;t.flags|=x.LocalMin;let s=new N(t,e,i);this._minimaList.push(s)}addSubject(t){this.addPath(t,P.Subject)}addOpenSubject(t){this.addPath(t,P.Subject,!0)}addClip(t){this.addPath(t,P.Clip)}addPath(t,e,i=!1){let s=[t];this.addPaths(s,e,i)}addPaths(t,e,i=!1){i&&(this._hasOpenPaths=!0),this._isSortedMinimaList=!1,V.addPathsToVertexList(t,e,i,this._minimaList,this._vertexList)}addReuseableData(t){if(0!==t._minimaList.length)for(let e of(this._isSortedMinimaList=!1,t._minimaList))this._minimaList.push(new N(e.vertex,e.polytype,e.isOpen)),e.isOpen&&(this._hasOpenPaths=!0)}isContributingClosed(t){switch(this._fillrule){case w.Positive:if(1!==t.windCount)return!1;break;case w.Negative:if(-1!==t.windCount)return!1;break;case w.NonZero:if(1!==Math.abs(t.windCount))return!1}switch(this._cliptype){case v.Intersection:switch(this._fillrule){case w.Positive:return t.windCount2>0;case w.Negative:return t.windCount2<0;default:return 0!==t.windCount2}case v.Union:switch(this._fillrule){case w.Positive:return t.windCount2<=0;case w.Negative:return t.windCount2>=0;default:return 0===t.windCount2}case v.Difference:let e=this._fillrule===w.Positive?t.windCount2<=0:this._fillrule===w.Negative?t.windCount2>=0:0===t.windCount2;return J.getPolyType(t)===P.Subject?e:!e;case v.Xor:return!0;default:return!1}}isContributingOpen(t){let e,i;switch(this._fillrule){case w.Positive:i=t.windCount>0,e=t.windCount2>0;break;case w.Negative:i=t.windCount<0,e=t.windCount2<0;break;default:i=0!==t.windCount,e=0!==t.windCount2}switch(this._cliptype){case v.Intersection:return e;case v.Union:return!i&&!e;default:return!e}}setWindCountForClosedPathEdge(t){let e=t.prevInAEL,i=J.getPolyType(t);for(;void 0!==e&&(J.getPolyType(e)!==i||J.isOpen(e));)e=e.prevInAEL;if(void 0===e?(t.windCount=t.windDx,e=this._actives):(this._fillrule===w.EvenOdd?t.windCount=t.windDx:e.windCount*e.windDx<0?Math.abs(e.windCount)>1?e.windDx*t.windDx<0?t.windCount=e.windCount:t.windCount=e.windCount+t.windDx:t.windCount=J.isOpen(t)?1:t.windDx:e.windDx*t.windDx<0?t.windCount=e.windCount:t.windCount=e.windCount+t.windDx,t.windCount2=e.windCount2,e=e.nextInAEL),this._fillrule===w.EvenOdd)for(;e!==t;)J.getPolyType(e)===i||J.isOpen(e)||(t.windCount2=0===t.windCount2?1:0),e=e.nextInAEL;else for(;e!==t;)J.getPolyType(e)===i||J.isOpen(e)||(t.windCount2+=e.windDx),e=e.nextInAEL}setWindCountForOpenPathEdge(t){let e=this._actives;if(this._fillrule===w.EvenOdd){let i=0,s=0;for(;e!==t;)J.getPolyType(e)===P.Clip?s++:!J.isOpen(e)&&i++,e=e.nextInAEL;t.windCount=J.isOdd(i)?1:0,t.windCount2=J.isOdd(s)?1:0}else for(;e!==t;)J.getPolyType(e)===P.Clip?t.windCount2+=e.windDx:J.isOpen(e)||(t.windCount+=e.windDx),e=e.nextInAEL}static isValidAelOrder(t,e){if(e.curX!==t.curX)return e.curX>t.curX;let i=$.crossProduct(t.top,e.bot,e.top);if(0!==i)return i<0;if(!this.isMaximaActive(t)&&t.top.y>e.top.y)return 0>=$.crossProduct(e.bot,t.top,this.nextVertex(t).pt);if(!this.isMaximaActive(e)&&e.top.y>t.top.y)return $.crossProduct(e.bot,e.top,this.nextVertex(e).pt)>=0;let s=e.bot.y,r=e.isLeftBound;return t.bot.y!==s||t.localMin.vertex.pt.y!==s?e.isLeftBound:t.isLeftBound!==r?r:0===$.crossProduct(this.prevPrevVertex(t).pt,t.bot,t.top)||$.crossProduct(this.prevPrevVertex(t).pt,e.bot,this.prevPrevVertex(e).pt)>0===r}insertLeftEdge(t){let e;if(this._actives){if(J.isValidAelOrder(this._actives,t)){for(e=this._actives;e.nextInAEL&&J.isValidAelOrder(e.nextInAEL,t);)e=e.nextInAEL;e.joinWith===g.Right&&(e=e.nextInAEL),t.nextInAEL=e.nextInAEL,e.nextInAEL&&(e.nextInAEL.prevInAEL=t),t.prevInAEL=e,e.nextInAEL=t}else t.prevInAEL=void 0,t.nextInAEL=this._actives,this._actives.prevInAEL=t,this._actives=t}else t.prevInAEL=void 0,t.nextInAEL=void 0,this._actives=t}static insertRightEdge(t,e){e.nextInAEL=t.nextInAEL,t.nextInAEL&&(t.nextInAEL.prevInAEL=e),e.prevInAEL=t,t.nextInAEL=e}insertLocalMinimaIntoAEL(t){let e,i,s;for(;this.hasLocMinAtY(t);){((e=this.popLocalMinima()).vertex.flags&x.OpenStart)!==x.None?i=void 0:((i=new F).bot=e.vertex.pt,i.curX=e.vertex.pt.x,i.windDx=-1,i.vertexTop=e.vertex.prev,i.top=e.vertex.prev.pt,i.outrec=void 0,i.localMin=e,J.setDx(i)),(e.vertex.flags&x.OpenEnd)!==x.None?s=void 0:((s=new F).bot=e.vertex.pt,s.curX=e.vertex.pt.x,s.windDx=1,s.vertexTop=e.vertex.next,s.top=e.vertex.next.pt,s.outrec=void 0,s.localMin=e,J.setDx(s)),i&&s?J.isHorizontal(i)?J.isHeadingRightHorz(i)&&([s,i]=[i,s]):J.isHorizontal(s)?J.isHeadingLeftHorz(s)&&([s,i]=[i,s]):i.dx<s.dx&&([s,i]=[i,s]):void 0===i&&(i=s,s=void 0);let t=!1;if(i.isLeftBound=!0,this.insertLeftEdge(i),J.isOpen(i)?(this.setWindCountForOpenPathEdge(i),t=this.isContributingOpen(i)):(this.setWindCountForClosedPathEdge(i),t=this.isContributingClosed(i)),s){for(s.windCount=i.windCount,s.windCount2=i.windCount2,J.insertRightEdge(i,s),t&&(this.addLocalMinPoly(i,s,i.bot,!0),J.isHorizontal(i)||this.checkJoinLeft(i,i.bot));s.nextInAEL&&J.isValidAelOrder(s.nextInAEL,s);)this.intersectEdges(s,s.nextInAEL,s.bot),this.swapPositionsInAEL(s,s.nextInAEL);J.isHorizontal(s)?this.pushHorz(s):(this.checkJoinRight(s,s.bot),this.insertScanline(s.top.y))}else t&&this.startOpenPath(i,i.bot);J.isHorizontal(i)?this.pushHorz(i):this.insertScanline(i.top.y)}}pushHorz(t){t.nextInSEL=this._sel,this._sel=t}popHorz(){let t=this._sel;if(void 0!==this._sel)return this._sel=this._sel.nextInSEL,t}addLocalMinPoly(t,e,i,s=!1){let r=this.newOutRec();if(t.outrec=r,e.outrec=r,J.isOpen(t))r.owner=void 0,r.isOpen=!0,t.windDx>0?J.setSides(r,t,e):J.setSides(r,e,t);else{r.isOpen=!1;let i=J.getPrevHotEdge(t);i?(this._using_polytree&&J.setOwner(r,i.outrec),r.owner=i.outrec,J.outrecIsAscending(i)===s?J.setSides(r,e,t):J.setSides(r,t,e)):(r.owner=void 0,s?J.setSides(r,t,e):J.setSides(r,e,t))}let n=new z(i,r);return r.pts=n,n}addLocalMaxPoly(t,e,i){if(J.isJoined(t)&&this.split(t,i),J.isJoined(e)&&this.split(e,i),J.isFront(t)===J.isFront(e)){if(J.isOpenEndActive(t))J.swapFrontBackSides(t.outrec);else if(J.isOpenEndActive(e))J.swapFrontBackSides(e.outrec);else{this._succeeded=!1;return}}let s=J.addOutPt(t,i);if(t.outrec===e.outrec){let e=t.outrec;if(e.pts=s,this._using_polytree){let i=J.getPrevHotEdge(t);void 0===i?e.owner=void 0:J.setOwner(e,i.outrec)}J.uncoupleOutRec(t)}else J.isOpen(t)?t.windDx<0?J.joinOutrecPaths(t,e):J.joinOutrecPaths(e,t):t.outrec.idx<e.outrec.idx?J.joinOutrecPaths(t,e):J.joinOutrecPaths(e,t);return s}static joinOutrecPaths(t,e){let i=t.outrec.pts,s=e.outrec.pts,r=i.next,n=s.next;J.isFront(t)?(n.prev=i,i.next=n,s.next=r,r.prev=s,t.outrec.pts=s,t.outrec.frontEdge=e.outrec.frontEdge,t.outrec.frontEdge&&(t.outrec.frontEdge.outrec=t.outrec)):(r.prev=s,s.next=r,i.next=n,n.prev=i,t.outrec.backEdge=e.outrec.backEdge,t.outrec.backEdge&&(t.outrec.backEdge.outrec=t.outrec)),e.outrec.frontEdge=void 0,e.outrec.backEdge=void 0,e.outrec.pts=void 0,J.setOwner(e.outrec,t.outrec),J.isOpenEndActive(t)&&(e.outrec.pts=t.outrec.pts,t.outrec.pts=void 0),t.outrec=void 0,e.outrec=void 0}static addOutPt(t,e){let i=t.outrec,s=J.isFront(t),r=i.pts,n=r.next;if(s&&e==r.pt)return r;if(!s&&e==n.pt)return n;let o=new z(e,i);return n.prev=o,o.prev=r,o.next=n,r.next=o,s&&(i.pts=o),o}newOutRec(){let t=new X(this._outrecList.length);return this._outrecList.push(t),t}startOpenPath(t,e){let i=this.newOutRec();i.isOpen=!0,t.windDx>0?(i.frontEdge=t,i.backEdge=void 0):(i.frontEdge=void 0,i.backEdge=t),t.outrec=i;let s=new z(e,i);return i.pts=s,s}updateEdgeIntoAEL(t){t.bot=t.top,t.vertexTop=J.nextVertex(t),t.top=t.vertexTop.pt,t.curX=t.bot.x,J.setDx(t),J.isJoined(t)&&this.split(t,t.bot),J.isHorizontal(t)||(this.insertScanline(t.top.y),this.checkJoinLeft(t,t.bot),this.checkJoinRight(t,t.bot,!0))}static findEdgeWithMatchingLocMin(t){let e=t.nextInAEL;for(;e;){if(e.localMin===t.localMin)return e;e=J.isHorizontal(e)||t.bot===e.bot?e.nextInAEL:void 0}for(e=t.prevInAEL;e&&e.localMin!==t.localMin;){if(!J.isHorizontal(e)&&t.bot!==e.bot)return;e=e.prevInAEL}return e}intersectEdges(t,e,i){let s,r,n;if(this._hasOpenPaths&&(J.isOpen(t)||J.isOpen(e))){if(J.isOpen(t)&&J.isOpen(e))return;if(J.isOpen(e)&&J.swapActives(t,e),J.isJoined(e)&&this.split(e,i),this._cliptype===v.Union){if(!J.isHotEdgeActive(e))return}else if(e.localMin.polytype===P.Subject)return;switch(this._fillrule){case w.Positive:if(1!==e.windCount)return;break;case w.Negative:if(-1!==e.windCount)return;break;default:if(1!==Math.abs(e.windCount))return}if(J.isHotEdgeActive(t))n=J.addOutPt(t,i),J.isFront(t)?t.outrec.frontEdge=void 0:t.outrec.backEdge=void 0,t.outrec=void 0;else if(i!==t.localMin.vertex.pt||J.isOpenEnd(t.localMin.vertex))n=this.startOpenPath(t,i);else{let e=J.findEdgeWithMatchingLocMin(t);if(e&&J.isHotEdgeActive(e))return t.outrec=e.outrec,t.windDx>0?J.setSides(e.outrec,t,e):J.setSides(e.outrec,e,t),e.outrec.pts;n=this.startOpenPath(t,i)}return n}switch(J.isJoined(t)&&this.split(t,i),J.isJoined(e)&&this.split(e,i),t.localMin.polytype===e.localMin.polytype?this._fillrule===w.EvenOdd?(s=t.windCount,t.windCount=e.windCount,e.windCount=s):(t.windCount+e.windDx===0?t.windCount=-t.windCount:t.windCount+=e.windDx,e.windCount-t.windDx==0?e.windCount=-e.windCount:e.windCount-=t.windDx):(this._fillrule!==w.EvenOdd?t.windCount2+=e.windDx:t.windCount2=0===t.windCount2?1:0,this._fillrule!==w.EvenOdd?e.windCount2-=t.windDx:e.windCount2=0===e.windCount2?1:0),this._fillrule){case w.Positive:s=t.windCount,r=e.windCount;break;case w.Negative:s=-t.windCount,r=-e.windCount;break;default:s=Math.abs(t.windCount),r=Math.abs(e.windCount)}let o=0===s||1===s,l=0===r||1===r;if((J.isHotEdgeActive(t)||o)&&(J.isHotEdgeActive(e)||l)){if(J.isHotEdgeActive(t)&&J.isHotEdgeActive(e))0!==s&&1!==s||0!==r&&1!==r||t.localMin.polytype!==e.localMin.polytype&&this._cliptype!==v.Xor?n=this.addLocalMaxPoly(t,e,i):J.isFront(t)||t.outrec===e.outrec?(n=this.addLocalMaxPoly(t,e,i),this.addLocalMinPoly(t,e,i)):(n=J.addOutPt(t,i),J.addOutPt(e,i),J.swapOutrecs(t,e));else if(J.isHotEdgeActive(t))n=J.addOutPt(t,i),J.swapOutrecs(t,e);else if(J.isHotEdgeActive(e))n=J.addOutPt(e,i),J.swapOutrecs(t,e);else{let o,l;switch(this._fillrule){case w.Positive:o=t.windCount2,l=e.windCount2;break;case w.Negative:o=-t.windCount2,l=-e.windCount2;break;default:o=Math.abs(t.windCount2),l=Math.abs(e.windCount2)}if(J.isSamePolyType(t,e)){if(1===s&&1===r)switch(n=void 0,this._cliptype){case v.Union:if(o>0&&l>0)return;n=this.addLocalMinPoly(t,e,i);break;case v.Difference:(J.getPolyType(t)===P.Clip&&o>0&&l>0||J.getPolyType(t)===P.Subject&&o<=0&&l<=0)&&(n=this.addLocalMinPoly(t,e,i));break;case v.Xor:n=this.addLocalMinPoly(t,e,i);break;default:if(o<=0||l<=0)return;n=this.addLocalMinPoly(t,e,i)}}else n=this.addLocalMinPoly(t,e,i)}return n}}deleteFromAEL(t){let e=t.prevInAEL,i=t.nextInAEL;(e||i||t===this._actives)&&(e?e.nextInAEL=i:this._actives=i,i&&(i.prevInAEL=e))}adjustCurrXAndCopyToSEL(t){let e=this._actives;for(this._sel=e;e;)e.prevInSEL=e.prevInAEL,e.nextInSEL=e.nextInAEL,e.jump=e.nextInSEL,e.joinWith===g.Left?e.curX=e.prevInAEL.curX:e.curX=J.topX(e,t),e=e.nextInAEL}executeInternal(t,e){if(t===v.None)return;this._fillrule=e,this._cliptype=t,this.reset();let i=this.popScanline();if(void 0!==i){for(;this._succeeded;){this.insertLocalMinimaIntoAEL(i);let t=this.popHorz();for(;t;)this.doHorizontal(t),t=this.popHorz();if(this._horzSegList.length>0&&(this.convertHorzSegsToJoins(),this._horzSegList.length=0),this._currentBotY=i,void 0===(i=this.popScanline()))break;for(this.doIntersections(i),this.doTopOfScanbeam(i),t=this.popHorz();t;)this.doHorizontal(t),t=this.popHorz()}this._succeeded&&this.processHorzJoins()}}doIntersections(t){this.buildIntersectList(t)&&(this.processIntersectList(),this.disposeIntersectNodes())}disposeIntersectNodes(){this._intersectList.length=0}addNewIntersectNode(t,e,i){let s=$.getIntersectPt(t.bot,t.top,e.bot,e.top),r=s.ip;if(s.success||(r=new Y(t.curX,i)),r.y>this._currentBotY||r.y<i){let s=Math.abs(t.dx),n=Math.abs(e.dx);s>100&&n>100?r=s>n?$.getClosestPtOnSegment(r,t.bot,t.top):$.getClosestPtOnSegment(r,e.bot,e.top):s>100?r=$.getClosestPtOnSegment(r,t.bot,t.top):n>100?r=$.getClosestPtOnSegment(r,e.bot,e.top):(r.y<i?r.y=i:r.y=this._currentBotY,s<n?r.x=J.topX(t,r.y):r.x=J.topX(e,r.y))}let n=new H(r,t,e);this._intersectList.push(n)}static extractFromSEL(t){let e=t.nextInSEL;return e&&(e.prevInSEL=t.prevInSEL),t.prevInSEL.nextInSEL=e,e}static insert1Before2InSEL(t,e){t.prevInSEL=e.prevInSEL,t.prevInSEL&&(t.prevInSEL.nextInSEL=t),t.nextInSEL=e,e.prevInSEL=t}buildIntersectList(t){if(!this._actives||!this._actives.nextInAEL)return!1;this.adjustCurrXAndCopyToSEL(t);let e=this._sel,i,s,r,n,o,l;for(;e.jump;){for(o=void 0;e&&e.jump;){for(n=e,s=i=e.jump,r=i.jump,e.jump=r;e!==s&&i!==r;)if(i.curX<e.curX){for(l=i.prevInSEL;this.addNewIntersectNode(l,i,t),l!==e;)l=l.prevInSEL;l=i,s=i=J.extractFromSEL(l),J.insert1Before2InSEL(l,e),e===n&&((n=l).jump=r,void 0===o?this._sel=n:o.jump=n)}else e=e.nextInSEL;o=n,e=r}e=this._sel}return this._intersectList.length>0}processIntersectList(){this._intersectList.sort((t,e)=>t.pt.y===e.pt.y?t.pt.x===e.pt.x?0:t.pt.x<e.pt.x?-1:1:t.pt.y>e.pt.y?-1:1);for(let t=0;t<this._intersectList.length;++t){if(!J.edgesAdjacentInAEL(this._intersectList[t])){let e=t+1;for(;!J.edgesAdjacentInAEL(this._intersectList[e]);)e++;[this._intersectList[e],this._intersectList[t]]=[this._intersectList[t],this._intersectList[e]]}let e=this._intersectList[t];this.intersectEdges(e.edge1,e.edge2,e.pt),this.swapPositionsInAEL(e.edge1,e.edge2),e.edge1.curX=e.pt.x,e.edge2.curX=e.pt.x,this.checkJoinLeft(e.edge2,e.pt,!0),this.checkJoinRight(e.edge1,e.pt,!0)}}swapPositionsInAEL(t,e){let i=e.nextInAEL;i&&(i.prevInAEL=t);let s=t.prevInAEL;s&&(s.nextInAEL=e),e.prevInAEL=s,e.nextInAEL=t,t.prevInAEL=e,t.nextInAEL=i,e.prevInAEL||(this._actives=e)}static resetHorzDirection(t,e){let i,s;if(t.bot.x===t.top.x){i=t.curX,s=t.curX;let r=t.nextInAEL;for(;r&&r.vertexTop!==e;)r=r.nextInAEL;return{isLeftToRight:void 0!==r,leftX:i,rightX:s}}return t.curX<t.top.x?{isLeftToRight:!0,leftX:i=t.curX,rightX:s=t.top.x}:{isLeftToRight:!1,leftX:i=t.top.x,rightX:s=t.curX}}static horzIsSpike(t){let e=J.nextVertex(t).pt;return t.bot.x<t.top.x!=t.top.x<e.x}static trimHorz(t,e){let i=!1,s=J.nextVertex(t).pt;for(;s.y===t.top.y&&(!e||s.x<t.top.x==t.bot.x<t.top.x)&&(t.vertexTop=J.nextVertex(t),t.top=s,i=!0,!J.isMaximaActive(t));)s=J.nextVertex(t).pt;i&&J.setDx(t)}addToHorzSegList(t){t.outrec.isOpen||this._horzSegList.push(new B(t))}getLastOp(t){let e=t.outrec;return t===e.frontEdge?e.pts:e.pts.next}doHorizontal(t){let e;let i=J.isOpen(t),s=t.bot.y,r=i?J.getCurrYMaximaVertex_Open(t):J.getCurrYMaximaVertex(t);r&&!i&&r!==t.vertexTop&&J.trimHorz(t,this.preserveCollinear);let{isLeftToRight:n,leftX:o,rightX:l}=J.resetHorzDirection(t,r);if(J.isHotEdgeActive(t)){let e=J.addOutPt(t,new Y(t.curX,s));this.addToHorzSegList(e)}for(;;){let a=n?t.nextInAEL:t.prevInAEL;for(;a;){if(a.vertexTop===r){if(J.isHotEdgeActive(t)&&J.isJoined(a)&&this.split(a,a.top),J.isHotEdgeActive(t)){for(;t.vertexTop!==r;)J.addOutPt(t,t.top),this.updateEdgeIntoAEL(t);n?this.addLocalMaxPoly(t,a,t.top):this.addLocalMaxPoly(a,t,t.top)}this.deleteFromAEL(a),this.deleteFromAEL(t);return}if(r!==t.vertexTop||J.isOpenEndActive(t)){if(n&&a.curX>l||!n&&a.curX<o)break;if(a.curX===t.top.x&&!J.isHorizontal(a)){if(e=J.nextVertex(t).pt,!J.isOpen(a)||J.isSamePolyType(a,t)||J.isHotEdgeActive(a)){if(n&&J.topX(a,e.y)>=e.x||!n&&J.topX(a,e.y)<=e.x)break}else if(n&&J.topX(a,e.y)>e.x||!n&&J.topX(a,e.y)<e.x)break}}e=new Y(a.curX,s),n?(this.intersectEdges(t,a,e),this.swapPositionsInAEL(t,a),t.curX=a.curX,a=t.nextInAEL):(this.intersectEdges(a,t,e),this.swapPositionsInAEL(a,t),t.curX=a.curX,a=t.prevInAEL),J.isHotEdgeActive(t)&&this.addToHorzSegList(this.getLastOp(t))}if(i&&J.isOpenEndActive(t)){J.isHotEdgeActive(t)&&(J.addOutPt(t,t.top),J.isFront(t)?t.outrec.frontEdge=void 0:t.outrec.backEdge=void 0,t.outrec=void 0),this.deleteFromAEL(t);return}if(J.nextVertex(t).pt.y!==t.top.y)break;J.isHotEdgeActive(t)&&J.addOutPt(t,t.top),this.updateEdgeIntoAEL(t),this.preserveCollinear&&!i&&J.horzIsSpike(t)&&J.trimHorz(t,!0);let h=J.resetHorzDirection(t,r);n=h.isLeftToRight,o=h.leftX,l=h.rightX}if(J.isHotEdgeActive(t)){let e=J.addOutPt(t,t.top);this.addToHorzSegList(e)}this.updateEdgeIntoAEL(t)}doTopOfScanbeam(t){this._sel=void 0;let e=this._actives;for(;e;){if(e.top.y===t){if(e.curX=e.top.x,J.isMaximaActive(e)){e=this.doMaxima(e);continue}J.isHotEdgeActive(e)&&J.addOutPt(e,e.top),this.updateEdgeIntoAEL(e),J.isHorizontal(e)&&this.pushHorz(e)}else e.curX=J.topX(e,t);e=e.nextInAEL}}doMaxima(t){let e=t.prevInAEL,i=t.nextInAEL;if(J.isOpenEndActive(t))return J.isHotEdgeActive(t)&&J.addOutPt(t,t.top),J.isHorizontal(t)||(J.isHotEdgeActive(t)&&(J.isFront(t)?t.outrec.frontEdge=void 0:t.outrec.backEdge=void 0,t.outrec=void 0),this.deleteFromAEL(t)),i;let s=J.getMaximaPair(t);if(!s)return i;for(J.isJoined(t)&&this.split(t,t.top),J.isJoined(s)&&this.split(s,s.top);i!==s;)this.intersectEdges(t,i,t.top),this.swapPositionsInAEL(t,i),i=t.nextInAEL;return J.isOpen(t)?(J.isHotEdgeActive(t)&&this.addLocalMaxPoly(t,s,t.top),this.deleteFromAEL(s),this.deleteFromAEL(t)):(J.isHotEdgeActive(t)&&this.addLocalMaxPoly(t,s,t.top),this.deleteFromAEL(t),this.deleteFromAEL(s)),e?e.nextInAEL:this._actives}static isJoined(t){return t.joinWith!==g.None}split(t,e){t.joinWith===g.Right?(t.joinWith=g.None,t.nextInAEL.joinWith=g.None,this.addLocalMinPoly(t,t.nextInAEL,e,!0)):(t.joinWith=g.None,t.prevInAEL.joinWith=g.None,this.addLocalMinPoly(t.prevInAEL,t,e,!0))}checkJoinLeft(t,e,i=!1){let s=t.prevInAEL;if(!(!s||J.isOpen(t)||J.isOpen(s))&&J.isHotEdgeActive(t)&&J.isHotEdgeActive(s)&&(!(e.y<t.top.y+2)&&!(e.y<s.top.y+2)||!(t.bot.y>e.y)&&!(s.bot.y>e.y))){if(i){if(R.perpendicDistFromLineSqrd(e,s.bot,s.top)>.25)return}else if(t.curX!==s.curX)return;0===$.crossProduct(t.top,e,s.top)&&(t.outrec.idx===s.outrec.idx?this.addLocalMaxPoly(s,t,e):t.outrec.idx<s.outrec.idx?J.joinOutrecPaths(t,s):J.joinOutrecPaths(s,t),s.joinWith=g.Right,t.joinWith=g.Left)}}checkJoinRight(t,e,i=!1){let s=t.nextInAEL;if(!(J.isOpen(t)||!J.isHotEdgeActive(t)||J.isJoined(t)||!s||J.isOpen(s))&&J.isHotEdgeActive(s)&&(!(e.y<t.top.y+2)&&!(e.y<s.top.y+2)||!(t.bot.y>e.y)&&!(s.bot.y>e.y))){if(i){if(R.perpendicDistFromLineSqrd(e,s.bot,s.top)>.25)return}else if(t.curX!==s.curX)return;0===$.crossProduct(t.top,e,s.top)&&(t.outrec.idx===s.outrec.idx?this.addLocalMaxPoly(t,s,e):t.outrec.idx<s.outrec.idx?J.joinOutrecPaths(t,s):J.joinOutrecPaths(s,t),t.joinWith=g.Right,s.joinWith=g.Left)}}static fixOutRecPts(t){let e=t.pts;do e.outrec=t,e=e.next;while(e!==t.pts)}static setHorzSegHeadingForward(t,e,i){return e.pt.x!==i.pt.x&&(e.pt.x<i.pt.x?(t.leftOp=e,t.rightOp=i,t.leftToRight=!0):(t.leftOp=i,t.rightOp=e,t.leftToRight=!1),!0)}static updateHorzSegment(t){let e=t.leftOp,i=this.getRealOutRec(e.outrec),s=void 0!==i.frontEdge,r=e.pt.y,n=e,o=e;if(s){let t=i.pts,e=t.next;for(;n!==e&&n.prev.pt.y===r;)n=n.prev;for(;o!==t&&o.next.pt.y===r;)o=o.next}else{for(;n.prev!==o&&n.prev.pt.y===r;)n=n.prev;for(;o.next!==n&&o.next.pt.y===r;)o=o.next}let l=this.setHorzSegHeadingForward(t,n,o)&&void 0===t.leftOp.horz;return l?t.leftOp.horz=t:t.rightOp=void 0,l}static duplicateOp(t,e){let i=new z(t.pt,t.outrec);return e?(i.next=t.next,i.next.prev=i,i.prev=t,t.next=i):(i.prev=t.prev,i.prev.next=i,i.next=t,t.prev=i),i}convertHorzSegsToJoins(){let t=0;for(let e of this._horzSegList)J.updateHorzSegment(e)&&t++;if(!(t<2)){this._horzSegList.sort((t,e)=>t&&e?t.rightOp?e.rightOp?t.leftOp.pt.x-e.leftOp.pt.x:-1:e.rightOp?1:0:0);for(let e=0;e<t-1;e++){let i=this._horzSegList[e];for(let s=e+1;s<t;s++){let t=this._horzSegList[s];if(t.leftOp.pt.x>=i.rightOp.pt.x||t.leftToRight===i.leftToRight||t.rightOp.pt.x<=i.leftOp.pt.x)continue;let e=i.leftOp.pt.y;if(i.leftToRight){for(;i.leftOp.next.pt.y===e&&i.leftOp.next.pt.x<=t.leftOp.pt.x;)i.leftOp=i.leftOp.next;for(;t.leftOp.prev.pt.y===e&&t.leftOp.prev.pt.x<=i.leftOp.pt.x;)t.leftOp=t.leftOp.prev;let s=new j(J.duplicateOp(i.leftOp,!0),J.duplicateOp(t.leftOp,!1));this._horzJoinList.push(s)}else{for(;i.leftOp.prev.pt.y===e&&i.leftOp.prev.pt.x<=t.leftOp.pt.x;)i.leftOp=i.leftOp.prev;for(;t.leftOp.next.pt.y===e&&t.leftOp.next.pt.x<=i.leftOp.pt.x;)t.leftOp=t.leftOp.next;let s=new j(J.duplicateOp(t.leftOp,!0),J.duplicateOp(i.leftOp,!1));this._horzJoinList.push(s)}}}}}static getCleanPath(t){let e=new W,i=t;for(;i.next!==t&&(i.pt.x===i.next.pt.x&&i.pt.x===i.prev.pt.x||i.pt.y===i.next.pt.y&&i.pt.y===i.prev.pt.y);)i=i.next;e.push(i.pt);let s=i;for(i=i.next;i!==t;)(i.pt.x!==i.next.pt.x||i.pt.x!==s.pt.x)&&(i.pt.y!==i.next.pt.y||i.pt.y!==s.pt.y)&&(e.push(i.pt),s=i),i=i.next;return e}static pointInOpPolygon(t,e){if(e===e.next||e.prev===e.next)return f.IsOutside;let i=e;do{if(e.pt.y!==t.y)break;e=e.next}while(e!==i)if(e.pt.y===t.y)return f.IsOutside;let s=e.pt.y<t.y,r=s,n=0;for(i=e.next;i!==e;){if(s)for(;i!==e&&i.pt.y<t.y;)i=i.next;else for(;i!==e&&i.pt.y>t.y;)i=i.next;if(i===e)break;if(i.pt.y===t.y){if(i.pt.x===t.x||i.pt.y===i.prev.pt.y&&t.x<i.prev.pt.x!=t.x<i.pt.x)return f.IsOn;if((i=i.next)===e)break;continue}if(i.pt.x<=t.x||i.prev.pt.x<=t.x){if(i.prev.pt.x<t.x&&i.pt.x<t.x)n=1-n;else{let e=$.crossProduct(i.prev.pt,i.pt,t);if(0===e)return f.IsOn;e<0===s&&(n=1-n)}}s=!s,i=i.next}if(s!==r){let e=$.crossProduct(i.prev.pt,i.pt,t);if(0===e)return f.IsOn;e<0===s&&(n=1-n)}return 0===n?f.IsOutside:f.IsInside}static path1InsidePath2(t,e){let i;let s=0,r=t;do(i=this.pointInOpPolygon(r.pt,e))===f.IsOutside?++s:i===f.IsInside&&--s,r=r.next;while(r!==t&&2>Math.abs(s))if(Math.abs(s)>1)return s<0;let n=J.getBoundsPath(this.getCleanPath(t)).midPoint(),o=this.getCleanPath(e);return $.pointInPolygon(n,o)!==f.IsOutside}moveSplits(t,e){if(t.splits){for(let i of(e.splits=e.splits||[],t.splits))e.splits.push(i);t.splits=void 0}}processHorzJoins(){for(let t of this._horzJoinList){let e=J.getRealOutRec(t.op1.outrec),i=J.getRealOutRec(t.op2.outrec),s=t.op1.next,r=t.op2.prev;if(t.op1.next=t.op2,t.op2.prev=t.op1,s.prev=r,r.next=s,e===i){if((i=this.newOutRec()).pts=s,J.fixOutRecPts(i),e.pts.outrec===i&&(e.pts=t.op1,e.pts.outrec=e),this._using_polytree){if(J.path1InsidePath2(e.pts,i.pts)){let t=e.pts;e.pts=i.pts,i.pts=t,J.fixOutRecPts(e),J.fixOutRecPts(i),i.owner=e.owner}else J.path1InsidePath2(i.pts,e.pts)?i.owner=e:i.owner=e.owner;e.splits=e.splits||[],e.splits.push(i.idx)}else i.owner=e}else i.pts=void 0,this._using_polytree?(J.setOwner(i,e),this.moveSplits(i,e)):i.owner=e}}static ptsReallyClose(t,e){return 2>Math.abs(t.x-e.x)&&2>Math.abs(t.y-e.y)}static isVerySmallTriangle(t){return t.next.next===t.prev&&(this.ptsReallyClose(t.prev.pt,t.next.pt)||this.ptsReallyClose(t.pt,t.next.pt)||this.ptsReallyClose(t.pt,t.prev.pt))}static isValidClosedPath(t){return void 0!==t&&t.next!==t&&(t.next!==t.prev||!this.isVerySmallTriangle(t))}static disposeOutPt(t){let e=t.next===t?void 0:t.next;return t.prev.next=t.next,t.next.prev=t.prev,e}cleanCollinear(t){if(void 0===(t=J.getRealOutRec(t))||t.isOpen)return;if(!J.isValidClosedPath(t.pts)){t.pts=void 0;return}let e=t.pts,i=e;for(;;){if(0===$.crossProduct(i.prev.pt,i.pt,i.next.pt)&&(i.pt===i.prev.pt||i.pt===i.next.pt||!this.preserveCollinear||0>$.dotProduct(i.prev.pt,i.pt,i.next.pt))){if(i===t.pts&&(t.pts=i.prev),i=J.disposeOutPt(i),!J.isValidClosedPath(i)){t.pts=void 0;return}e=i;continue}if((i=i.next)===e)break}this.fixSelfIntersects(t)}doSplitOp(t,e){let i=e.prev,s=e.next.next;t.pts=i;let r=$.getIntersectPoint(i.pt,e.pt,e.next.pt,s.pt).ip,n=J.area(i),o=Math.abs(n);if(o<2){t.pts=void 0;return}let l=J.areaTriangle(r,e.pt,e.next.pt),a=Math.abs(l);if(r===i.pt||r===s.pt)s.prev=i,i.next=s;else{let e=new z(r,t);e.prev=i,e.next=s,s.prev=e,i.next=e}if(a>1&&(a>o||l>0==n>0)){let s=this.newOutRec();s.owner=t.owner,e.outrec=s,e.next.outrec=s;let n=new z(r,s);n.prev=e.next,n.next=e,s.pts=n,e.prev=n,e.next.next=n,this._using_polytree&&(J.path1InsidePath2(i,n)?(s.splits=s.splits||[],s.splits.push(t.idx)):(t.splits=t.splits||[],t.splits.push(s.idx)))}}fixSelfIntersects(t){let e=t.pts;for(;e.prev!==e.next.next;){if($.segsIntersect(e.prev.pt,e.pt,e.next.pt,e.next.next.pt)){if(this.doSplitOp(t,e),!t.pts)return;e=t.pts;continue}if((e=e.next)===t.pts)break}}static buildPath(t,e,i,s){let r,n;if(void 0===t||t.next===t||!i&&t.next===t.prev)return!1;for(s.length=0,e?(r=t.pt,n=t.prev):(r=(t=t.next).pt,n=t.next),s.push(r);n!==t;)n.pt!==r&&(r=n.pt,s.push(r)),n=e?n.prev:n.next;return!(3===s.length&&this.isVerySmallTriangle(n))}buildPaths(t,e){t.length=0,e.length=0;let i=0;for(;i<this._outrecList.length;){let s=this._outrecList[i++];if(!s.pts)continue;let r=new W;s.isOpen?J.buildPath(s.pts,this.reverseSolution,!0,r)&&e.push(r):(this.cleanCollinear(s),J.buildPath(s.pts,this.reverseSolution,!1,r)&&t.push(r))}return!0}static getBoundsPath(t){if(0===t.length)return new G;let e=R.InvalidRect64;for(let i of t)i.x<e.left&&(e.left=i.x),i.x>e.right&&(e.right=i.x),i.y<e.top&&(e.top=i.y),i.y>e.bottom&&(e.bottom=i.y);return e}checkBounds(t){return void 0!==t.pts&&(!t.bounds.isEmpty()||(this.cleanCollinear(t),!!(void 0!==t.pts&&J.buildPath(t.pts,this.reverseSolution,!1,t.path))&&(t.bounds=J.getBoundsPath(t.path),!0)))}checkSplitOwner(t,e){for(let i of e){let e=J.getRealOutRec(this._outrecList[i]);if(void 0!==e&&e!==t&&e.recursiveSplit!==t){if(e.recursiveSplit=t,void 0!==e.splits&&this.checkSplitOwner(t,e.splits))return!0;if(J.isValidOwner(t,e)&&this.checkBounds(e)&&e.bounds.containsRect(t.bounds)&&J.path1InsidePath2(t.pts,e.pts))return t.owner=e,!0}}return!1}recursiveCheckOwners(t,e){if(!(void 0!==t.polypath||t.bounds.isEmpty())){for(;void 0!==t.owner&&!(void 0!==t.owner.splits&&this.checkSplitOwner(t,t.owner.splits))&&!(void 0!==t.owner.pts&&this.checkBounds(t.owner)&&J.path1InsidePath2(t.pts,t.owner.pts));)t.owner=t.owner.owner;void 0!==t.owner?(void 0===t.owner.polypath&&this.recursiveCheckOwners(t.owner,e),t.polypath=t.owner.polypath.addChild(t.path)):t.polypath=e.addChild(t.path)}}buildTree(t,e){t.clear(),e.length=0;let i=0;for(;i<this._outrecList.length;){let s=this._outrecList[i++];if(void 0!==s.pts){if(s.isOpen){let t=new W;J.buildPath(s.pts,this.reverseSolution,!0,t)&&e.push(t);continue}this.checkBounds(s)&&this.recursiveCheckOwners(s,t)}}}getBounds(){let t=R.InvalidRect64;for(let e of this._vertexList){let i=e;do i.pt.x<t.left&&(t.left=i.pt.x),i.pt.x>t.right&&(t.right=i.pt.x),i.pt.y<t.top&&(t.top=i.pt.y),i.pt.y>t.bottom&&(t.bottom=i.pt.y),i=i.next;while(i!==e)}return t.isEmpty()?new G(0,0,0,0):t}}class U extends J{addPath(t,e,i=!1){super.addPath(t,e,i)}addReusableData(t){super.addReuseableData(t)}addPaths(t,e,i=!1){super.addPaths(t,e,i)}addSubjectPaths(t){this.addPaths(t,P.Subject)}addOpenSubjectPaths(t){this.addPaths(t,P.Subject,!0)}addClipPaths(t){this.addPaths(t,P.Clip)}execute(t,e,i,s=new Z){i.length=0,s.length=0;try{this.executeInternal(t,e),this.buildPaths(i,s)}catch(t){this._succeeded=!1}return this.clearSolutionOnly(),this._succeeded}executePolyTree(t,e,i,s=new Z){i.clear(),s.length=0,this._using_polytree=!0;try{this.executeInternal(t,e),this.buildTree(i,s)}catch(t){this._succeeded=!1}return this.clearSolutionOnly(),this._succeeded}}(l=v||(v={}))[l.None=0]="None",l[l.Intersection=1]="Intersection",l[l.Union=2]="Union",l[l.Difference=3]="Difference",l[l.Xor=4]="Xor",(a=P||(P={}))[a.Subject=0]="Subject",a[a.Clip=1]="Clip",(h=w||(w={}))[h.EvenOdd=0]="EvenOdd",h[h.NonZero=1]="NonZero",h[h.Positive=2]="Positive",h[h.Negative=3]="Negative",(p=L||(L={}))[p.Inside=0]="Inside",p[p.Outside=1]="Outside",p[p.OnEdge=2]="OnEdge";class W extends Array{}class Z extends Array{}class G{constructor(t,e,i,s){"boolean"==typeof t?t?(this.left=0,this.top=0,this.right=0,this.bottom=0):(this.left=Number.MAX_SAFE_INTEGER,this.top=Number.MAX_SAFE_INTEGER,this.right=Number.MIN_SAFE_INTEGER,this.bottom=Number.MIN_SAFE_INTEGER):"number"==typeof t?(this.left=t,this.top=e,this.right=i,this.bottom=s):(this.left=t.left,this.top=t.top,this.right=t.right,this.bottom=t.bottom)}get width(){return this.right-this.left}set width(t){this.right=this.left+t}get height(){return this.bottom-this.top}set height(t){this.bottom=this.top+t}isEmpty(){return this.bottom<=this.top||this.right<=this.left}midPoint(){return new Y((this.left+this.right)/2,(this.top+this.bottom)/2)}contains(t){return t.x>this.left&&t.x<this.right&&t.y>this.top&&t.y<this.bottom}containsRect(t){return t.left>=this.left&&t.right<=this.right&&t.top>=this.top&&t.bottom<=this.bottom}intersects(t){return Math.max(this.left,t.left)<=Math.min(this.right,t.right)&&Math.max(this.top,t.top)<=Math.min(this.bottom,t.bottom)}asPath(){let t=new W;return t.push(new Y(this.left,this.top)),t.push(new Y(this.right,this.top)),t.push(new Y(this.right,this.bottom)),t.push(new Y(this.left,this.bottom)),t}}class Y{constructor(t,e){"number"==typeof t&&"number"==typeof e?(this.x=Math.round(t),this.y=Math.round(e)):void 0!==e?(this.x=Math.round(t.x*e),this.y=Math.round(t.y*e)):(this.x=t.x,this.y=t.y)}static equals(t,e){return t.x===e.x&&t.y===e.y}static notEquals(t,e){return t.x!==e.x||t.y!==e.y}static add(t,e){return new Y(t.x+e.x,t.y+e.y)}static subtract(t,e){return new Y(t.x-e.x,t.y-e.y)}toString(){return`${this.x},${this.y} `}equals(t){return t instanceof Y&&Y.equals(this,t)}}class ${static checkPrecision(t){if(t<-8||t>8)throw Error(this.precision_range_error)}static isAlmostZero(t){return Math.abs(t)<=this.floatingPointTolerance}static crossProduct(t,e,i){return(e.x-t.x)*(i.y-e.y)-(e.y-t.y)*(i.x-e.x)}static dotProduct(t,e,i){return(e.x-t.x)*(i.x-e.x)+(e.y-t.y)*(i.y-e.y)}static checkCastInt64(t){return t>=this.max_coord||t<=this.min_coord?this.Invalid64:Math.round(t)}static getIntersectPt(t,e,i,s){let r=e.y-t.y,n=e.x-t.x,o=s.y-i.y,l=s.x-i.x,a=r*l-o*n;if(0===a)return{ip:new Y(0,0),success:!1};let h=((t.x-i.x)*o-(t.y-i.y)*l)/a;return{ip:h<=0?t:h>=1?e:new Y(t.x+h*n,t.y+h*r),success:!0}}static getIntersectPoint(t,e,i,s){let r=e.y-t.y,n=e.x-t.x,o=s.y-i.y,l=s.x-i.x,a=r*l-o*n;if(0===a)return{ip:new Y(0,0),success:!1};let h=((t.x-i.x)*o-(t.y-i.y)*l)/a;return{ip:h<=0?t:h>=1?i:new Y(t.x+h*n,t.y+h*r),success:!0}}static segsIntersect(t,e,i,s,r=!1){if(!r)return $.crossProduct(t,i,s)*$.crossProduct(e,i,s)<0&&$.crossProduct(i,t,e)*$.crossProduct(s,t,e)<0;{let r=$.crossProduct(t,i,s),n=$.crossProduct(e,i,s);if(r*n>0)return!1;let o=$.crossProduct(i,t,e),l=$.crossProduct(s,t,e);return!(o*l>0)&&(0!==r||0!==n||0!==o||0!==l)}}static getClosestPtOnSegment(t,e,i){if(e.x===i.x&&e.y===i.y)return e;let s=i.x-e.x,r=i.y-e.y,n=((t.x-e.x)*s+(t.y-e.y)*r)/(s*s+r*r);return n<0?n=0:n>1&&(n=1),new Y(e.x+Math.round(n*s),e.y+Math.round(n*r))}static pointInPolygon(t,e){let i=e.length,s=0;if(i<3)return f.IsOutside;for(;s<i&&e[s].y===t.y;)s++;if(s===i)return f.IsOutside;let r=0,n=e[s].y<t.y,o=n,l=0,a=s+1,h=i;for(;;){if(a===h){if(0===h||0===s)break;h=s,a=0}if(n){for(;a<h&&e[a].y<t.y;)a++;if(a===h)continue}else{for(;a<h&&e[a].y>t.y;)a++;if(a===h)continue}let o=e[a],p=a>0?e[a-1]:e[i-1];if(o.y===t.y){if(o.x===t.x||o.y===p.y&&t.x<p.x!=t.x<o.x)return f.IsOn;if(++a===s)break;continue}if(t.x<o.x&&t.x<p.x);else if(t.x>p.x&&t.x>o.x)l=1-l;else{if(0===(r=$.crossProduct(p,o,t)))return f.IsOn;r<0===n&&(l=1-l)}n=!n,a++}if(n!==o){if(a===i?a=0:r=$.crossProduct(e[a-1],e[a],t),0===r)return f.IsOn;r<0===n&&(l=1-l)}return 0===l?f.IsOutside:f.IsInside}}function K(t,e){e.x=t.x,e.y=t.z}function Q(t,e){return 500>=Math.abs(t-e)}function tt(t,e){return Q(t.x,e.x)&&Q(t.y,e.y)&&Q(t.z,e.z)}function te(t,e){function i(t,e,i){return(i.y-t.y)*(e.x-t.x)>(e.y-t.y)*(i.x-t.x)}let s=t.start,r=t.end,n=e.start,o=e.end;return i(s,n,o)!==i(r,n,o)&&i(s,r,n)!==i(s,r,o)}$.MaxInt64=0x7fffffffffffffff,$.MaxCoord=$.MaxInt64/4,$.max_coord=$.MaxCoord,$.min_coord=-$.MaxCoord,$.Invalid64=$.MaxInt64,$.defaultArcTolerance=.25,$.floatingPointTolerance=1e-12,$.defaultMinimumEdgeLength=.1,$.precision_range_error="Error: Precision is out of range.";var b=(_("e06gU"),_("e06gU"),_("e06gU"));function ti(t){let{index:e}=t,i=t.attributes.position;return e?e.count/3:i.count/3}let ts=new b.Triangle,tr=new b.Vector3(0,1,0),tn=new b.Triangle,to=new b.Vector3,tl=new b.Vector3,ta=new b.Vector3;function th(t,e){let i=t.map(t=>t.flatMap(t=>new b.Vector2(t.x/e,t.y/e))),s=i.filter(t=>(0,b.ShapeUtils).isClockWise(t)).map(t=>new b.Shape(t)),r=i.filter(t=>!(0,b.ShapeUtils).isClockWise(t)).map(t=>{let e=new b.Shape(t);return e.holes=s,e}),n=new(0,b.ShapeGeometry)(r).rotateX(Math.PI/2);return n.index.array.reverse(),n}function tp(t,e){let i=[];t.forEach(t=>{for(let s=0,r=t.length;s<r;s++){let r=(s+1)%t.length,n=t[s],o=t[r];i.push(new b.Vector3(n.x/e,0,n.y/e),new b.Vector3(o.x/e,0,o.y/e))}});let s=new b.BufferGeometry;return s.setFromPoints(i),s}class tc{constructor(){this.iterationTime=30,this.intScalar=1e9,this.doubleSided=!1,this.sortTriangles=!1,this.output=0}generateAsync(t,e={}){return new Promise((i,s)=>{let{signal:r}=e,n=this.generate(t,e);!function t(){if(r&&r.aborted){s(Error("SilhouetteGenerator: Process aborted via AbortSignal."));return}let e=n.next();e.done?i(e.value):requestAnimationFrame(t)}()})}*generate(t,e={}){let{iterationTime:i,intScalar:s,doubleSided:r,output:n,sortTriangles:o}=this,{onProgress:l}=e,a=Math.log10(s),h=Math.pow(10,-(a-2)),p=t.index,c=t.attributes.position,u=ti(t),d=null,f=o?function(t){let e=t.index,i=t.attributes.position,s=ti(t);return Array(s).fill().map((t,s)=>{let r=3*s+0,n=3*s+1,o=3*s+2;return e&&(r=e.getX(r),n=e.getX(n),o=e.getX(o)),ts.a.fromBufferAttribute(i,r),ts.b.fromBufferAttribute(i,n),ts.c.fromBufferAttribute(i,o),ts.a.y=0,ts.b.y=0,ts.c.y=0,{area:ts.getArea(),index:s}}).sort((t,e)=>e.area-t.area).map(t=>t.index)}(t):Array(u).fill().map((t,e)=>e),x={getGeometry:()=>0===n?th(d,s):1===n?tp(d,s):[th(d,s),tp(d,s)]},g=performance.now();for(let t=0;t<u;t++){let e=3*f[t],n=e+0,o=e+1,a=e+2;p&&(n=p.getX(n),o=p.getX(o),a=p.getX(a));let{a:y,b:v,c:P}=tn;if(y.fromBufferAttribute(c,n),v.fromBufferAttribute(c,o),P.fromBufferAttribute(c,a),!r&&(tn.getNormal(to),0>to.dot(tr))||(y.y=0,v.y=0,P.y=0,1e-8>tn.getArea()))continue;tl.copy(y).add(v).add(P).multiplyScalar(1/3),ta.subVectors(y,tl).normalize(),y.addScaledVector(ta,h),ta.subVectors(v,tl).normalize(),v.addScaledVector(ta,h),ta.subVectors(P,tl).normalize(),P.addScaledVector(ta,h);let L=new W;if(L.push(R.makePath([y.x*s,y.z*s,v.x*s,v.z*s,P.x*s,P.z*s])),y.multiplyScalar(s),v.multiplyScalar(s),P.multiplyScalar(s),d&&function(t,e){let i=["a","b","c"],s=[new b.Line3,new b.Line3,new b.Line3],r=new b.Line3,n=new b.Line3;n.start.set(0,0,0).addScaledVector(t.a,1/3).addScaledVector(t.b,1/3).addScaledVector(t.c,1/3),K(n.start,n.start),n.end.copy(n.start),n.end.y+=1e10;for(let e=0;e<3;e++){let r=(e+1)%3,n=t[i[e]],o=t[i[r]],l=s[e];K(n,l.start),K(o,l.end)}let o=0;for(let t=0,i=e.length;t<i;t++){let i=e[t];for(let t=0,e=i.length;t<e;t++){let l=(t+1)%e;r.start.copy(i[t]),r.start.z=0,r.end.copy(i[l]),r.end.z=0,te(n,r)&&o++;for(let t=0;t<3;t++){let e=s[t];if(te(e,r)||tt(e.start,r.start)||tt(e.end,r.end)||tt(e.end,r.start)||tt(e.start,r.end))return!1}}}return o%2==1}(tn,d))continue;null===d?d=L:(d=R.Union(d,L,w.NonZero)).forEach(t=>(function(t){for(let i=0;i<t.length;i++){let s=t[i];for(;;){var e;let r=i+1;if(t.length>r&&(e=t[r],s.x===e.x&&s.y===e.y||function(t,e){let i=e.x-t.x,s=e.y-t.y;return 100>Math.sqrt(i*i+s*s)}(s,t[r])))t.splice(r,1);else break}for(;;){let e=i+1,r=i+2;if(t.length>r&&function(t,e,i){let s=e.x-t.x,r=e.y-t.y,n=i.x-e.x,o=i.y-e.y;return .001>Math.abs(s/r-n/o)}(s,t[e],t[r]))t.splice(i+1,1);else break}}})(t));let m=performance.now()-g;if(m>i){if(l){let e=t/u;l(e,x)}yield,g=performance.now()}}return x.getGeometry()}}onmessage=function({data:t}){let e=performance.now();try{let i,s;let{index:r,position:n,options:o}=t,l=new b.BufferGeometry;l.setIndex(new b.BufferAttribute(r,1,!1)),l.setAttribute("position",new b.BufferAttribute(n,3,!1));let a=new tc;a.doubleSided=o.doubleSided??a.doubleSided,a.output=o.output??a.output,a.intScalar=o.intScalar??a.intScalar,a.sortTriangles=o.sortTriangles??a.sortTriangles;let h=a.generate(l,{onProgress:function(t){let i=performance.now();(i-e>=10||1===t)&&(postMessage({error:null,progress:t}),e=i)}}),p=h.next();for(;!p.done;)p=h.next();if(2===a.output)i=[],s=[],p.value.forEach(t=>{console.log(t);let e=t.attributes.position.array,r=t.index?.array||null;s.push({position:e,index:r}),i.push(e.buffer,r?.buffer)});else{let t=p.value.attributes.position.array,e=p.value.index.array;s={position:t,index:e},i=[t.buffer,e.buffer]}postMessage({result:s,error:null,progress:1},i.filter(t=>!!t))}catch(t){postMessage({error:t,progress:1})}}})();
//# sourceMappingURL=silhouetteAsync.worker.f555f2b4.js.map
