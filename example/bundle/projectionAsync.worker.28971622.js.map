{"mappings":"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","sources":["<anon>","src/worker/projectionAsync.worker.js","src/ProjectionGenerator.js","node_modules/three-mesh-bvh/src/core/MeshBVH.js","node_modules/three-mesh-bvh/src/core/Constants.js","node_modules/three-mesh-bvh/src/core/build/buildTree.js","node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","node_modules/three-mesh-bvh/src/core/build/splitUtils.js","node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js","node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js","node_modules/three-mesh-bvh/src/math/OrientedBox.js","node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","node_modules/three-mesh-bvh/src/math/MathUtilities.js","node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","node_modules/three-mesh-bvh/src/core/cast/shapecast.js","node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","node_modules/three-mesh-bvh/src/core/cast/bvhcast.generated.js","node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/bvhcast_indirect.generated.js","node_modules/three-mesh-bvh/src/utils/BufferUtils.js","src/utils/triangleLineUtils.js","src/utils/generateEdges.js","src/utils/overlapUtils.js","src/utils/trimToBeneathTriPlane.js","src/utils/getProjectedLineOverlap.js","src/utils/getProjectedOverlaps.js","src/utils/generateIntersectionEdges.js"],"sourcesContent":["(() => {\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire6c98\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire6c98\"] = parcelRequire;\n}\nimportScripts(\"./projectionAsync.worker.d112c604.js\");\nvar $30a43f3c8b68694e$exports = {};\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\nvar $e06gU = parcelRequire(\"e06gU\");\n// Split strategy constants\nconst $bc798809290ffd6b$export$91c2158bc24c63d4 = 0;\nconst $bc798809290ffd6b$export$d3bfe4097a2a8542 = 1;\nconst $bc798809290ffd6b$export$2b2cc3fb4f03d723 = 2;\nconst $bc798809290ffd6b$export$34b5498ca69d033 = 0;\nconst $bc798809290ffd6b$export$a26e00882057cd76 = 1;\nconst $bc798809290ffd6b$export$82ad94f0a038b67a = 2;\nconst $bc798809290ffd6b$export$22e1995328fd3cd9 = 1.25;\nconst $bc798809290ffd6b$export$f4b101accf1b23d1 = 1;\nconst $bc798809290ffd6b$export$a08e7d18fbc53be5 = 32;\nconst $bc798809290ffd6b$export$661fddb62bfe0e42 = 0xFFFF;\nconst $bc798809290ffd6b$export$859129fb5c8f4dc1 = Math.pow(2, -24);\nconst $bc798809290ffd6b$export$abef70518a11a6ba = Symbol(\"SKIP_GENERATION\");\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\nfunction $512bf92b30757ce0$export$bb010cc24ecaa644(geo) {\n    return geo.index ? geo.index.count : geo.attributes.position.count;\n}\nfunction $512bf92b30757ce0$export$c56c51fae37b2d63(geo) {\n    return $512bf92b30757ce0$export$bb010cc24ecaa644(geo) / 3;\n}\nfunction $512bf92b30757ce0$export$62808f0201824da2(vertexCount, BufferConstructor = ArrayBuffer) {\n    if (vertexCount > 65535) return new Uint32Array(new BufferConstructor(4 * vertexCount));\n    else return new Uint16Array(new BufferConstructor(2 * vertexCount));\n}\nfunction $512bf92b30757ce0$export$90fd303420808ebb(geo, options) {\n    if (!geo.index) {\n        const vertexCount = geo.attributes.position.count;\n        const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n        const index = $512bf92b30757ce0$export$62808f0201824da2(vertexCount, BufferConstructor);\n        geo.setIndex(new (0, $e06gU.BufferAttribute)(index, 1));\n        for(let i = 0; i < vertexCount; i++)index[i] = i;\n    }\n}\nfunction $512bf92b30757ce0$export$8c9d42783264c26e(geo) {\n    const triCount = $512bf92b30757ce0$export$c56c51fae37b2d63(geo);\n    const drawRange = geo.drawRange;\n    const start = drawRange.start / 3;\n    const end = (drawRange.start + drawRange.count) / 3;\n    const offset = Math.max(0, start);\n    const count = Math.min(triCount, end) - offset;\n    return [\n        {\n            offset: Math.floor(offset),\n            count: Math.floor(count)\n        }\n    ];\n}\nfunction $512bf92b30757ce0$export$fd7a16c461f5043c(geo) {\n    if (!geo.groups || !geo.groups.length) return $512bf92b30757ce0$export$8c9d42783264c26e(geo);\n    const ranges = [];\n    const rangeBoundaries = new Set();\n    const drawRange = geo.drawRange;\n    const drawRangeStart = drawRange.start / 3;\n    const drawRangeEnd = (drawRange.start + drawRange.count) / 3;\n    for (const group of geo.groups){\n        const groupStart = group.start / 3;\n        const groupEnd = (group.start + group.count) / 3;\n        rangeBoundaries.add(Math.max(drawRangeStart, groupStart));\n        rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));\n    }\n    // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n    const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b)=>a - b);\n    for(let i = 0; i < sortedBoundaries.length - 1; i++){\n        const start = sortedBoundaries[i];\n        const end = sortedBoundaries[i + 1];\n        ranges.push({\n            offset: Math.floor(start),\n            count: Math.floor(end - start)\n        });\n    }\n    return ranges;\n}\nfunction $512bf92b30757ce0$export$d3cf4eabab21775d(geometry) {\n    if (geometry.groups.length === 0) return false;\n    const vertexCount = $512bf92b30757ce0$export$c56c51fae37b2d63(geometry);\n    const groups = $512bf92b30757ce0$export$fd7a16c461f5043c(geometry).sort((a, b)=>a.offset - b.offset);\n    const finalGroup = groups[groups.length - 1];\n    finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);\n    let total = 0;\n    groups.forEach(({ count: count })=>total += count);\n    return vertexCount !== total;\n}\n\n\n\nfunction $d5323e54f8bf740a$export$40b9a5e446bf11e0(nodeIndex32, array, target) {\n    target.min.x = array[nodeIndex32];\n    target.min.y = array[nodeIndex32 + 1];\n    target.min.z = array[nodeIndex32 + 2];\n    target.max.x = array[nodeIndex32 + 3];\n    target.max.y = array[nodeIndex32 + 4];\n    target.max.z = array[nodeIndex32 + 5];\n    return target;\n}\nfunction $d5323e54f8bf740a$export$8737d658f04762d3(target) {\n    target[0] = target[1] = target[2] = Infinity;\n    target[3] = target[4] = target[5] = -Infinity;\n}\nfunction $d5323e54f8bf740a$export$dcdc414399b99746(bounds) {\n    let splitDimIdx = -1;\n    let splitDist = -Infinity;\n    for(let i = 0; i < 3; i++){\n        const dist = bounds[i + 3] - bounds[i];\n        if (dist > splitDist) {\n            splitDist = dist;\n            splitDimIdx = i;\n        }\n    }\n    return splitDimIdx;\n}\nfunction $d5323e54f8bf740a$export$14b050a767b4a3a7(source, target) {\n    target.set(source);\n}\nfunction $d5323e54f8bf740a$export$a8a7063dce01a911(a, b, target) {\n    let aVal, bVal;\n    for(let d = 0; d < 3; d++){\n        const d3 = d + 3;\n        // set the minimum values\n        aVal = a[d];\n        bVal = b[d];\n        target[d] = aVal < bVal ? aVal : bVal;\n        // set the max values\n        aVal = a[d3];\n        bVal = b[d3];\n        target[d3] = aVal > bVal ? aVal : bVal;\n    }\n}\nfunction $d5323e54f8bf740a$export$c989e53c4b24c2f5(startIndex, triangleBounds, bounds) {\n    for(let d = 0; d < 3; d++){\n        const tCenter = triangleBounds[startIndex + 2 * d];\n        const tHalf = triangleBounds[startIndex + 2 * d + 1];\n        const tMin = tCenter - tHalf;\n        const tMax = tCenter + tHalf;\n        if (tMin < bounds[d]) bounds[d] = tMin;\n        if (tMax > bounds[d + 3]) bounds[d + 3] = tMax;\n    }\n}\nfunction $d5323e54f8bf740a$export$dbf4320364dc239e(bounds) {\n    const d0 = bounds[3] - bounds[0];\n    const d1 = bounds[4] - bounds[1];\n    const d2 = bounds[5] - bounds[2];\n    return 2 * (d0 * d1 + d1 * d2 + d2 * d0);\n}\n\n\n\nfunction $faecb3eca4385fa9$export$becd1e645219fa23(triangleBounds, offset, count, target, centroidTarget = null) {\n    let minx = Infinity;\n    let miny = Infinity;\n    let minz = Infinity;\n    let maxx = -Infinity;\n    let maxy = -Infinity;\n    let maxz = -Infinity;\n    let cminx = Infinity;\n    let cminy = Infinity;\n    let cminz = Infinity;\n    let cmaxx = -Infinity;\n    let cmaxy = -Infinity;\n    let cmaxz = -Infinity;\n    const includeCentroid = centroidTarget !== null;\n    for(let i = offset * 6, end = (offset + count) * 6; i < end; i += 6){\n        const cx = triangleBounds[i + 0];\n        const hx = triangleBounds[i + 1];\n        const lx = cx - hx;\n        const rx = cx + hx;\n        if (lx < minx) minx = lx;\n        if (rx > maxx) maxx = rx;\n        if (includeCentroid && cx < cminx) cminx = cx;\n        if (includeCentroid && cx > cmaxx) cmaxx = cx;\n        const cy = triangleBounds[i + 2];\n        const hy = triangleBounds[i + 3];\n        const ly = cy - hy;\n        const ry = cy + hy;\n        if (ly < miny) miny = ly;\n        if (ry > maxy) maxy = ry;\n        if (includeCentroid && cy < cminy) cminy = cy;\n        if (includeCentroid && cy > cmaxy) cmaxy = cy;\n        const cz = triangleBounds[i + 4];\n        const hz = triangleBounds[i + 5];\n        const lz = cz - hz;\n        const rz = cz + hz;\n        if (lz < minz) minz = lz;\n        if (rz > maxz) maxz = rz;\n        if (includeCentroid && cz < cminz) cminz = cz;\n        if (includeCentroid && cz > cmaxz) cmaxz = cz;\n    }\n    target[0] = minx;\n    target[1] = miny;\n    target[2] = minz;\n    target[3] = maxx;\n    target[4] = maxy;\n    target[5] = maxz;\n    if (includeCentroid) {\n        centroidTarget[0] = cminx;\n        centroidTarget[1] = cminy;\n        centroidTarget[2] = cminz;\n        centroidTarget[3] = cmaxx;\n        centroidTarget[4] = cmaxy;\n        centroidTarget[5] = cmaxz;\n    }\n}\nfunction $faecb3eca4385fa9$export$8eb05c58dc5aa2de(triangleBounds, offset, count, centroidTarget) {\n    let cminx = Infinity;\n    let cminy = Infinity;\n    let cminz = Infinity;\n    let cmaxx = -Infinity;\n    let cmaxy = -Infinity;\n    let cmaxz = -Infinity;\n    for(let i = offset * 6, end = (offset + count) * 6; i < end; i += 6){\n        const cx = triangleBounds[i + 0];\n        if (cx < cminx) cminx = cx;\n        if (cx > cmaxx) cmaxx = cx;\n        const cy = triangleBounds[i + 2];\n        if (cy < cminy) cminy = cy;\n        if (cy > cmaxy) cmaxy = cy;\n        const cz = triangleBounds[i + 4];\n        if (cz < cminz) cminz = cz;\n        if (cz > cmaxz) cmaxz = cz;\n    }\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n}\nfunction $faecb3eca4385fa9$export$b3cc4d5d5179e78c(geo, fullBounds) {\n    // clear the bounds to empty\n    (0, $d5323e54f8bf740a$export$8737d658f04762d3)(fullBounds);\n    const posAttr = geo.attributes.position;\n    const index = geo.index ? geo.index.array : null;\n    const triCount = (0, $512bf92b30757ce0$export$c56c51fae37b2d63)(geo);\n    const triangleBounds = new Float32Array(triCount * 6);\n    const normalized = posAttr.normalized;\n    // used for non-normalized positions\n    const posArr = posAttr.array;\n    // support for an interleaved position buffer\n    const bufferOffset = posAttr.offset || 0;\n    let stride = 3;\n    if (posAttr.isInterleavedBufferAttribute) stride = posAttr.data.stride;\n    // used for normalized positions\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\"\n    ];\n    for(let tri = 0; tri < triCount; tri++){\n        const tri3 = tri * 3;\n        const tri6 = tri * 6;\n        let ai = tri3 + 0;\n        let bi = tri3 + 1;\n        let ci = tri3 + 2;\n        if (index) {\n            ai = index[ai];\n            bi = index[bi];\n            ci = index[ci];\n        }\n        // we add the stride and offset here since we access the array directly\n        // below for the sake of performance\n        if (!normalized) {\n            ai = ai * stride + bufferOffset;\n            bi = bi * stride + bufferOffset;\n            ci = ci * stride + bufferOffset;\n        }\n        for(let el = 0; el < 3; el++){\n            let a, b, c;\n            if (normalized) {\n                a = posAttr[getters[el]](ai);\n                b = posAttr[getters[el]](bi);\n                c = posAttr[getters[el]](ci);\n            } else {\n                a = posArr[ai + el];\n                b = posArr[bi + el];\n                c = posArr[ci + el];\n            }\n            let min = a;\n            if (b < min) min = b;\n            if (c < min) min = c;\n            let max = a;\n            if (b > max) max = b;\n            if (c > max) max = c;\n            // Increase the bounds size by float32 epsilon to avoid precision errors when\n            // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n            // worked with.\n            const halfExtents = (max - min) / 2;\n            const el2 = el * 2;\n            triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n            triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * (0, $bc798809290ffd6b$export$859129fb5c8f4dc1);\n            if (min < fullBounds[el]) fullBounds[el] = min;\n            if (max > fullBounds[el + 3]) fullBounds[el + 3] = max;\n        }\n    }\n    return triangleBounds;\n}\n\n\n\n\nconst $62809835080ba262$var$BIN_COUNT = 32;\nconst $62809835080ba262$var$binsSort = (a, b)=>a.candidate - b.candidate;\nconst $62809835080ba262$var$sahBins = new Array($62809835080ba262$var$BIN_COUNT).fill().map(()=>{\n    return {\n        count: 0,\n        bounds: new Float32Array(6),\n        rightCacheBounds: new Float32Array(6),\n        leftCacheBounds: new Float32Array(6),\n        candidate: 0\n    };\n});\nconst $62809835080ba262$var$leftBounds = new Float32Array(6);\nfunction $62809835080ba262$export$9e40712018083c80(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n    let axis = -1;\n    let pos = 0;\n    // Center\n    if (strategy === (0, $bc798809290ffd6b$export$91c2158bc24c63d4)) {\n        axis = (0, $d5323e54f8bf740a$export$dcdc414399b99746)(centroidBoundingData);\n        if (axis !== -1) pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    } else if (strategy === (0, $bc798809290ffd6b$export$d3bfe4097a2a8542)) {\n        axis = (0, $d5323e54f8bf740a$export$dcdc414399b99746)(nodeBoundingData);\n        if (axis !== -1) pos = $62809835080ba262$var$getAverage(triangleBounds, offset, count, axis);\n    } else if (strategy === (0, $bc798809290ffd6b$export$2b2cc3fb4f03d723)) {\n        const rootSurfaceArea = (0, $d5323e54f8bf740a$export$dbf4320364dc239e)(nodeBoundingData);\n        let bestCost = (0, $bc798809290ffd6b$export$22e1995328fd3cd9) * count;\n        // iterate over all axes\n        const cStart = offset * 6;\n        const cEnd = (offset + count) * 6;\n        for(let a = 0; a < 3; a++){\n            const axisLeft = centroidBoundingData[a];\n            const axisRight = centroidBoundingData[a + 3];\n            const axisLength = axisRight - axisLeft;\n            const binWidth = axisLength / $62809835080ba262$var$BIN_COUNT;\n            // If we have fewer triangles than we're planning to split then just check all\n            // the triangle positions because it will be faster.\n            if (count < $62809835080ba262$var$BIN_COUNT / 4) {\n                // initialize the bin candidates\n                const truncatedBins = [\n                    ...$62809835080ba262$var$sahBins\n                ];\n                truncatedBins.length = count;\n                // set the candidates\n                let b = 0;\n                for(let c = cStart; c < cEnd; c += 6, b++){\n                    const bin = truncatedBins[b];\n                    bin.candidate = triangleBounds[c + 2 * a];\n                    bin.count = 0;\n                    const { bounds: bounds, leftCacheBounds: leftCacheBounds, rightCacheBounds: rightCacheBounds } = bin;\n                    for(let d = 0; d < 3; d++){\n                        rightCacheBounds[d] = Infinity;\n                        rightCacheBounds[d + 3] = -Infinity;\n                        leftCacheBounds[d] = Infinity;\n                        leftCacheBounds[d + 3] = -Infinity;\n                        bounds[d] = Infinity;\n                        bounds[d + 3] = -Infinity;\n                    }\n                    (0, $d5323e54f8bf740a$export$c989e53c4b24c2f5)(c, triangleBounds, bounds);\n                }\n                truncatedBins.sort($62809835080ba262$var$binsSort);\n                // remove redundant splits\n                let splitCount = count;\n                for(let bi = 0; bi < splitCount; bi++){\n                    const bin = truncatedBins[bi];\n                    while(bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate){\n                        truncatedBins.splice(bi + 1, 1);\n                        splitCount--;\n                    }\n                }\n                // find the appropriate bin for each triangle and expand the bounds.\n                for(let c = cStart; c < cEnd; c += 6){\n                    const center = triangleBounds[c + 2 * a];\n                    for(let bi = 0; bi < splitCount; bi++){\n                        const bin = truncatedBins[bi];\n                        if (center >= bin.candidate) (0, $d5323e54f8bf740a$export$c989e53c4b24c2f5)(c, triangleBounds, bin.rightCacheBounds);\n                        else {\n                            (0, $d5323e54f8bf740a$export$c989e53c4b24c2f5)(c, triangleBounds, bin.leftCacheBounds);\n                            bin.count++;\n                        }\n                    }\n                }\n                // expand all the bounds\n                for(let bi = 0; bi < splitCount; bi++){\n                    const bin = truncatedBins[bi];\n                    const leftCount = bin.count;\n                    const rightCount = count - bin.count;\n                    // check the cost of this split\n                    const leftBounds = bin.leftCacheBounds;\n                    const rightBounds = bin.rightCacheBounds;\n                    let leftProb = 0;\n                    if (leftCount !== 0) leftProb = (0, $d5323e54f8bf740a$export$dbf4320364dc239e)(leftBounds) / rootSurfaceArea;\n                    let rightProb = 0;\n                    if (rightCount !== 0) rightProb = (0, $d5323e54f8bf740a$export$dbf4320364dc239e)(rightBounds) / rootSurfaceArea;\n                    const cost = (0, $bc798809290ffd6b$export$f4b101accf1b23d1) + (0, $bc798809290ffd6b$export$22e1995328fd3cd9) * (leftProb * leftCount + rightProb * rightCount);\n                    if (cost < bestCost) {\n                        axis = a;\n                        bestCost = cost;\n                        pos = bin.candidate;\n                    }\n                }\n            } else {\n                // reset the bins\n                for(let i = 0; i < $62809835080ba262$var$BIN_COUNT; i++){\n                    const bin = $62809835080ba262$var$sahBins[i];\n                    bin.count = 0;\n                    bin.candidate = axisLeft + binWidth + i * binWidth;\n                    const bounds = bin.bounds;\n                    for(let d = 0; d < 3; d++){\n                        bounds[d] = Infinity;\n                        bounds[d + 3] = -Infinity;\n                    }\n                }\n                // iterate over all center positions\n                for(let c = cStart; c < cEnd; c += 6){\n                    const triCenter = triangleBounds[c + 2 * a];\n                    const relativeCenter = triCenter - axisLeft;\n                    // in the partition function if the centroid lies on the split plane then it is\n                    // considered to be on the right side of the split\n                    let binIndex = ~~(relativeCenter / binWidth);\n                    if (binIndex >= $62809835080ba262$var$BIN_COUNT) binIndex = $62809835080ba262$var$BIN_COUNT - 1;\n                    const bin = $62809835080ba262$var$sahBins[binIndex];\n                    bin.count++;\n                    (0, $d5323e54f8bf740a$export$c989e53c4b24c2f5)(c, triangleBounds, bin.bounds);\n                }\n                // cache the unioned bounds from right to left so we don't have to regenerate them each time\n                const lastBin = $62809835080ba262$var$sahBins[$62809835080ba262$var$BIN_COUNT - 1];\n                (0, $d5323e54f8bf740a$export$14b050a767b4a3a7)(lastBin.bounds, lastBin.rightCacheBounds);\n                for(let i = $62809835080ba262$var$BIN_COUNT - 2; i >= 0; i--){\n                    const bin = $62809835080ba262$var$sahBins[i];\n                    const nextBin = $62809835080ba262$var$sahBins[i + 1];\n                    (0, $d5323e54f8bf740a$export$a8a7063dce01a911)(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);\n                }\n                let leftCount = 0;\n                for(let i = 0; i < $62809835080ba262$var$BIN_COUNT - 1; i++){\n                    const bin = $62809835080ba262$var$sahBins[i];\n                    const binCount = bin.count;\n                    const bounds = bin.bounds;\n                    const nextBin = $62809835080ba262$var$sahBins[i + 1];\n                    const rightBounds = nextBin.rightCacheBounds;\n                    // don't do anything with the bounds if the new bounds have no triangles\n                    if (binCount !== 0) {\n                        if (leftCount === 0) (0, $d5323e54f8bf740a$export$14b050a767b4a3a7)(bounds, $62809835080ba262$var$leftBounds);\n                        else (0, $d5323e54f8bf740a$export$a8a7063dce01a911)(bounds, $62809835080ba262$var$leftBounds, $62809835080ba262$var$leftBounds);\n                    }\n                    leftCount += binCount;\n                    // check the cost of this split\n                    let leftProb = 0;\n                    let rightProb = 0;\n                    if (leftCount !== 0) leftProb = (0, $d5323e54f8bf740a$export$dbf4320364dc239e)($62809835080ba262$var$leftBounds) / rootSurfaceArea;\n                    const rightCount = count - leftCount;\n                    if (rightCount !== 0) rightProb = (0, $d5323e54f8bf740a$export$dbf4320364dc239e)(rightBounds) / rootSurfaceArea;\n                    const cost = (0, $bc798809290ffd6b$export$f4b101accf1b23d1) + (0, $bc798809290ffd6b$export$22e1995328fd3cd9) * (leftProb * leftCount + rightProb * rightCount);\n                    if (cost < bestCost) {\n                        axis = a;\n                        bestCost = cost;\n                        pos = bin.candidate;\n                    }\n                }\n            }\n        }\n    } else console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);\n    return {\n        axis: axis,\n        pos: pos\n    };\n}\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction $62809835080ba262$var$getAverage(triangleBounds, offset, count, axis) {\n    let avg = 0;\n    for(let i = offset, end = offset + count; i < end; i++)avg += triangleBounds[i * 6 + axis * 2];\n    return avg / count;\n}\n\n\nclass $5f1fa9198ab38bd9$export$6f473cc5f89b0a1c {\n    constructor(){\n    // internal nodes have boundingData, left, right, and splitAxis\n    // leaf nodes have offset and count (referring to primitives in the mesh geometry)\n    }\n}\n\n\n\n/********************************************************/ /* This file is generated from \"sortUtils.template.js\". */ /********************************************************/ // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction $dc07fa3855e86015$export$b29f828819edca8d(indirectBuffer, index, triangleBounds, offset, count, split) {\n    let left = offset;\n    let right = offset + count - 1;\n    const pos = split.pos;\n    const axisOffset = split.axis * 2;\n    // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    while(true){\n        while(left <= right && triangleBounds[left * 6 + axisOffset] < pos)left++;\n        // if a triangle center lies on the partition plane it is considered to be on the right side\n        while(left <= right && triangleBounds[right * 6 + axisOffset] >= pos)right--;\n        if (left < right) {\n            // we need to swap all of the information associated with the triangles at index\n            // left and right; that's the verts in the geometry index, the bounds,\n            // and perhaps the SAH planes\n            for(let i = 0; i < 3; i++){\n                let t0 = index[left * 3 + i];\n                index[left * 3 + i] = index[right * 3 + i];\n                index[right * 3 + i] = t0;\n            }\n            // swap bounds\n            for(let i = 0; i < 6; i++){\n                let tb = triangleBounds[left * 6 + i];\n                triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n                triangleBounds[right * 6 + i] = tb;\n            }\n            left++;\n            right--;\n        } else return left;\n    }\n}\n\n\n/********************************************************/ /* This file is generated from \"sortUtils.template.js\". */ /********************************************************/ // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction $aace0473d446b8ef$export$7cee363d477551d0(indirectBuffer, index, triangleBounds, offset, count, split) {\n    let left = offset;\n    let right = offset + count - 1;\n    const pos = split.pos;\n    const axisOffset = split.axis * 2;\n    // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    while(true){\n        while(left <= right && triangleBounds[left * 6 + axisOffset] < pos)left++;\n        // if a triangle center lies on the partition plane it is considered to be on the right side\n        while(left <= right && triangleBounds[right * 6 + axisOffset] >= pos)right--;\n        if (left < right) {\n            // we need to swap all of the information associated with the triangles at index\n            // left and right; that's the verts in the geometry index, the bounds,\n            // and perhaps the SAH planes\n            let t = indirectBuffer[left];\n            indirectBuffer[left] = indirectBuffer[right];\n            indirectBuffer[right] = t;\n            // swap bounds\n            for(let i = 0; i < 6; i++){\n                let tb = triangleBounds[left * 6 + i];\n                triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n                triangleBounds[right * 6 + i] = tb;\n            }\n            left++;\n            right--;\n        } else return left;\n    }\n}\n\n\nfunction $1b5942106133d63e$var$generateIndirectBuffer(geometry, useSharedArrayBuffer) {\n    const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    const useUint32 = triCount > 2 ** 16;\n    const byteCount = useUint32 ? 4 : 2;\n    const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n    const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n    for(let i = 0, l = indirectBuffer.length; i < l; i++)indirectBuffer[i] = i;\n    return indirectBuffer;\n}\nfunction $1b5942106133d63e$var$buildTree(bvh, options) {\n    // Compute the full bounds of the geometry at the same time as triangle bounds because\n    // we'll need it for the root bounds in the case with no groups and it should be fast here.\n    // We can't use the geometry bounding box if it's available because it may be out of date.\n    const geometry = bvh.geometry;\n    const indexArray = geometry.index ? geometry.index.array : null;\n    const maxDepth = options.maxDepth;\n    const verbose = options.verbose;\n    const maxLeafTris = options.maxLeafTris;\n    const strategy = options.strategy;\n    const onProgress = options.onProgress;\n    const totalTriangles = (0, $512bf92b30757ce0$export$c56c51fae37b2d63)(geometry);\n    const indirectBuffer = bvh._indirectBuffer;\n    let reachedMaxDepth = false;\n    const fullBounds = new Float32Array(6);\n    const cacheCentroidBoundingData = new Float32Array(6);\n    const triangleBounds = (0, $faecb3eca4385fa9$export$b3cc4d5d5179e78c)(geometry, fullBounds);\n    const partionFunc = options.indirect ? (0, $aace0473d446b8ef$export$7cee363d477551d0) : (0, $dc07fa3855e86015$export$b29f828819edca8d);\n    const roots = [];\n    const ranges = options.indirect ? (0, $512bf92b30757ce0$export$8c9d42783264c26e)(geometry) : (0, $512bf92b30757ce0$export$fd7a16c461f5043c)(geometry);\n    if (ranges.length === 1) {\n        const range = ranges[0];\n        const root = new (0, $5f1fa9198ab38bd9$export$6f473cc5f89b0a1c)();\n        root.boundingData = fullBounds;\n        (0, $faecb3eca4385fa9$export$8eb05c58dc5aa2de)(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n        splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n        roots.push(root);\n    } else for (let range of ranges){\n        const root = new (0, $5f1fa9198ab38bd9$export$6f473cc5f89b0a1c)();\n        root.boundingData = new Float32Array(6);\n        (0, $faecb3eca4385fa9$export$becd1e645219fa23)(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\n        splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n        roots.push(root);\n    }\n    return roots;\n    function triggerProgress(trianglesProcessed) {\n        if (onProgress) onProgress(trianglesProcessed / totalTriangles);\n    }\n    // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n    // recording the offset and count of its triangles and writing them into the reordered geometry index.\n    function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {\n        if (!reachedMaxDepth && depth >= maxDepth) {\n            reachedMaxDepth = true;\n            if (verbose) {\n                console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);\n                console.warn(geometry);\n            }\n        }\n        // early out if we've met our capacity\n        if (count <= maxLeafTris || depth >= maxDepth) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n            return node;\n        }\n        // Find where to split the volume\n        const split = (0, $62809835080ba262$export$9e40712018083c80)(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n        if (split.axis === -1) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n            return node;\n        }\n        const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n        // create the two new child nodes\n        if (splitOffset === offset || splitOffset === offset + count) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n        } else {\n            node.splitAxis = split.axis;\n            // create the left child and compute its bounding box\n            const left = new (0, $5f1fa9198ab38bd9$export$6f473cc5f89b0a1c)();\n            const lstart = offset;\n            const lcount = splitOffset - offset;\n            node.left = left;\n            left.boundingData = new Float32Array(6);\n            (0, $faecb3eca4385fa9$export$becd1e645219fa23)(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n            splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n            // repeat for right\n            const right = new (0, $5f1fa9198ab38bd9$export$6f473cc5f89b0a1c)();\n            const rstart = splitOffset;\n            const rcount = count - lcount;\n            node.right = right;\n            right.boundingData = new Float32Array(6);\n            (0, $faecb3eca4385fa9$export$becd1e645219fa23)(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n            splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n        }\n        return node;\n    }\n}\nfunction $1b5942106133d63e$export$e63bca57f220b8e3(bvh, options) {\n    const geometry = bvh.geometry;\n    if (options.indirect) {\n        bvh._indirectBuffer = $1b5942106133d63e$var$generateIndirectBuffer(geometry, options.useSharedArrayBuffer);\n        if ((0, $512bf92b30757ce0$export$d3cf4eabab21775d)(geometry) && !options.verbose) console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. BVH may incorrectly report intersections on unrendered portions of the geometry.');\n    }\n    if (!bvh._indirectBuffer) (0, $512bf92b30757ce0$export$90fd303420808ebb)(geometry, options);\n    // boundingData  \t\t\t\t: 6 float32\n    // right / offset \t\t\t\t: 1 uint32\n    // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n    const roots = $1b5942106133d63e$var$buildTree(bvh, options);\n    let float32Array;\n    let uint32Array;\n    let uint16Array;\n    const packedRoots = [];\n    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    for(let i = 0; i < roots.length; i++){\n        const root = roots[i];\n        let nodeCount = countNodes(root);\n        const buffer = new BufferConstructor((0, $bc798809290ffd6b$export$a08e7d18fbc53be5) * nodeCount);\n        float32Array = new Float32Array(buffer);\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        populateBuffer(0, root);\n        packedRoots.push(buffer);\n    }\n    bvh._roots = packedRoots;\n    return;\n    function countNodes(node) {\n        if (node.count) return 1;\n        else return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n    function populateBuffer(byteOffset, node) {\n        const stride4Offset = byteOffset / 4;\n        const stride2Offset = byteOffset / 2;\n        const isLeaf = !!node.count;\n        const boundingData = node.boundingData;\n        for(let i = 0; i < 6; i++)float32Array[stride4Offset + i] = boundingData[i];\n        if (isLeaf) {\n            const offset = node.offset;\n            const count = node.count;\n            uint32Array[stride4Offset + 6] = offset;\n            uint16Array[stride2Offset + 14] = count;\n            uint16Array[stride2Offset + 15] = (0, $bc798809290ffd6b$export$661fddb62bfe0e42);\n            return byteOffset + (0, $bc798809290ffd6b$export$a08e7d18fbc53be5);\n        } else {\n            const left = node.left;\n            const right = node.right;\n            const splitAxis = node.splitAxis;\n            let nextUnusedPointer;\n            nextUnusedPointer = populateBuffer(byteOffset + (0, $bc798809290ffd6b$export$a08e7d18fbc53be5), left);\n            if (nextUnusedPointer / 4 > Math.pow(2, 32)) throw new Error(\"MeshBVH: Cannot store child pointer greater than 32 bits.\");\n            uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n            nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n            uint32Array[stride4Offset + 7] = splitAxis;\n            return nextUnusedPointer;\n        }\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\nvar $e06gU = parcelRequire(\"e06gU\");\nclass $34f95eced4ec08e7$export$f758e41ecdcd8e69 {\n    constructor(){\n        this.min = Infinity;\n        this.max = -Infinity;\n    }\n    setFromPointsField(points, field) {\n        let min = Infinity;\n        let max = -Infinity;\n        for(let i = 0, l = points.length; i < l; i++){\n            const p = points[i];\n            const val = p[field];\n            min = val < min ? val : min;\n            max = val > max ? val : max;\n        }\n        this.min = min;\n        this.max = max;\n    }\n    setFromPoints(axis, points) {\n        let min = Infinity;\n        let max = -Infinity;\n        for(let i = 0, l = points.length; i < l; i++){\n            const p = points[i];\n            const val = axis.dot(p);\n            min = val < min ? val : min;\n            max = val > max ? val : max;\n        }\n        this.min = min;\n        this.max = max;\n    }\n    isSeparated(other) {\n        return this.min > other.max || other.min > this.max;\n    }\n}\n$34f95eced4ec08e7$export$f758e41ecdcd8e69.prototype.setFromBox = function() {\n    const p = new (0, $e06gU.Vector3)();\n    return function setFromBox(axis, box) {\n        const boxMin = box.min;\n        const boxMax = box.max;\n        let min = Infinity;\n        let max = -Infinity;\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++)for(let z = 0; z <= 1; z++){\n                p.x = boxMin.x * x + boxMax.x * (1 - x);\n                p.y = boxMin.y * y + boxMax.y * (1 - y);\n                p.z = boxMin.z * z + boxMax.z * (1 - z);\n                const val = axis.dot(p);\n                min = Math.min(val, min);\n                max = Math.max(val, max);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    };\n}();\nconst $34f95eced4ec08e7$export$e086b7be1b4d1d36 = function() {\n    const cacheSatBounds = new $34f95eced4ec08e7$export$f758e41ecdcd8e69();\n    return function areIntersecting(shape1, shape2) {\n        const points1 = shape1.points;\n        const satAxes1 = shape1.satAxes;\n        const satBounds1 = shape1.satBounds;\n        const points2 = shape2.points;\n        const satAxes2 = shape2.satAxes;\n        const satBounds2 = shape2.satBounds;\n        // check axes of the first shape\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds1[i];\n            const sa = satAxes1[i];\n            cacheSatBounds.setFromPoints(sa, points2);\n            if (sb.isSeparated(cacheSatBounds)) return false;\n        }\n        // check axes of the second shape\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds2[i];\n            const sa = satAxes2[i];\n            cacheSatBounds.setFromPoints(sa, points1);\n            if (sb.isSeparated(cacheSatBounds)) return false;\n        }\n    };\n}();\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\nconst $1300ab831e41e936$export$479eef7c8f1b846c = function() {\n    // https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n    const dir1 = new (0, $e06gU.Vector3)();\n    const dir2 = new (0, $e06gU.Vector3)();\n    const v02 = new (0, $e06gU.Vector3)();\n    return function closestPointLineToLine(l1, l2, result) {\n        const v0 = l1.start;\n        const v10 = dir1;\n        const v2 = l2.start;\n        const v32 = dir2;\n        v02.subVectors(v0, v2);\n        dir1.subVectors(l1.end, l1.start);\n        dir2.subVectors(l2.end, l2.start);\n        // float d0232 = v02.Dot(v32);\n        const d0232 = v02.dot(v32);\n        // float d3210 = v32.Dot(v10);\n        const d3210 = v32.dot(v10);\n        // float d3232 = v32.Dot(v32);\n        const d3232 = v32.dot(v32);\n        // float d0210 = v02.Dot(v10);\n        const d0210 = v02.dot(v10);\n        // float d1010 = v10.Dot(v10);\n        const d1010 = v10.dot(v10);\n        // float denom = d1010*d3232 - d3210*d3210;\n        const denom = d1010 * d3232 - d3210 * d3210;\n        let d, d2;\n        if (denom !== 0) d = (d0232 * d3210 - d0210 * d3232) / denom;\n        else d = 0;\n        d2 = (d0232 + d * d3210) / d3232;\n        result.x = d;\n        result.y = d2;\n    };\n}();\nconst $1300ab831e41e936$export$b09f296caca7547a = function() {\n    // https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n    const paramResult = new (0, $e06gU.Vector2)();\n    const temp1 = new (0, $e06gU.Vector3)();\n    const temp2 = new (0, $e06gU.Vector3)();\n    return function closestPointsSegmentToSegment(l1, l2, target1, target2) {\n        $1300ab831e41e936$export$479eef7c8f1b846c(l1, l2, paramResult);\n        let d = paramResult.x;\n        let d2 = paramResult.y;\n        if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {\n            l1.at(d, target1);\n            l2.at(d2, target2);\n            return;\n        } else if (d >= 0 && d <= 1) {\n            // Only d2 is out of bounds.\n            if (d2 < 0) l2.at(0, target2);\n            else l2.at(1, target2);\n            l1.closestPointToPoint(target2, true, target1);\n            return;\n        } else if (d2 >= 0 && d2 <= 1) {\n            // Only d is out of bounds.\n            if (d < 0) l1.at(0, target1);\n            else l1.at(1, target1);\n            l2.closestPointToPoint(target1, true, target2);\n            return;\n        } else {\n            // Both u and u2 are out of bounds.\n            let p;\n            if (d < 0) p = l1.start;\n            else p = l1.end;\n            let p2;\n            if (d2 < 0) p2 = l2.start;\n            else p2 = l2.end;\n            const closestPoint = temp1;\n            const closestPoint2 = temp2;\n            l1.closestPointToPoint(p2, true, temp1);\n            l2.closestPointToPoint(p, true, temp2);\n            if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {\n                target1.copy(closestPoint);\n                target2.copy(p2);\n                return;\n            } else {\n                target1.copy(p);\n                target2.copy(closestPoint2);\n                return;\n            }\n        }\n    };\n}();\nconst $1300ab831e41e936$export$eed3a6606b3adc41 = function() {\n    // https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n    const closestPointTemp = new (0, $e06gU.Vector3)();\n    const projectedPointTemp = new (0, $e06gU.Vector3)();\n    const planeTemp = new (0, $e06gU.Plane)();\n    const lineTemp = new (0, $e06gU.Line3)();\n    return function sphereIntersectTriangle(sphere, triangle) {\n        const { radius: radius, center: center } = sphere;\n        const { a: a, b: b, c: c } = triangle;\n        // phase 1\n        lineTemp.start = a;\n        lineTemp.end = b;\n        const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint1.distanceTo(center) <= radius) return true;\n        lineTemp.start = a;\n        lineTemp.end = c;\n        const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint2.distanceTo(center) <= radius) return true;\n        lineTemp.start = b;\n        lineTemp.end = c;\n        const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint3.distanceTo(center) <= radius) return true;\n        // phase 2\n        const plane = triangle.getPlane(planeTemp);\n        const dp = Math.abs(plane.distanceToPoint(center));\n        if (dp <= radius) {\n            const pp = plane.projectPoint(center, projectedPointTemp);\n            const cp = triangle.containsPoint(pp);\n            if (cp) return true;\n        }\n        return false;\n    };\n}();\n\n\nconst $277ed51eec8cb2f4$var$ZERO_EPSILON = 1e-15;\nfunction $277ed51eec8cb2f4$var$isNearZero(value) {\n    return Math.abs(value) < $277ed51eec8cb2f4$var$ZERO_EPSILON;\n}\nclass $277ed51eec8cb2f4$export$a37f7ec1c23dfacf extends (0, $e06gU.Triangle) {\n    constructor(...args){\n        super(...args);\n        this.isExtendedTriangle = true;\n        this.satAxes = new Array(4).fill().map(()=>new (0, $e06gU.Vector3)());\n        this.satBounds = new Array(4).fill().map(()=>new (0, $34f95eced4ec08e7$export$f758e41ecdcd8e69)());\n        this.points = [\n            this.a,\n            this.b,\n            this.c\n        ];\n        this.sphere = new (0, $e06gU.Sphere)();\n        this.plane = new (0, $e06gU.Plane)();\n        this.needsUpdate = true;\n    }\n    intersectsSphere(sphere) {\n        return (0, $1300ab831e41e936$export$eed3a6606b3adc41)(sphere, this);\n    }\n    update() {\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const points = this.points;\n        const satAxes = this.satAxes;\n        const satBounds = this.satBounds;\n        const axis0 = satAxes[0];\n        const sab0 = satBounds[0];\n        this.getNormal(axis0);\n        sab0.setFromPoints(axis0, points);\n        const axis1 = satAxes[1];\n        const sab1 = satBounds[1];\n        axis1.subVectors(a, b);\n        sab1.setFromPoints(axis1, points);\n        const axis2 = satAxes[2];\n        const sab2 = satBounds[2];\n        axis2.subVectors(b, c);\n        sab2.setFromPoints(axis2, points);\n        const axis3 = satAxes[3];\n        const sab3 = satBounds[3];\n        axis3.subVectors(c, a);\n        sab3.setFromPoints(axis3, points);\n        this.sphere.setFromPoints(this.points);\n        this.plane.setFromNormalAndCoplanarPoint(axis0, a);\n        this.needsUpdate = false;\n    }\n}\n$277ed51eec8cb2f4$export$a37f7ec1c23dfacf.prototype.closestPointToSegment = function() {\n    const point1 = new (0, $e06gU.Vector3)();\n    const point2 = new (0, $e06gU.Vector3)();\n    const edge = new (0, $e06gU.Line3)();\n    return function distanceToSegment(segment, target1 = null, target2 = null) {\n        const { start: start, end: end } = segment;\n        const points = this.points;\n        let distSq;\n        let closestDistanceSq = Infinity;\n        // check the triangle edges\n        for(let i = 0; i < 3; i++){\n            const nexti = (i + 1) % 3;\n            edge.start.copy(points[i]);\n            edge.end.copy(points[nexti]);\n            (0, $1300ab831e41e936$export$b09f296caca7547a)(edge, segment, point1, point2);\n            distSq = point1.distanceToSquared(point2);\n            if (distSq < closestDistanceSq) {\n                closestDistanceSq = distSq;\n                if (target1) target1.copy(point1);\n                if (target2) target2.copy(point2);\n            }\n        }\n        // check end points\n        this.closestPointToPoint(start, point1);\n        distSq = start.distanceToSquared(point1);\n        if (distSq < closestDistanceSq) {\n            closestDistanceSq = distSq;\n            if (target1) target1.copy(point1);\n            if (target2) target2.copy(start);\n        }\n        this.closestPointToPoint(end, point1);\n        distSq = end.distanceToSquared(point1);\n        if (distSq < closestDistanceSq) {\n            closestDistanceSq = distSq;\n            if (target1) target1.copy(point1);\n            if (target2) target2.copy(end);\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n$277ed51eec8cb2f4$export$a37f7ec1c23dfacf.prototype.intersectsTriangle = function() {\n    const saTri2 = new $277ed51eec8cb2f4$export$a37f7ec1c23dfacf();\n    const arr1 = new Array(3);\n    const arr2 = new Array(3);\n    const cachedSatBounds = new (0, $34f95eced4ec08e7$export$f758e41ecdcd8e69)();\n    const cachedSatBounds2 = new (0, $34f95eced4ec08e7$export$f758e41ecdcd8e69)();\n    const cachedAxis = new (0, $e06gU.Vector3)();\n    const dir = new (0, $e06gU.Vector3)();\n    const dir1 = new (0, $e06gU.Vector3)();\n    const dir2 = new (0, $e06gU.Vector3)();\n    const tempDir = new (0, $e06gU.Vector3)();\n    const edge = new (0, $e06gU.Line3)();\n    const edge1 = new (0, $e06gU.Line3)();\n    const edge2 = new (0, $e06gU.Line3)();\n    const tempPoint = new (0, $e06gU.Vector3)();\n    function triIntersectPlane(tri, plane, targetEdge) {\n        // find the edge that intersects the other triangle plane\n        const points = tri.points;\n        let count = 0;\n        let startPointIntersection = -1;\n        for(let i = 0; i < 3; i++){\n            const { start: start, end: end } = edge;\n            start.copy(points[i]);\n            end.copy(points[(i + 1) % 3]);\n            edge.delta(dir);\n            const startIntersects = $277ed51eec8cb2f4$var$isNearZero(plane.distanceToPoint(start));\n            if ($277ed51eec8cb2f4$var$isNearZero(plane.normal.dot(dir)) && startIntersects) {\n                // if the edge lies on the plane then take the line\n                targetEdge.copy(edge);\n                count = 2;\n                break;\n            }\n            // check if the start point is near the plane because \"intersectLine\" is not robust to that case\n            const doesIntersect = plane.intersectLine(edge, tempPoint);\n            if (!doesIntersect && startIntersects) tempPoint.copy(start);\n            // ignore the end point\n            if ((doesIntersect || startIntersects) && !$277ed51eec8cb2f4$var$isNearZero(tempPoint.distanceTo(end))) {\n                if (count <= 1) {\n                    // assign to the start or end point and save which index was snapped to\n                    // the start point if necessary\n                    const point = count === 1 ? targetEdge.start : targetEdge.end;\n                    point.copy(tempPoint);\n                    if (startIntersects) startPointIntersection = count;\n                } else if (count >= 2) {\n                    // if we're here that means that there must have been one point that had\n                    // snapped to the start point so replace it here\n                    const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n                    point.copy(tempPoint);\n                    count = 2;\n                    break;\n                }\n                count++;\n                if (count === 2 && startPointIntersection === -1) break;\n            }\n        }\n        return count;\n    }\n    // TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n    // be a line contained by both triangles if not a different special case somehow represented in the return result.\n    return function intersectsTriangle(other, target = null, suppressLog = false) {\n        if (this.needsUpdate) this.update();\n        if (!other.isExtendedTriangle) {\n            saTri2.copy(other);\n            saTri2.update();\n            other = saTri2;\n        } else if (other.needsUpdate) other.update();\n        const plane1 = this.plane;\n        const plane2 = other.plane;\n        if (Math.abs(plane1.normal.dot(plane2.normal)) > 1.0 - 1e-10) {\n            // perform separating axis intersection test only for coplanar triangles\n            const satBounds1 = this.satBounds;\n            const satAxes1 = this.satAxes;\n            arr2[0] = other.a;\n            arr2[1] = other.b;\n            arr2[2] = other.c;\n            for(let i = 0; i < 4; i++){\n                const sb = satBounds1[i];\n                const sa = satAxes1[i];\n                cachedSatBounds.setFromPoints(sa, arr2);\n                if (sb.isSeparated(cachedSatBounds)) return false;\n            }\n            const satBounds2 = other.satBounds;\n            const satAxes2 = other.satAxes;\n            arr1[0] = this.a;\n            arr1[1] = this.b;\n            arr1[2] = this.c;\n            for(let i = 0; i < 4; i++){\n                const sb = satBounds2[i];\n                const sa = satAxes2[i];\n                cachedSatBounds.setFromPoints(sa, arr1);\n                if (sb.isSeparated(cachedSatBounds)) return false;\n            }\n            // check crossed axes\n            for(let i = 0; i < 4; i++){\n                const sa1 = satAxes1[i];\n                for(let i2 = 0; i2 < 4; i2++){\n                    const sa2 = satAxes2[i2];\n                    cachedAxis.crossVectors(sa1, sa2);\n                    cachedSatBounds.setFromPoints(cachedAxis, arr1);\n                    cachedSatBounds2.setFromPoints(cachedAxis, arr2);\n                    if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n                }\n            }\n            if (target) {\n                // TODO find two points that intersect on the edges and make that the result\n                if (!suppressLog) console.warn(\"ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.\");\n                target.start.set(0, 0, 0);\n                target.end.set(0, 0, 0);\n            }\n            return true;\n        } else {\n            // find the edge that intersects the other triangle plane\n            const count1 = triIntersectPlane(this, plane2, edge1);\n            if (count1 === 1 && other.containsPoint(edge1.end)) {\n                if (target) {\n                    target.start.copy(edge1.end);\n                    target.end.copy(edge1.end);\n                }\n                return true;\n            } else if (count1 !== 2) return false;\n            // find the other triangles edge that intersects this plane\n            const count2 = triIntersectPlane(other, plane1, edge2);\n            if (count2 === 1 && this.containsPoint(edge2.end)) {\n                if (target) {\n                    target.start.copy(edge2.end);\n                    target.end.copy(edge2.end);\n                }\n                return true;\n            } else if (count2 !== 2) return false;\n            // find swap the second edge so both lines are running the same direction\n            edge1.delta(dir1);\n            edge2.delta(dir2);\n            if (dir1.dot(dir2) < 0) {\n                let tmp = edge2.start;\n                edge2.start = edge2.end;\n                edge2.end = tmp;\n            }\n            // check if the edges are overlapping\n            const s1 = edge1.start.dot(dir1);\n            const e1 = edge1.end.dot(dir1);\n            const s2 = edge2.start.dot(dir1);\n            const e2 = edge2.end.dot(dir1);\n            const separated1 = e1 < s2;\n            const separated2 = s1 < e2;\n            if (s1 !== e2 && s2 !== e1 && separated1 === separated2) return false;\n            // assign the target output\n            if (target) {\n                tempDir.subVectors(edge1.start, edge2.start);\n                if (tempDir.dot(dir1) > 0) target.start.copy(edge1.start);\n                else target.start.copy(edge2.start);\n                tempDir.subVectors(edge1.end, edge2.end);\n                if (tempDir.dot(dir1) < 0) target.end.copy(edge1.end);\n                else target.end.copy(edge2.end);\n            }\n            return true;\n        }\n    };\n}();\n$277ed51eec8cb2f4$export$a37f7ec1c23dfacf.prototype.distanceToPoint = function() {\n    const target = new (0, $e06gU.Vector3)();\n    return function distanceToPoint(point) {\n        this.closestPointToPoint(point, target);\n        return point.distanceTo(target);\n    };\n}();\n$277ed51eec8cb2f4$export$a37f7ec1c23dfacf.prototype.distanceToTriangle = function() {\n    const point = new (0, $e06gU.Vector3)();\n    const point2 = new (0, $e06gU.Vector3)();\n    const cornerFields = [\n        \"a\",\n        \"b\",\n        \"c\"\n    ];\n    const line1 = new (0, $e06gU.Line3)();\n    const line2 = new (0, $e06gU.Line3)();\n    return function distanceToTriangle(other, target1 = null, target2 = null) {\n        const lineTarget = target1 || target2 ? line1 : null;\n        if (this.intersectsTriangle(other, lineTarget)) {\n            if (target1 || target2) {\n                if (target1) lineTarget.getCenter(target1);\n                if (target2) lineTarget.getCenter(target2);\n            }\n            return 0;\n        }\n        let closestDistanceSq = Infinity;\n        // check all point distances\n        for(let i = 0; i < 3; i++){\n            let dist;\n            const field = cornerFields[i];\n            const otherVec = other[field];\n            this.closestPointToPoint(otherVec, point);\n            dist = otherVec.distanceToSquared(point);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(point);\n                if (target2) target2.copy(otherVec);\n            }\n            const thisVec = this[field];\n            other.closestPointToPoint(thisVec, point);\n            dist = thisVec.distanceToSquared(point);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(thisVec);\n                if (target2) target2.copy(point);\n            }\n        }\n        for(let i = 0; i < 3; i++){\n            const f11 = cornerFields[i];\n            const f12 = cornerFields[(i + 1) % 3];\n            line1.set(this[f11], this[f12]);\n            for(let i2 = 0; i2 < 3; i2++){\n                const f21 = cornerFields[i2];\n                const f22 = cornerFields[(i2 + 1) % 3];\n                line2.set(other[f21], other[f22]);\n                (0, $1300ab831e41e936$export$b09f296caca7547a)(line1, line2, point, point2);\n                const dist = point.distanceToSquared(point2);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point);\n                    if (target2) target2.copy(point2);\n                }\n            }\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n\n\n\nclass $2210a8ccded54a38$export$4ccecd8ac6ee0e58 {\n    constructor(min, max, matrix){\n        this.isOrientedBox = true;\n        this.min = new (0, $e06gU.Vector3)();\n        this.max = new (0, $e06gU.Vector3)();\n        this.matrix = new (0, $e06gU.Matrix4)();\n        this.invMatrix = new (0, $e06gU.Matrix4)();\n        this.points = new Array(8).fill().map(()=>new (0, $e06gU.Vector3)());\n        this.satAxes = new Array(3).fill().map(()=>new (0, $e06gU.Vector3)());\n        this.satBounds = new Array(3).fill().map(()=>new (0, $34f95eced4ec08e7$export$f758e41ecdcd8e69)());\n        this.alignedSatBounds = new Array(3).fill().map(()=>new (0, $34f95eced4ec08e7$export$f758e41ecdcd8e69)());\n        this.needsUpdate = false;\n        if (min) this.min.copy(min);\n        if (max) this.max.copy(max);\n        if (matrix) this.matrix.copy(matrix);\n    }\n    set(min, max, matrix) {\n        this.min.copy(min);\n        this.max.copy(max);\n        this.matrix.copy(matrix);\n        this.needsUpdate = true;\n    }\n    copy(other) {\n        this.min.copy(other.min);\n        this.max.copy(other.max);\n        this.matrix.copy(other.matrix);\n        this.needsUpdate = true;\n    }\n}\n$2210a8ccded54a38$export$4ccecd8ac6ee0e58.prototype.update = function() {\n    return function update() {\n        const matrix = this.matrix;\n        const min = this.min;\n        const max = this.max;\n        const points = this.points;\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++)for(let z = 0; z <= 1; z++){\n                const i = 1 * x | 2 * y | 4 * z;\n                const v = points[i];\n                v.x = x ? max.x : min.x;\n                v.y = y ? max.y : min.y;\n                v.z = z ? max.z : min.z;\n                v.applyMatrix4(matrix);\n            }\n        }\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        const minVec = points[0];\n        for(let i = 0; i < 3; i++){\n            const axis = satAxes[i];\n            const sb = satBounds[i];\n            const index = 1 << i;\n            const pi = points[index];\n            axis.subVectors(minVec, pi);\n            sb.setFromPoints(axis, points);\n        }\n        const alignedSatBounds = this.alignedSatBounds;\n        alignedSatBounds[0].setFromPointsField(points, \"x\");\n        alignedSatBounds[1].setFromPointsField(points, \"y\");\n        alignedSatBounds[2].setFromPointsField(points, \"z\");\n        this.invMatrix.copy(this.matrix).invert();\n        this.needsUpdate = false;\n    };\n}();\n$2210a8ccded54a38$export$4ccecd8ac6ee0e58.prototype.intersectsBox = function() {\n    const aabbBounds = new (0, $34f95eced4ec08e7$export$f758e41ecdcd8e69)();\n    return function intersectsBox(box) {\n        // TODO: should this be doing SAT against the AABB?\n        if (this.needsUpdate) this.update();\n        const min = box.min;\n        const max = box.max;\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        const alignedSatBounds = this.alignedSatBounds;\n        aabbBounds.min = min.x;\n        aabbBounds.max = max.x;\n        if (alignedSatBounds[0].isSeparated(aabbBounds)) return false;\n        aabbBounds.min = min.y;\n        aabbBounds.max = max.y;\n        if (alignedSatBounds[1].isSeparated(aabbBounds)) return false;\n        aabbBounds.min = min.z;\n        aabbBounds.max = max.z;\n        if (alignedSatBounds[2].isSeparated(aabbBounds)) return false;\n        for(let i = 0; i < 3; i++){\n            const axis = satAxes[i];\n            const sb = satBounds[i];\n            aabbBounds.setFromBox(axis, box);\n            if (sb.isSeparated(aabbBounds)) return false;\n        }\n        return true;\n    };\n}();\n$2210a8ccded54a38$export$4ccecd8ac6ee0e58.prototype.intersectsTriangle = function() {\n    const saTri = new (0, $277ed51eec8cb2f4$export$a37f7ec1c23dfacf)();\n    const pointsArr = new Array(3);\n    const cachedSatBounds = new (0, $34f95eced4ec08e7$export$f758e41ecdcd8e69)();\n    const cachedSatBounds2 = new (0, $34f95eced4ec08e7$export$f758e41ecdcd8e69)();\n    const cachedAxis = new (0, $e06gU.Vector3)();\n    return function intersectsTriangle(triangle) {\n        if (this.needsUpdate) this.update();\n        if (!triangle.isExtendedTriangle) {\n            saTri.copy(triangle);\n            saTri.update();\n            triangle = saTri;\n        } else if (triangle.needsUpdate) triangle.update();\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        pointsArr[0] = triangle.a;\n        pointsArr[1] = triangle.b;\n        pointsArr[2] = triangle.c;\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds[i];\n            const sa = satAxes[i];\n            cachedSatBounds.setFromPoints(sa, pointsArr);\n            if (sb.isSeparated(cachedSatBounds)) return false;\n        }\n        const triSatBounds = triangle.satBounds;\n        const triSatAxes = triangle.satAxes;\n        const points = this.points;\n        for(let i = 0; i < 3; i++){\n            const sb = triSatBounds[i];\n            const sa = triSatAxes[i];\n            cachedSatBounds.setFromPoints(sa, points);\n            if (sb.isSeparated(cachedSatBounds)) return false;\n        }\n        // check crossed axes\n        for(let i = 0; i < 3; i++){\n            const sa1 = satAxes[i];\n            for(let i2 = 0; i2 < 4; i2++){\n                const sa2 = triSatAxes[i2];\n                cachedAxis.crossVectors(sa1, sa2);\n                cachedSatBounds.setFromPoints(cachedAxis, pointsArr);\n                cachedSatBounds2.setFromPoints(cachedAxis, points);\n                if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n            }\n        }\n        return true;\n    };\n}();\n$2210a8ccded54a38$export$4ccecd8ac6ee0e58.prototype.closestPointToPoint = function() {\n    return function closestPointToPoint(point, target1) {\n        if (this.needsUpdate) this.update();\n        target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);\n        return target1;\n    };\n}();\n$2210a8ccded54a38$export$4ccecd8ac6ee0e58.prototype.distanceToPoint = function() {\n    const target = new (0, $e06gU.Vector3)();\n    return function distanceToPoint(point) {\n        this.closestPointToPoint(point, target);\n        return point.distanceTo(target);\n    };\n}();\n$2210a8ccded54a38$export$4ccecd8ac6ee0e58.prototype.distanceToBox = function() {\n    const xyzFields = [\n        \"x\",\n        \"y\",\n        \"z\"\n    ];\n    const segments1 = new Array(12).fill().map(()=>new (0, $e06gU.Line3)());\n    const segments2 = new Array(12).fill().map(()=>new (0, $e06gU.Line3)());\n    const point1 = new (0, $e06gU.Vector3)();\n    const point2 = new (0, $e06gU.Vector3)();\n    // early out if we find a value below threshold\n    return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {\n        if (this.needsUpdate) this.update();\n        if (this.intersectsBox(box)) {\n            if (target1 || target2) {\n                box.getCenter(point2);\n                this.closestPointToPoint(point2, point1);\n                box.closestPointToPoint(point1, point2);\n                if (target1) target1.copy(point1);\n                if (target2) target2.copy(point2);\n            }\n            return 0;\n        }\n        const threshold2 = threshold * threshold;\n        const min = box.min;\n        const max = box.max;\n        const points = this.points;\n        // iterate over every edge and compare distances\n        let closestDistanceSq = Infinity;\n        // check over all these points\n        for(let i = 0; i < 8; i++){\n            const p = points[i];\n            point2.copy(p).clamp(min, max);\n            const dist = p.distanceToSquared(point2);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(p);\n                if (target2) target2.copy(point2);\n                if (dist < threshold2) return Math.sqrt(dist);\n            }\n        }\n        // generate and check all line segment distances\n        let count = 0;\n        for(let i = 0; i < 3; i++){\n            for(let i1 = 0; i1 <= 1; i1++)for(let i2 = 0; i2 <= 1; i2++){\n                const nextIndex = (i + 1) % 3;\n                const nextIndex2 = (i + 2) % 3;\n                // get obb line segments\n                const index = i1 << nextIndex | i2 << nextIndex2;\n                const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n                const p1 = points[index];\n                const p2 = points[index2];\n                const line1 = segments1[count];\n                line1.set(p1, p2);\n                // get aabb line segments\n                const f1 = xyzFields[i];\n                const f2 = xyzFields[nextIndex];\n                const f3 = xyzFields[nextIndex2];\n                const line2 = segments2[count];\n                const start = line2.start;\n                const end = line2.end;\n                start[f1] = min[f1];\n                start[f2] = i1 ? min[f2] : max[f2];\n                start[f3] = i2 ? min[f3] : max[f2];\n                end[f1] = max[f1];\n                end[f2] = i1 ? min[f2] : max[f2];\n                end[f3] = i2 ? min[f3] : max[f2];\n                count++;\n            }\n        }\n        // check all the other boxes point\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++)for(let z = 0; z <= 1; z++){\n                point2.x = x ? max.x : min.x;\n                point2.y = y ? max.y : min.y;\n                point2.z = z ? max.z : min.z;\n                this.closestPointToPoint(point2, point1);\n                const dist = point2.distanceToSquared(point1);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point1);\n                    if (target2) target2.copy(point2);\n                    if (dist < threshold2) return Math.sqrt(dist);\n                }\n            }\n        }\n        for(let i = 0; i < 12; i++){\n            const l1 = segments1[i];\n            for(let i2 = 0; i2 < 12; i2++){\n                const l2 = segments2[i2];\n                (0, $1300ab831e41e936$export$b09f296caca7547a)(l1, l2, point1, point2);\n                const dist = point1.distanceToSquared(point2);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point1);\n                    if (target2) target2.copy(point2);\n                    if (dist < threshold2) return Math.sqrt(dist);\n                }\n            }\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n\n\n\n\nclass $4a3ee1d4de1c7643$export$bf300c504651112a {\n    constructor(getNewPrimitive){\n        this._getNewPrimitive = getNewPrimitive;\n        this._primitives = [];\n    }\n    getPrimitive() {\n        const primitives = this._primitives;\n        if (primitives.length === 0) return this._getNewPrimitive();\n        else return primitives.pop();\n    }\n    releasePrimitive(primitive) {\n        this._primitives.push(primitive);\n    }\n}\n\n\nclass $a7a12bd8496afd7c$var$ExtendedTrianglePoolBase extends (0, $4a3ee1d4de1c7643$export$bf300c504651112a) {\n    constructor(){\n        super(()=>new (0, $277ed51eec8cb2f4$export$a37f7ec1c23dfacf)());\n    }\n}\nconst $a7a12bd8496afd7c$export$2622f4315304edad = /* @__PURE__ */ new $a7a12bd8496afd7c$var$ExtendedTrianglePoolBase();\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\n\nfunction $8c79b2483f36f80e$export$bc7cbaf27fbe938e(n16, uint16Array) {\n    return uint16Array[n16 + 15] === 0xFFFF;\n}\nfunction $8c79b2483f36f80e$export$3231e969238304f3(n32, uint32Array) {\n    return uint32Array[n32 + 6];\n}\nfunction $8c79b2483f36f80e$export$d61684373eacdf61(n16, uint16Array) {\n    return uint16Array[n16 + 14];\n}\nfunction $8c79b2483f36f80e$export$7a68bc00425859d(n32) {\n    return n32 + 8;\n}\nfunction $8c79b2483f36f80e$export$4f44f52d9f75fa31(n32, uint32Array) {\n    return uint32Array[n32 + 6];\n}\nfunction $8c79b2483f36f80e$export$b43717b3ca95505(n32, uint32Array) {\n    return uint32Array[n32 + 7];\n}\nfunction $8c79b2483f36f80e$export$b5b7e27a1440579d(n32) {\n    return n32;\n}\n\n\nclass $00672725876edc9e$var$_BufferStack {\n    constructor(){\n        this.float32Array = null;\n        this.uint16Array = null;\n        this.uint32Array = null;\n        const stack = [];\n        let prevBuffer = null;\n        this.setBuffer = (buffer)=>{\n            if (prevBuffer) stack.push(prevBuffer);\n            prevBuffer = buffer;\n            this.float32Array = new Float32Array(buffer);\n            this.uint16Array = new Uint16Array(buffer);\n            this.uint32Array = new Uint32Array(buffer);\n        };\n        this.clearBuffer = ()=>{\n            prevBuffer = null;\n            this.float32Array = null;\n            this.uint16Array = null;\n            this.uint32Array = null;\n            if (stack.length !== 0) this.setBuffer(stack.pop());\n        };\n    }\n}\nconst $00672725876edc9e$export$7451c73ce907854f = new $00672725876edc9e$var$_BufferStack();\n\n\nlet $59a851f097f5ef7e$var$_box1, $59a851f097f5ef7e$var$_box2;\nconst $59a851f097f5ef7e$var$boxStack = [];\nconst $59a851f097f5ef7e$var$boxPool = /* @__PURE__ */ new (0, $4a3ee1d4de1c7643$export$bf300c504651112a)(()=>new (0, $e06gU.Box3)());\nfunction $59a851f097f5ef7e$export$963c78622ed2c172(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {\n    // setup\n    $59a851f097f5ef7e$var$_box1 = $59a851f097f5ef7e$var$boxPool.getPrimitive();\n    $59a851f097f5ef7e$var$_box2 = $59a851f097f5ef7e$var$boxPool.getPrimitive();\n    $59a851f097f5ef7e$var$boxStack.push($59a851f097f5ef7e$var$_box1, $59a851f097f5ef7e$var$_box2);\n    (0, $00672725876edc9e$export$7451c73ce907854f).setBuffer(bvh._roots[root]);\n    const result = $59a851f097f5ef7e$var$shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n    // cleanup\n    (0, $00672725876edc9e$export$7451c73ce907854f).clearBuffer();\n    $59a851f097f5ef7e$var$boxPool.releasePrimitive($59a851f097f5ef7e$var$_box1);\n    $59a851f097f5ef7e$var$boxPool.releasePrimitive($59a851f097f5ef7e$var$_box2);\n    $59a851f097f5ef7e$var$boxStack.pop();\n    $59a851f097f5ef7e$var$boxStack.pop();\n    const length = $59a851f097f5ef7e$var$boxStack.length;\n    if (length > 0) {\n        $59a851f097f5ef7e$var$_box2 = $59a851f097f5ef7e$var$boxStack[length - 1];\n        $59a851f097f5ef7e$var$_box1 = $59a851f097f5ef7e$var$boxStack[length - 2];\n    }\n    return result;\n}\nfunction $59a851f097f5ef7e$var$shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $00672725876edc9e$export$7451c73ce907854f);\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8c79b2483f36f80e$export$3231e969238304f3)(nodeIndex32, uint32Array);\n        const count = (0, $8c79b2483f36f80e$export$d61684373eacdf61)(nodeIndex16, uint16Array);\n        (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(nodeIndex32), float32Array, $59a851f097f5ef7e$var$_box1);\n        return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, $59a851f097f5ef7e$var$_box1);\n    } else {\n        const left = (0, $8c79b2483f36f80e$export$7a68bc00425859d)(nodeIndex32);\n        const right = (0, $8c79b2483f36f80e$export$4f44f52d9f75fa31)(nodeIndex32, uint32Array);\n        let c1 = left;\n        let c2 = right;\n        let score1, score2;\n        let box1, box2;\n        if (nodeScoreFunc) {\n            box1 = $59a851f097f5ef7e$var$_box1;\n            box2 = $59a851f097f5ef7e$var$_box2;\n            // bounding data is not offset\n            (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(c1), float32Array, box1);\n            (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(c2), float32Array, box2);\n            score1 = nodeScoreFunc(box1);\n            score2 = nodeScoreFunc(box2);\n            if (score2 < score1) {\n                c1 = right;\n                c2 = left;\n                const temp = score1;\n                score1 = score2;\n                score2 = temp;\n                box1 = box2;\n            // box2 is always set before use below\n            }\n        }\n        // Check box 1 intersection\n        if (!box1) {\n            box1 = $59a851f097f5ef7e$var$_box1;\n            (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(c1), float32Array, box1);\n        }\n        const isC1Leaf = (0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(c1 * 2, uint16Array);\n        const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n        let c1StopTraversal;\n        if (c1Intersection === (0, $bc798809290ffd6b$export$82ad94f0a038b67a)) {\n            const offset = getLeftOffset(c1);\n            const end = getRightEndOffset(c1);\n            const count = end - offset;\n            c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n        } else c1StopTraversal = c1Intersection && $59a851f097f5ef7e$var$shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n        if (c1StopTraversal) return true;\n        // Check box 2 intersection\n        // cached box2 will have been overwritten by previous traversal\n        box2 = $59a851f097f5ef7e$var$_box2;\n        (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(c2), float32Array, box2);\n        const isC2Leaf = (0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(c2 * 2, uint16Array);\n        const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n        let c2StopTraversal;\n        if (c2Intersection === (0, $bc798809290ffd6b$export$82ad94f0a038b67a)) {\n            const offset = getLeftOffset(c2);\n            const end = getRightEndOffset(c2);\n            const count = end - offset;\n            c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);\n        } else c2StopTraversal = c2Intersection && $59a851f097f5ef7e$var$shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n        if (c2StopTraversal) return true;\n        return false;\n        // Define these inside the function so it has access to the local variables needed\n        // when converting to the buffer equivalents\n        function getLeftOffset(nodeIndex32) {\n            const { uint16Array: uint16Array, uint32Array: uint32Array } = (0, $00672725876edc9e$export$7451c73ce907854f);\n            let nodeIndex16 = nodeIndex32 * 2;\n            // traverse until we find a leaf\n            while(!(0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(nodeIndex16, uint16Array)){\n                nodeIndex32 = (0, $8c79b2483f36f80e$export$7a68bc00425859d)(nodeIndex32);\n                nodeIndex16 = nodeIndex32 * 2;\n            }\n            return (0, $8c79b2483f36f80e$export$3231e969238304f3)(nodeIndex32, uint32Array);\n        }\n        function getRightEndOffset(nodeIndex32) {\n            const { uint16Array: uint16Array, uint32Array: uint32Array } = (0, $00672725876edc9e$export$7451c73ce907854f);\n            let nodeIndex16 = nodeIndex32 * 2;\n            // traverse until we find a leaf\n            while(!(0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(nodeIndex16, uint16Array)){\n                // adjust offset to point to the right node\n                nodeIndex32 = (0, $8c79b2483f36f80e$export$4f44f52d9f75fa31)(nodeIndex32, uint32Array);\n                nodeIndex16 = nodeIndex32 * 2;\n            }\n            // return the end offset of the triangle range\n            return (0, $8c79b2483f36f80e$export$3231e969238304f3)(nodeIndex32, uint32Array) + (0, $8c79b2483f36f80e$export$d61684373eacdf61)(nodeIndex16, uint16Array);\n        }\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\nconst $452345387fe1f65a$var$temp = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $452345387fe1f65a$var$temp1 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nfunction $452345387fe1f65a$export$96ec44700e587d99(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n    // early out if under minThreshold\n    // skip checking if over maxThreshold\n    // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n    // returns Infinity if no value found\n    const minThresholdSq = minThreshold * minThreshold;\n    const maxThresholdSq = maxThreshold * maxThreshold;\n    let closestDistanceSq = Infinity;\n    let closestDistanceTriIndex = null;\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            $452345387fe1f65a$var$temp.copy(point).clamp(box.min, box.max);\n            return $452345387fe1f65a$var$temp.distanceToSquared(point);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: (tri, triIndex)=>{\n            tri.closestPointToPoint(point, $452345387fe1f65a$var$temp);\n            const distSq = point.distanceToSquared($452345387fe1f65a$var$temp);\n            if (distSq < closestDistanceSq) {\n                $452345387fe1f65a$var$temp1.copy($452345387fe1f65a$var$temp);\n                closestDistanceSq = distSq;\n                closestDistanceTriIndex = triIndex;\n            }\n            if (distSq < minThresholdSq) return true;\n            else return false;\n        }\n    });\n    if (closestDistanceSq === Infinity) return null;\n    const closestDistance = Math.sqrt(closestDistanceSq);\n    if (!target.point) target.point = $452345387fe1f65a$var$temp1.clone();\n    else target.point.copy($452345387fe1f65a$var$temp1);\n    target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n    return target;\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst $7db34e138f2585de$var$_vA = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $7db34e138f2585de$var$_vB = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $7db34e138f2585de$var$_vC = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $7db34e138f2585de$var$_uvA = /* @__PURE__ */ new (0, $e06gU.Vector2)();\nconst $7db34e138f2585de$var$_uvB = /* @__PURE__ */ new (0, $e06gU.Vector2)();\nconst $7db34e138f2585de$var$_uvC = /* @__PURE__ */ new (0, $e06gU.Vector2)();\nconst $7db34e138f2585de$var$_normalA = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $7db34e138f2585de$var$_normalB = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $7db34e138f2585de$var$_normalC = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $7db34e138f2585de$var$_intersectionPoint = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nfunction $7db34e138f2585de$var$checkIntersection(ray, pA, pB, pC, point, side) {\n    let intersect;\n    if (side === (0, $e06gU.BackSide)) intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    else intersect = ray.intersectTriangle(pA, pB, pC, side !== (0, $e06gU.DoubleSide), point);\n    if (intersect === null) return null;\n    const distance = ray.origin.distanceTo(point);\n    return {\n        distance: distance,\n        point: point.clone()\n    };\n}\nfunction $7db34e138f2585de$var$checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side) {\n    $7db34e138f2585de$var$_vA.fromBufferAttribute(position, a);\n    $7db34e138f2585de$var$_vB.fromBufferAttribute(position, b);\n    $7db34e138f2585de$var$_vC.fromBufferAttribute(position, c);\n    const intersection = $7db34e138f2585de$var$checkIntersection(ray, $7db34e138f2585de$var$_vA, $7db34e138f2585de$var$_vB, $7db34e138f2585de$var$_vC, $7db34e138f2585de$var$_intersectionPoint, side);\n    if (intersection) {\n        if (uv) {\n            $7db34e138f2585de$var$_uvA.fromBufferAttribute(uv, a);\n            $7db34e138f2585de$var$_uvB.fromBufferAttribute(uv, b);\n            $7db34e138f2585de$var$_uvC.fromBufferAttribute(uv, c);\n            intersection.uv = (0, $e06gU.Triangle).getInterpolation($7db34e138f2585de$var$_intersectionPoint, $7db34e138f2585de$var$_vA, $7db34e138f2585de$var$_vB, $7db34e138f2585de$var$_vC, $7db34e138f2585de$var$_uvA, $7db34e138f2585de$var$_uvB, $7db34e138f2585de$var$_uvC, new (0, $e06gU.Vector2)());\n        }\n        if (uv1) {\n            $7db34e138f2585de$var$_uvA.fromBufferAttribute(uv1, a);\n            $7db34e138f2585de$var$_uvB.fromBufferAttribute(uv1, b);\n            $7db34e138f2585de$var$_uvC.fromBufferAttribute(uv1, c);\n            intersection.uv1 = (0, $e06gU.Triangle).getInterpolation($7db34e138f2585de$var$_intersectionPoint, $7db34e138f2585de$var$_vA, $7db34e138f2585de$var$_vB, $7db34e138f2585de$var$_vC, $7db34e138f2585de$var$_uvA, $7db34e138f2585de$var$_uvB, $7db34e138f2585de$var$_uvC, new (0, $e06gU.Vector2)());\n        }\n        if (normal) {\n            $7db34e138f2585de$var$_normalA.fromBufferAttribute(normal, a);\n            $7db34e138f2585de$var$_normalB.fromBufferAttribute(normal, b);\n            $7db34e138f2585de$var$_normalC.fromBufferAttribute(normal, c);\n            intersection.normal = (0, $e06gU.Triangle).getInterpolation($7db34e138f2585de$var$_intersectionPoint, $7db34e138f2585de$var$_vA, $7db34e138f2585de$var$_vB, $7db34e138f2585de$var$_vC, $7db34e138f2585de$var$_normalA, $7db34e138f2585de$var$_normalB, $7db34e138f2585de$var$_normalC, new (0, $e06gU.Vector3)());\n            if (intersection.normal.dot(ray.direction) > 0) intersection.normal.multiplyScalar(-1);\n        }\n        const face = {\n            a: a,\n            b: b,\n            c: c,\n            normal: new (0, $e06gU.Vector3)(),\n            materialIndex: 0\n        };\n        (0, $e06gU.Triangle).getNormal($7db34e138f2585de$var$_vA, $7db34e138f2585de$var$_vB, $7db34e138f2585de$var$_vC, face.normal);\n        intersection.face = face;\n        intersection.faceIndex = a;\n    }\n    return intersection;\n}\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction $7db34e138f2585de$export$1a557053019a130b(geo, side, ray, tri, intersections) {\n    const triOffset = tri * 3;\n    let a = triOffset + 0;\n    let b = triOffset + 1;\n    let c = triOffset + 2;\n    const index = geo.index;\n    if (geo.index) {\n        a = index.getX(a);\n        b = index.getX(b);\n        c = index.getX(c);\n    }\n    const { position: position, normal: normal, uv: uv, uv1: uv1 } = geo.attributes;\n    const intersection = $7db34e138f2585de$var$checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side);\n    if (intersection) {\n        intersection.faceIndex = tri;\n        if (intersections) intersections.push(intersection);\n        return intersection;\n    }\n    return null;\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\nfunction $eb6f5960b3eb8549$export$32f7fa781964ae30(tri, i, index, pos) {\n    const ta = tri.a;\n    const tb = tri.b;\n    const tc = tri.c;\n    let i0 = i;\n    let i1 = i + 1;\n    let i2 = i + 2;\n    if (index) {\n        i0 = index.getX(i0);\n        i1 = index.getX(i1);\n        i2 = index.getX(i2);\n    }\n    ta.x = pos.getX(i0);\n    ta.y = pos.getY(i0);\n    ta.z = pos.getZ(i0);\n    tb.x = pos.getX(i1);\n    tb.y = pos.getY(i1);\n    tb.z = pos.getZ(i1);\n    tc.x = pos.getX(i2);\n    tc.y = pos.getY(i2);\n    tc.z = pos.getZ(i2);\n}\nconst $eb6f5960b3eb8549$var$tempV1 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $eb6f5960b3eb8549$var$tempV2 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $eb6f5960b3eb8549$var$tempV3 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $eb6f5960b3eb8549$var$tempUV1 = /* @__PURE__ */ new (0, $e06gU.Vector2)();\nconst $eb6f5960b3eb8549$var$tempUV2 = /* @__PURE__ */ new (0, $e06gU.Vector2)();\nconst $eb6f5960b3eb8549$var$tempUV3 = /* @__PURE__ */ new (0, $e06gU.Vector2)();\nfunction $eb6f5960b3eb8549$export$d3cf03f2575167ef(point, geometry, triangleIndex, target) {\n    const indices = geometry.getIndex().array;\n    const positions = geometry.getAttribute(\"position\");\n    const uvs = geometry.getAttribute(\"uv\");\n    const a = indices[triangleIndex * 3];\n    const b = indices[triangleIndex * 3 + 1];\n    const c = indices[triangleIndex * 3 + 2];\n    $eb6f5960b3eb8549$var$tempV1.fromBufferAttribute(positions, a);\n    $eb6f5960b3eb8549$var$tempV2.fromBufferAttribute(positions, b);\n    $eb6f5960b3eb8549$var$tempV3.fromBufferAttribute(positions, c);\n    // find the associated material index\n    let materialIndex = 0;\n    const groups = geometry.groups;\n    const firstVertexIndex = triangleIndex * 3;\n    for(let i = 0, l = groups.length; i < l; i++){\n        const group = groups[i];\n        const { start: start, count: count } = group;\n        if (firstVertexIndex >= start && firstVertexIndex < start + count) {\n            materialIndex = group.materialIndex;\n            break;\n        }\n    }\n    // extract uvs\n    let uv = null;\n    if (uvs) {\n        $eb6f5960b3eb8549$var$tempUV1.fromBufferAttribute(uvs, a);\n        $eb6f5960b3eb8549$var$tempUV2.fromBufferAttribute(uvs, b);\n        $eb6f5960b3eb8549$var$tempUV3.fromBufferAttribute(uvs, c);\n        if (target && target.uv) uv = target.uv;\n        else uv = new (0, $e06gU.Vector2)();\n        (0, $e06gU.Triangle).getInterpolation(point, $eb6f5960b3eb8549$var$tempV1, $eb6f5960b3eb8549$var$tempV2, $eb6f5960b3eb8549$var$tempV3, $eb6f5960b3eb8549$var$tempUV1, $eb6f5960b3eb8549$var$tempUV2, $eb6f5960b3eb8549$var$tempUV3, uv);\n    }\n    // adjust the provided target or create a new one\n    if (target) {\n        if (!target.face) target.face = {};\n        target.face.a = a;\n        target.face.b = b;\n        target.face.c = c;\n        target.face.materialIndex = materialIndex;\n        if (!target.face.normal) target.face.normal = new (0, $e06gU.Vector3)();\n        (0, $e06gU.Triangle).getNormal($eb6f5960b3eb8549$var$tempV1, $eb6f5960b3eb8549$var$tempV2, $eb6f5960b3eb8549$var$tempV3, target.face.normal);\n        if (uv) target.uv = uv;\n        return target;\n    } else return {\n        face: {\n            a: a,\n            b: b,\n            c: c,\n            materialIndex: materialIndex,\n            normal: (0, $e06gU.Triangle).getNormal($eb6f5960b3eb8549$var$tempV1, $eb6f5960b3eb8549$var$tempV2, $eb6f5960b3eb8549$var$tempV3, new (0, $e06gU.Vector3)())\n        },\n        uv: uv\n    };\n}\n\n\n/*************************************************************/ /* This file is generated from \"iterationUtils.template.js\". */ /*************************************************************/ /* eslint-disable indent */ function $9474092dcc9c56eb$export$6f0a8fc5d2775a51(bvh, side, ray, offset, count, intersections) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    for(let i = offset, end = offset + count; i < end; i++)(0, $7db34e138f2585de$export$1a557053019a130b)(geometry, side, ray, i, intersections);\n}\nfunction $9474092dcc9c56eb$export$4331f2604b0bca4(bvh, side, ray, offset, count) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    let dist = Infinity;\n    let res = null;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let intersection;\n        intersection = (0, $7db34e138f2585de$export$1a557053019a130b)(geometry, side, ray, i);\n        if (intersection && intersection.distance < dist) {\n            res = intersection;\n            dist = intersection.distance;\n        }\n    }\n    return res;\n}\nfunction $9474092dcc9c56eb$export$be1391b7aa79c0f6(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle) {\n    const { geometry: geometry } = bvh;\n    const { index: index } = geometry;\n    const pos = geometry.attributes.position;\n    for(let i = offset, l = count + offset; i < l; i++){\n        let tri;\n        tri = i;\n        (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle, tri * 3, index, pos);\n        triangle.needsUpdate = true;\n        if (intersectsTriangleFunc(triangle, tri, contained, depth)) return true;\n    }\n    return false;\n}\n\n\n\n/****************************************************/ /* This file is generated from \"refit.template.js\". */ /****************************************************/ function $d6886d66b20a1b65$export$8eb1eda96b2e6d7a(bvh, nodeIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) nodeIndices = new Set(nodeIndices);\n    const geometry = bvh.geometry;\n    const indexArr = geometry.index ? geometry.index.array : null;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = bvh._roots;\n    for(let i = 0, l = roots.length; i < l; i++){\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset, force = false) {\n        const node16Index = node32Index * 2;\n        const isLeaf = uint16Array[node16Index + 15] === (0, $bc798809290ffd6b$export$661fddb62bfe0e42);\n        if (isLeaf) {\n            const offset = uint32Array[node32Index + 6];\n            const count = uint16Array[node16Index + 14];\n            let minx = Infinity;\n            let miny = Infinity;\n            let minz = Infinity;\n            let maxx = -Infinity;\n            let maxy = -Infinity;\n            let maxz = -Infinity;\n            for(let i = 3 * offset, l = 3 * (offset + count); i < l; i++){\n                let index = indexArr[i];\n                const x = posAttr.getX(index);\n                const y = posAttr.getY(index);\n                const z = posAttr.getZ(index);\n                if (x < minx) minx = x;\n                if (x > maxx) maxx = x;\n                if (y < miny) miny = y;\n                if (y > maxy) maxy = y;\n                if (z < minz) minz = z;\n                if (z > maxz) maxz = z;\n            }\n            if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n                float32Array[node32Index + 0] = minx;\n                float32Array[node32Index + 1] = miny;\n                float32Array[node32Index + 2] = minz;\n                float32Array[node32Index + 3] = maxx;\n                float32Array[node32Index + 4] = maxy;\n                float32Array[node32Index + 5] = maxz;\n                return true;\n            } else return false;\n        } else {\n            const left = node32Index + 8;\n            const right = uint32Array[node32Index + 6];\n            // the identifying node indices provided by the shapecast function include offsets of all\n            // root buffers to guarantee they're unique between roots so offset left and right indices here.\n            const offsetLeft = left + byteOffset;\n            const offsetRight = right + byteOffset;\n            let forceChildren = force;\n            let includesLeft = false;\n            let includesRight = false;\n            if (nodeIndices) // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            {\n                if (!forceChildren) {\n                    includesLeft = nodeIndices.has(offsetLeft);\n                    includesRight = nodeIndices.has(offsetRight);\n                    forceChildren = !includesLeft && !includesRight;\n                }\n            } else {\n                includesLeft = true;\n                includesRight = true;\n            }\n            const traverseLeft = forceChildren || includesLeft;\n            const traverseRight = forceChildren || includesRight;\n            let leftChange = false;\n            if (traverseLeft) leftChange = _traverse(left, byteOffset, forceChildren);\n            let rightChange = false;\n            if (traverseRight) rightChange = _traverse(right, byteOffset, forceChildren);\n            const didChange = leftChange || rightChange;\n            if (didChange) for(let i = 0; i < 3; i++){\n                const lefti = left + i;\n                const righti = right + i;\n                const minLeftValue = float32Array[lefti];\n                const maxLeftValue = float32Array[lefti + 3];\n                const minRightValue = float32Array[righti];\n                const maxRightValue = float32Array[righti + 3];\n                float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n                float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n            return didChange;\n        }\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\nconst $c6fa00580fc66263$var$_boundingBox = /* @__PURE__ */ new (0, $e06gU.Box3)();\nfunction $c6fa00580fc66263$export$d5a069a08bb68982(nodeIndex32, array, ray, target) {\n    (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)(nodeIndex32, array, $c6fa00580fc66263$var$_boundingBox);\n    return ray.intersectBox($c6fa00580fc66263$var$_boundingBox, target);\n}\n\n\n\n\n\n\n/******************************************************/ /* This file is generated from \"raycast.template.js\". */ /******************************************************/ const $06f35bd135b4cbcc$var$_boxIntersection = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nfunction $06f35bd135b4cbcc$export$630e89aab3ddc1d6(bvh, root, side, ray, intersects) {\n    (0, $00672725876edc9e$export$7451c73ce907854f).setBuffer(bvh._roots[root]);\n    $06f35bd135b4cbcc$var$_raycast(0, bvh, side, ray, intersects);\n    (0, $00672725876edc9e$export$7451c73ce907854f).clearBuffer();\n}\nfunction $06f35bd135b4cbcc$var$_raycast(nodeIndex32, bvh, side, ray, intersects) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $00672725876edc9e$export$7451c73ce907854f);\n    const nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8c79b2483f36f80e$export$3231e969238304f3)(nodeIndex32, uint32Array);\n        const count = (0, $8c79b2483f36f80e$export$d61684373eacdf61)(nodeIndex16, uint16Array);\n        (0, $9474092dcc9c56eb$export$6f0a8fc5d2775a51)(bvh, side, ray, offset, count, intersects);\n    } else {\n        const leftIndex = (0, $8c79b2483f36f80e$export$7a68bc00425859d)(nodeIndex32);\n        if ((0, $c6fa00580fc66263$export$d5a069a08bb68982)(leftIndex, float32Array, ray, $06f35bd135b4cbcc$var$_boxIntersection)) $06f35bd135b4cbcc$var$_raycast(leftIndex, bvh, side, ray, intersects);\n        const rightIndex = (0, $8c79b2483f36f80e$export$4f44f52d9f75fa31)(nodeIndex32, uint32Array);\n        if ((0, $c6fa00580fc66263$export$d5a069a08bb68982)(rightIndex, float32Array, ray, $06f35bd135b4cbcc$var$_boxIntersection)) $06f35bd135b4cbcc$var$_raycast(rightIndex, bvh, side, ray, intersects);\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\n\n\n\n/***********************************************************/ /* This file is generated from \"raycastFirst.template.js\". */ /***********************************************************/ const $8094198f7e753a2d$var$_boxIntersection = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $8094198f7e753a2d$var$_xyzFields = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nfunction $8094198f7e753a2d$export$1fa457bc72ef1a2a(bvh, root, side, ray) {\n    (0, $00672725876edc9e$export$7451c73ce907854f).setBuffer(bvh._roots[root]);\n    const result = $8094198f7e753a2d$var$_raycastFirst(0, bvh, side, ray);\n    (0, $00672725876edc9e$export$7451c73ce907854f).clearBuffer();\n    return result;\n}\nfunction $8094198f7e753a2d$var$_raycastFirst(nodeIndex32, bvh, side, ray) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $00672725876edc9e$export$7451c73ce907854f);\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8c79b2483f36f80e$export$3231e969238304f3)(nodeIndex32, uint32Array);\n        const count = (0, $8c79b2483f36f80e$export$d61684373eacdf61)(nodeIndex16, uint16Array);\n        return (0, $9474092dcc9c56eb$export$4331f2604b0bca4)(bvh, side, ray, offset, count);\n    } else {\n        // consider the position of the split plane with respect to the oncoming ray; whichever direction\n        // the ray is coming from, look for an intersection among that side of the tree first\n        const splitAxis = (0, $8c79b2483f36f80e$export$b43717b3ca95505)(nodeIndex32, uint32Array);\n        const xyzAxis = $8094198f7e753a2d$var$_xyzFields[splitAxis];\n        const rayDir = ray.direction[xyzAxis];\n        const leftToRight = rayDir >= 0;\n        // c1 is the child to check first\n        let c1, c2;\n        if (leftToRight) {\n            c1 = (0, $8c79b2483f36f80e$export$7a68bc00425859d)(nodeIndex32);\n            c2 = (0, $8c79b2483f36f80e$export$4f44f52d9f75fa31)(nodeIndex32, uint32Array);\n        } else {\n            c1 = (0, $8c79b2483f36f80e$export$4f44f52d9f75fa31)(nodeIndex32, uint32Array);\n            c2 = (0, $8c79b2483f36f80e$export$7a68bc00425859d)(nodeIndex32);\n        }\n        const c1Intersection = (0, $c6fa00580fc66263$export$d5a069a08bb68982)(c1, float32Array, ray, $8094198f7e753a2d$var$_boxIntersection);\n        const c1Result = c1Intersection ? $8094198f7e753a2d$var$_raycastFirst(c1, bvh, side, ray) : null;\n        // if we got an intersection in the first node and it's closer than the second node's bounding\n        // box, we don't need to consider the second node because it couldn't possibly be a better result\n        if (c1Result) {\n            // check if the point is within the second bounds\n            // \"point\" is in the local frame of the bvh\n            const point = c1Result.point[xyzAxis];\n            const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n            if (isOutside) return c1Result;\n        }\n        // either there was no intersection in the first node, or there could still be a closer\n        // intersection in the second, so check the second node and then take the better of the two\n        const c2Intersection = (0, $c6fa00580fc66263$export$d5a069a08bb68982)(c2, float32Array, ray, $8094198f7e753a2d$var$_boxIntersection);\n        const c2Result = c2Intersection ? $8094198f7e753a2d$var$_raycastFirst(c2, bvh, side, ray) : null;\n        if (c1Result && c2Result) return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n        else return c1Result || c2Result || null;\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\n\n\n\n\n/*****************************************************************/ /* This file is generated from \"intersectsGeometry.template.js\". */ /*****************************************************************/ /* eslint-disable indent */ const $40028eca76a25282$var$boundingBox = /* @__PURE__ */ new (0, $e06gU.Box3)();\nconst $40028eca76a25282$var$triangle = /* @__PURE__ */ new (0, $277ed51eec8cb2f4$export$a37f7ec1c23dfacf)();\nconst $40028eca76a25282$var$triangle2 = /* @__PURE__ */ new (0, $277ed51eec8cb2f4$export$a37f7ec1c23dfacf)();\nconst $40028eca76a25282$var$invertedMat = /* @__PURE__ */ new (0, $e06gU.Matrix4)();\nconst $40028eca76a25282$var$obb = /* @__PURE__ */ new (0, $2210a8ccded54a38$export$4ccecd8ac6ee0e58)();\nconst $40028eca76a25282$var$obb2 = /* @__PURE__ */ new (0, $2210a8ccded54a38$export$4ccecd8ac6ee0e58)();\nfunction $40028eca76a25282$export$b2f96b0abaf94e0a(bvh, root, otherGeometry, geometryToBvh) {\n    (0, $00672725876edc9e$export$7451c73ce907854f).setBuffer(bvh._roots[root]);\n    const result = $40028eca76a25282$var$_intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n    (0, $00672725876edc9e$export$7451c73ce907854f).clearBuffer();\n    return result;\n}\nfunction $40028eca76a25282$var$_intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $00672725876edc9e$export$7451c73ce907854f);\n    let nodeIndex16 = nodeIndex32 * 2;\n    if (cachedObb === null) {\n        if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n        $40028eca76a25282$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n        cachedObb = $40028eca76a25282$var$obb;\n    }\n    const isLeaf = (0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const thisGeometry = bvh.geometry;\n        const thisIndex = thisGeometry.index;\n        const thisPos = thisGeometry.attributes.position;\n        const index = otherGeometry.index;\n        const pos = otherGeometry.attributes.position;\n        const offset = (0, $8c79b2483f36f80e$export$3231e969238304f3)(nodeIndex32, uint32Array);\n        const count = (0, $8c79b2483f36f80e$export$d61684373eacdf61)(nodeIndex16, uint16Array);\n        // get the inverse of the geometry matrix so we can transform our triangles into the\n        // geometry space we're trying to test. We assume there are fewer triangles being checked\n        // here.\n        $40028eca76a25282$var$invertedMat.copy(geometryToBvh).invert();\n        if (otherGeometry.boundsTree) {\n            // if there's a bounds tree\n            (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(nodeIndex32), float32Array, $40028eca76a25282$var$obb2);\n            $40028eca76a25282$var$obb2.matrix.copy($40028eca76a25282$var$invertedMat);\n            $40028eca76a25282$var$obb2.needsUpdate = true;\n            // TODO: use a triangle iteration function here\n            const res = otherGeometry.boundsTree.shapecast({\n                intersectsBounds: (box)=>$40028eca76a25282$var$obb2.intersectsBox(box),\n                intersectsTriangle: (tri)=>{\n                    tri.a.applyMatrix4(geometryToBvh);\n                    tri.b.applyMatrix4(geometryToBvh);\n                    tri.c.applyMatrix4(geometryToBvh);\n                    tri.needsUpdate = true;\n                    for(let i = offset * 3, l = (count + offset) * 3; i < l; i += 3){\n                        // this triangle needs to be transformed into the current BVH coordinate frame\n                        (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)($40028eca76a25282$var$triangle2, i, thisIndex, thisPos);\n                        $40028eca76a25282$var$triangle2.needsUpdate = true;\n                        if (tri.intersectsTriangle($40028eca76a25282$var$triangle2)) return true;\n                    }\n                    return false;\n                }\n            });\n            return res;\n        } else // if we're just dealing with raw geometry\n        for(let i = offset * 3, l = (count + offset) * 3; i < l; i += 3){\n            // this triangle needs to be transformed into the current BVH coordinate frame\n            (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)($40028eca76a25282$var$triangle, i, thisIndex, thisPos);\n            $40028eca76a25282$var$triangle.a.applyMatrix4($40028eca76a25282$var$invertedMat);\n            $40028eca76a25282$var$triangle.b.applyMatrix4($40028eca76a25282$var$invertedMat);\n            $40028eca76a25282$var$triangle.c.applyMatrix4($40028eca76a25282$var$invertedMat);\n            $40028eca76a25282$var$triangle.needsUpdate = true;\n            for(let i2 = 0, l2 = index.count; i2 < l2; i2 += 3){\n                (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)($40028eca76a25282$var$triangle2, i2, index, pos);\n                $40028eca76a25282$var$triangle2.needsUpdate = true;\n                if ($40028eca76a25282$var$triangle.intersectsTriangle($40028eca76a25282$var$triangle2)) return true;\n            }\n        }\n    } else {\n        const left = nodeIndex32 + 8;\n        const right = uint32Array[nodeIndex32 + 6];\n        (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(left), float32Array, $40028eca76a25282$var$boundingBox);\n        const leftIntersection = cachedObb.intersectsBox($40028eca76a25282$var$boundingBox) && $40028eca76a25282$var$_intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (leftIntersection) return true;\n        (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(right), float32Array, $40028eca76a25282$var$boundingBox);\n        const rightIntersection = cachedObb.intersectsBox($40028eca76a25282$var$boundingBox) && $40028eca76a25282$var$_intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (rightIntersection) return true;\n        return false;\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\n\n\n/*********************************************************************/ /* This file is generated from \"closestPointToGeometry.template.js\". */ /*********************************************************************/ const $c82df4aa752dbd95$var$tempMatrix = /* @__PURE__ */ new (0, $e06gU.Matrix4)();\nconst $c82df4aa752dbd95$var$obb = /* @__PURE__ */ new (0, $2210a8ccded54a38$export$4ccecd8ac6ee0e58)();\nconst $c82df4aa752dbd95$var$obb2 = /* @__PURE__ */ new (0, $2210a8ccded54a38$export$4ccecd8ac6ee0e58)();\nconst $c82df4aa752dbd95$var$temp1 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $c82df4aa752dbd95$var$temp2 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $c82df4aa752dbd95$var$temp3 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $c82df4aa752dbd95$var$temp4 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nfunction $c82df4aa752dbd95$export$5912902c175a555e(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n    $c82df4aa752dbd95$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    $c82df4aa752dbd95$var$obb.needsUpdate = true;\n    const geometry = bvh.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = (0, $a7a12bd8496afd7c$export$2622f4315304edad).getPrimitive();\n    const triangle2 = (0, $a7a12bd8496afd7c$export$2622f4315304edad).getPrimitive();\n    let tempTarget1 = $c82df4aa752dbd95$var$temp1;\n    let tempTargetDest1 = $c82df4aa752dbd95$var$temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n        tempTarget2 = $c82df4aa752dbd95$var$temp3;\n        tempTargetDest2 = $c82df4aa752dbd95$var$temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    $c82df4aa752dbd95$var$tempMatrix.copy(geometryToBvh).invert();\n    $c82df4aa752dbd95$var$obb2.matrix.copy($c82df4aa752dbd95$var$tempMatrix);\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            return $c82df4aa752dbd95$var$obb.distanceToBox(box);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            if (score < closestDistance && score < maxThreshold) {\n                // if we know the triangles of this bounds will be intersected next then\n                // save the bounds to use during triangle checks.\n                if (isLeaf) {\n                    $c82df4aa752dbd95$var$obb2.min.copy(box.min);\n                    $c82df4aa752dbd95$var$obb2.max.copy(box.max);\n                    $c82df4aa752dbd95$var$obb2.needsUpdate = true;\n                }\n                return true;\n            }\n            return false;\n        },\n        intersectsRange: (offset, count)=>{\n            if (otherGeometry.boundsTree) {\n                // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n                // the closest bounds in the other geometry to check.\n                const otherBvh = otherGeometry.boundsTree;\n                return otherBvh.shapecast({\n                    boundsTraverseOrder: (box)=>{\n                        return $c82df4aa752dbd95$var$obb2.distanceToBox(box);\n                    },\n                    intersectsBounds: (box, isLeaf, score)=>{\n                        return score < closestDistance && score < maxThreshold;\n                    },\n                    intersectsRange: (otherOffset, otherCount)=>{\n                        for(let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++){\n                            (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle2, 3 * i2, otherIndex, otherPos);\n                            triangle2.a.applyMatrix4(geometryToBvh);\n                            triangle2.b.applyMatrix4(geometryToBvh);\n                            triangle2.c.applyMatrix4(geometryToBvh);\n                            triangle2.needsUpdate = true;\n                            for(let i = offset, l = offset + count; i < l; i++){\n                                (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle, 3 * i, index, pos);\n                                triangle.needsUpdate = true;\n                                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                                if (dist < closestDistance) {\n                                    tempTargetDest1.copy(tempTarget1);\n                                    if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                                    closestDistance = dist;\n                                    closestDistanceTriIndex = i;\n                                    closestDistanceOtherTriIndex = i2;\n                                }\n                                // stop traversal if we find a point that's under the given threshold\n                                if (dist < minThreshold) return true;\n                            }\n                        }\n                    }\n                });\n            } else {\n                // If no bounds tree then we'll just check every triangle.\n                const triCount = (0, $512bf92b30757ce0$export$c56c51fae37b2d63)(otherGeometry);\n                for(let i2 = 0, l2 = triCount; i2 < l2; i2++){\n                    (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle2, 3 * i2, otherIndex, otherPos);\n                    triangle2.a.applyMatrix4(geometryToBvh);\n                    triangle2.b.applyMatrix4(geometryToBvh);\n                    triangle2.c.applyMatrix4(geometryToBvh);\n                    triangle2.needsUpdate = true;\n                    for(let i = offset, l = offset + count; i < l; i++){\n                        (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle, 3 * i, index, pos);\n                        triangle.needsUpdate = true;\n                        const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                        if (dist < closestDistance) {\n                            tempTargetDest1.copy(tempTarget1);\n                            if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                            closestDistance = dist;\n                            closestDistanceTriIndex = i;\n                            closestDistanceOtherTriIndex = i2;\n                        }\n                        // stop traversal if we find a point that's under the given threshold\n                        if (dist < minThreshold) return true;\n                    }\n                }\n            }\n        }\n    });\n    (0, $a7a12bd8496afd7c$export$2622f4315304edad).releasePrimitive(triangle);\n    (0, $a7a12bd8496afd7c$export$2622f4315304edad).releasePrimitive(triangle2);\n    if (closestDistance === Infinity) return null;\n    if (!target1.point) target1.point = tempTargetDest1.clone();\n    else target1.point.copy(tempTargetDest1);\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();\n        else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4($c82df4aa752dbd95$var$tempMatrix);\n        tempTargetDest1.applyMatrix4($c82df4aa752dbd95$var$tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\n/******************************************************/ /* This file is generated from \"bvhcast.template.js\". */ /******************************************************/ const $15ccf80f37db9874$var$tempMatrix = new (0, $e06gU.Matrix4)();\nconst $15ccf80f37db9874$var$aabb = /* @__PURE__ */ new (0, $e06gU.Box3)();\nconst $15ccf80f37db9874$var$aabb2 = /* @__PURE__ */ new (0, $e06gU.Box3)();\nfunction $15ccf80f37db9874$export$a2253c6980b92559(bvh, otherBvh, matrixToLocal, callbacks) {\n    // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n    // than an approach that walks down the tree (see bvhcast.js file for more info).\n    let { intersectsRanges: intersectsRanges, intersectsTriangles: intersectsTriangles } = callbacks;\n    const indexAttr = bvh.geometry.index;\n    const positionAttr = bvh.geometry.attributes.position;\n    const otherIndexAttr = otherBvh.geometry.index;\n    const otherPositionAttr = otherBvh.geometry.attributes.position;\n    $15ccf80f37db9874$var$tempMatrix.copy(matrixToLocal).invert();\n    const triangle = (0, $a7a12bd8496afd7c$export$2622f4315304edad).getPrimitive();\n    const triangle2 = (0, $a7a12bd8496afd7c$export$2622f4315304edad).getPrimitive();\n    if (intersectsTriangles) {\n        const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2)=>{\n            for(let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++){\n                (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);\n                triangle2.a.applyMatrix4(matrixToLocal);\n                triangle2.b.applyMatrix4(matrixToLocal);\n                triangle2.c.applyMatrix4(matrixToLocal);\n                triangle2.needsUpdate = true;\n                for(let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++){\n                    (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle, i1 * 3, indexAttr, positionAttr);\n                    triangle.needsUpdate = true;\n                    if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) return true;\n                }\n            }\n            return false;\n        };\n        if (intersectsRanges) {\n            const originalIntersectsRanges = intersectsRanges;\n            intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n                if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n                return true;\n            };\n        } else intersectsRanges = iterateOverDoubleTriangles;\n    }\n    otherBvh.getBoundingBox($15ccf80f37db9874$var$aabb2);\n    $15ccf80f37db9874$var$aabb2.applyMatrix4(matrixToLocal);\n    const result = bvh.shapecast({\n        intersectsBounds: (box)=>$15ccf80f37db9874$var$aabb2.intersectsBox(box),\n        intersectsRange: (offset1, count1, contained, depth1, nodeIndex1, box)=>{\n            $15ccf80f37db9874$var$aabb.copy(box);\n            $15ccf80f37db9874$var$aabb.applyMatrix4($15ccf80f37db9874$var$tempMatrix);\n            return otherBvh.shapecast({\n                intersectsBounds: (box)=>$15ccf80f37db9874$var$aabb.intersectsBox(box),\n                intersectsRange: (offset2, count2, contained, depth2, nodeIndex2)=>{\n                    return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n                }\n            });\n        }\n    });\n    (0, $a7a12bd8496afd7c$export$2622f4315304edad).releasePrimitive(triangle);\n    (0, $a7a12bd8496afd7c$export$2622f4315304edad).releasePrimitive(triangle2);\n    return result;\n}\n\n\n\n\n/*************************************************************/ /* This file is generated from \"iterationUtils.template.js\". */ /*************************************************************/ /* eslint-disable indent */ function $30624a994ba6e57c$export$7e7412b9f4f11a5c(bvh, side, ray, offset, count, intersections) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let vi = _indirectBuffer ? _indirectBuffer[i] : i;\n        (0, $7db34e138f2585de$export$1a557053019a130b)(geometry, side, ray, vi, intersections);\n    }\n}\nfunction $30624a994ba6e57c$export$dddff414156655a1(bvh, side, ray, offset, count) {\n    const { geometry: geometry, _indirectBuffer: _indirectBuffer } = bvh;\n    let dist = Infinity;\n    let res = null;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let intersection;\n        intersection = (0, $7db34e138f2585de$export$1a557053019a130b)(geometry, side, ray, _indirectBuffer ? _indirectBuffer[i] : i);\n        if (intersection && intersection.distance < dist) {\n            res = intersection;\n            dist = intersection.distance;\n        }\n    }\n    return res;\n}\nfunction $30624a994ba6e57c$export$dae1f8efdced590b(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle) {\n    const { geometry: geometry } = bvh;\n    const { index: index } = geometry;\n    const pos = geometry.attributes.position;\n    for(let i = offset, l = count + offset; i < l; i++){\n        let tri;\n        tri = bvh.resolveTriangleIndex(i);\n        (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle, tri * 3, index, pos);\n        triangle.needsUpdate = true;\n        if (intersectsTriangleFunc(triangle, tri, contained, depth)) return true;\n    }\n    return false;\n}\n\n\n\n/****************************************************/ /* This file is generated from \"refit.template.js\". */ /****************************************************/ function $f4d14018db659d90$export$40f4af49b81ca898(bvh, nodeIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) nodeIndices = new Set(nodeIndices);\n    const geometry = bvh.geometry;\n    const indexArr = geometry.index ? geometry.index.array : null;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = bvh._roots;\n    for(let i = 0, l = roots.length; i < l; i++){\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset, force = false) {\n        const node16Index = node32Index * 2;\n        const isLeaf = uint16Array[node16Index + 15] === (0, $bc798809290ffd6b$export$661fddb62bfe0e42);\n        if (isLeaf) {\n            const offset = uint32Array[node32Index + 6];\n            const count = uint16Array[node16Index + 14];\n            let minx = Infinity;\n            let miny = Infinity;\n            let minz = Infinity;\n            let maxx = -Infinity;\n            let maxy = -Infinity;\n            let maxz = -Infinity;\n            for(let i = offset, l = offset + count; i < l; i++){\n                const t = 3 * bvh.resolveTriangleIndex(i);\n                for(let j = 0; j < 3; j++){\n                    let index = t + j;\n                    index = indexArr ? indexArr[index] : index;\n                    const x = posAttr.getX(index);\n                    const y = posAttr.getY(index);\n                    const z = posAttr.getZ(index);\n                    if (x < minx) minx = x;\n                    if (x > maxx) maxx = x;\n                    if (y < miny) miny = y;\n                    if (y > maxy) maxy = y;\n                    if (z < minz) minz = z;\n                    if (z > maxz) maxz = z;\n                }\n            }\n            if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n                float32Array[node32Index + 0] = minx;\n                float32Array[node32Index + 1] = miny;\n                float32Array[node32Index + 2] = minz;\n                float32Array[node32Index + 3] = maxx;\n                float32Array[node32Index + 4] = maxy;\n                float32Array[node32Index + 5] = maxz;\n                return true;\n            } else return false;\n        } else {\n            const left = node32Index + 8;\n            const right = uint32Array[node32Index + 6];\n            // the identifying node indices provided by the shapecast function include offsets of all\n            // root buffers to guarantee they're unique between roots so offset left and right indices here.\n            const offsetLeft = left + byteOffset;\n            const offsetRight = right + byteOffset;\n            let forceChildren = force;\n            let includesLeft = false;\n            let includesRight = false;\n            if (nodeIndices) // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            {\n                if (!forceChildren) {\n                    includesLeft = nodeIndices.has(offsetLeft);\n                    includesRight = nodeIndices.has(offsetRight);\n                    forceChildren = !includesLeft && !includesRight;\n                }\n            } else {\n                includesLeft = true;\n                includesRight = true;\n            }\n            const traverseLeft = forceChildren || includesLeft;\n            const traverseRight = forceChildren || includesRight;\n            let leftChange = false;\n            if (traverseLeft) leftChange = _traverse(left, byteOffset, forceChildren);\n            let rightChange = false;\n            if (traverseRight) rightChange = _traverse(right, byteOffset, forceChildren);\n            const didChange = leftChange || rightChange;\n            if (didChange) for(let i = 0; i < 3; i++){\n                const lefti = left + i;\n                const righti = right + i;\n                const minLeftValue = float32Array[lefti];\n                const maxLeftValue = float32Array[lefti + 3];\n                const minRightValue = float32Array[righti];\n                const maxRightValue = float32Array[righti + 3];\n                float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n                float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n            return didChange;\n        }\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\n\n\n\n/******************************************************/ /* This file is generated from \"raycast.template.js\". */ /******************************************************/ const $c34151c023e22e2c$var$_boxIntersection = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nfunction $c34151c023e22e2c$export$1999205ebe856279(bvh, root, side, ray, intersects) {\n    (0, $00672725876edc9e$export$7451c73ce907854f).setBuffer(bvh._roots[root]);\n    $c34151c023e22e2c$var$_raycast(0, bvh, side, ray, intersects);\n    (0, $00672725876edc9e$export$7451c73ce907854f).clearBuffer();\n}\nfunction $c34151c023e22e2c$var$_raycast(nodeIndex32, bvh, side, ray, intersects) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $00672725876edc9e$export$7451c73ce907854f);\n    const nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8c79b2483f36f80e$export$3231e969238304f3)(nodeIndex32, uint32Array);\n        const count = (0, $8c79b2483f36f80e$export$d61684373eacdf61)(nodeIndex16, uint16Array);\n        (0, $30624a994ba6e57c$export$7e7412b9f4f11a5c)(bvh, side, ray, offset, count, intersects);\n    } else {\n        const leftIndex = (0, $8c79b2483f36f80e$export$7a68bc00425859d)(nodeIndex32);\n        if ((0, $c6fa00580fc66263$export$d5a069a08bb68982)(leftIndex, float32Array, ray, $c34151c023e22e2c$var$_boxIntersection)) $c34151c023e22e2c$var$_raycast(leftIndex, bvh, side, ray, intersects);\n        const rightIndex = (0, $8c79b2483f36f80e$export$4f44f52d9f75fa31)(nodeIndex32, uint32Array);\n        if ((0, $c6fa00580fc66263$export$d5a069a08bb68982)(rightIndex, float32Array, ray, $c34151c023e22e2c$var$_boxIntersection)) $c34151c023e22e2c$var$_raycast(rightIndex, bvh, side, ray, intersects);\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\n\n\n\n/***********************************************************/ /* This file is generated from \"raycastFirst.template.js\". */ /***********************************************************/ const $c27191358c129b43$var$_boxIntersection = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $c27191358c129b43$var$_xyzFields = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nfunction $c27191358c129b43$export$44e48d4cf2fe0609(bvh, root, side, ray) {\n    (0, $00672725876edc9e$export$7451c73ce907854f).setBuffer(bvh._roots[root]);\n    const result = $c27191358c129b43$var$_raycastFirst(0, bvh, side, ray);\n    (0, $00672725876edc9e$export$7451c73ce907854f).clearBuffer();\n    return result;\n}\nfunction $c27191358c129b43$var$_raycastFirst(nodeIndex32, bvh, side, ray) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $00672725876edc9e$export$7451c73ce907854f);\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0, $8c79b2483f36f80e$export$3231e969238304f3)(nodeIndex32, uint32Array);\n        const count = (0, $8c79b2483f36f80e$export$d61684373eacdf61)(nodeIndex16, uint16Array);\n        return (0, $30624a994ba6e57c$export$dddff414156655a1)(bvh, side, ray, offset, count);\n    } else {\n        // consider the position of the split plane with respect to the oncoming ray; whichever direction\n        // the ray is coming from, look for an intersection among that side of the tree first\n        const splitAxis = (0, $8c79b2483f36f80e$export$b43717b3ca95505)(nodeIndex32, uint32Array);\n        const xyzAxis = $c27191358c129b43$var$_xyzFields[splitAxis];\n        const rayDir = ray.direction[xyzAxis];\n        const leftToRight = rayDir >= 0;\n        // c1 is the child to check first\n        let c1, c2;\n        if (leftToRight) {\n            c1 = (0, $8c79b2483f36f80e$export$7a68bc00425859d)(nodeIndex32);\n            c2 = (0, $8c79b2483f36f80e$export$4f44f52d9f75fa31)(nodeIndex32, uint32Array);\n        } else {\n            c1 = (0, $8c79b2483f36f80e$export$4f44f52d9f75fa31)(nodeIndex32, uint32Array);\n            c2 = (0, $8c79b2483f36f80e$export$7a68bc00425859d)(nodeIndex32);\n        }\n        const c1Intersection = (0, $c6fa00580fc66263$export$d5a069a08bb68982)(c1, float32Array, ray, $c27191358c129b43$var$_boxIntersection);\n        const c1Result = c1Intersection ? $c27191358c129b43$var$_raycastFirst(c1, bvh, side, ray) : null;\n        // if we got an intersection in the first node and it's closer than the second node's bounding\n        // box, we don't need to consider the second node because it couldn't possibly be a better result\n        if (c1Result) {\n            // check if the point is within the second bounds\n            // \"point\" is in the local frame of the bvh\n            const point = c1Result.point[xyzAxis];\n            const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n            if (isOutside) return c1Result;\n        }\n        // either there was no intersection in the first node, or there could still be a closer\n        // intersection in the second, so check the second node and then take the better of the two\n        const c2Intersection = (0, $c6fa00580fc66263$export$d5a069a08bb68982)(c2, float32Array, ray, $c27191358c129b43$var$_boxIntersection);\n        const c2Result = c2Intersection ? $c27191358c129b43$var$_raycastFirst(c2, bvh, side, ray) : null;\n        if (c1Result && c2Result) return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n        else return c1Result || c2Result || null;\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\n\n\n\n\n/*****************************************************************/ /* This file is generated from \"intersectsGeometry.template.js\". */ /*****************************************************************/ /* eslint-disable indent */ const $e7beda6ce58ad8bf$var$boundingBox = /* @__PURE__ */ new (0, $e06gU.Box3)();\nconst $e7beda6ce58ad8bf$var$triangle = /* @__PURE__ */ new (0, $277ed51eec8cb2f4$export$a37f7ec1c23dfacf)();\nconst $e7beda6ce58ad8bf$var$triangle2 = /* @__PURE__ */ new (0, $277ed51eec8cb2f4$export$a37f7ec1c23dfacf)();\nconst $e7beda6ce58ad8bf$var$invertedMat = /* @__PURE__ */ new (0, $e06gU.Matrix4)();\nconst $e7beda6ce58ad8bf$var$obb = /* @__PURE__ */ new (0, $2210a8ccded54a38$export$4ccecd8ac6ee0e58)();\nconst $e7beda6ce58ad8bf$var$obb2 = /* @__PURE__ */ new (0, $2210a8ccded54a38$export$4ccecd8ac6ee0e58)();\nfunction $e7beda6ce58ad8bf$export$80dca0df80ee0084(bvh, root, otherGeometry, geometryToBvh) {\n    (0, $00672725876edc9e$export$7451c73ce907854f).setBuffer(bvh._roots[root]);\n    const result = $e7beda6ce58ad8bf$var$_intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n    (0, $00672725876edc9e$export$7451c73ce907854f).clearBuffer();\n    return result;\n}\nfunction $e7beda6ce58ad8bf$var$_intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {\n    const { float32Array: float32Array, uint16Array: uint16Array, uint32Array: uint32Array } = (0, $00672725876edc9e$export$7451c73ce907854f);\n    let nodeIndex16 = nodeIndex32 * 2;\n    if (cachedObb === null) {\n        if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n        $e7beda6ce58ad8bf$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n        cachedObb = $e7beda6ce58ad8bf$var$obb;\n    }\n    const isLeaf = (0, $8c79b2483f36f80e$export$bc7cbaf27fbe938e)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const thisGeometry = bvh.geometry;\n        const thisIndex = thisGeometry.index;\n        const thisPos = thisGeometry.attributes.position;\n        const index = otherGeometry.index;\n        const pos = otherGeometry.attributes.position;\n        const offset = (0, $8c79b2483f36f80e$export$3231e969238304f3)(nodeIndex32, uint32Array);\n        const count = (0, $8c79b2483f36f80e$export$d61684373eacdf61)(nodeIndex16, uint16Array);\n        // get the inverse of the geometry matrix so we can transform our triangles into the\n        // geometry space we're trying to test. We assume there are fewer triangles being checked\n        // here.\n        $e7beda6ce58ad8bf$var$invertedMat.copy(geometryToBvh).invert();\n        if (otherGeometry.boundsTree) {\n            // if there's a bounds tree\n            (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(nodeIndex32), float32Array, $e7beda6ce58ad8bf$var$obb2);\n            $e7beda6ce58ad8bf$var$obb2.matrix.copy($e7beda6ce58ad8bf$var$invertedMat);\n            $e7beda6ce58ad8bf$var$obb2.needsUpdate = true;\n            // TODO: use a triangle iteration function here\n            const res = otherGeometry.boundsTree.shapecast({\n                intersectsBounds: (box)=>$e7beda6ce58ad8bf$var$obb2.intersectsBox(box),\n                intersectsTriangle: (tri)=>{\n                    tri.a.applyMatrix4(geometryToBvh);\n                    tri.b.applyMatrix4(geometryToBvh);\n                    tri.c.applyMatrix4(geometryToBvh);\n                    tri.needsUpdate = true;\n                    for(let i = offset, l = count + offset; i < l; i++){\n                        // this triangle needs to be transformed into the current BVH coordinate frame\n                        (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)($e7beda6ce58ad8bf$var$triangle2, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);\n                        $e7beda6ce58ad8bf$var$triangle2.needsUpdate = true;\n                        if (tri.intersectsTriangle($e7beda6ce58ad8bf$var$triangle2)) return true;\n                    }\n                    return false;\n                }\n            });\n            return res;\n        } else // if we're just dealing with raw geometry\n        for(let i = offset, l = count + offset; i < l; i++){\n            // this triangle needs to be transformed into the current BVH coordinate frame\n            const ti = bvh.resolveTriangleIndex(i);\n            (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)($e7beda6ce58ad8bf$var$triangle, 3 * ti, thisIndex, thisPos);\n            $e7beda6ce58ad8bf$var$triangle.a.applyMatrix4($e7beda6ce58ad8bf$var$invertedMat);\n            $e7beda6ce58ad8bf$var$triangle.b.applyMatrix4($e7beda6ce58ad8bf$var$invertedMat);\n            $e7beda6ce58ad8bf$var$triangle.c.applyMatrix4($e7beda6ce58ad8bf$var$invertedMat);\n            $e7beda6ce58ad8bf$var$triangle.needsUpdate = true;\n            for(let i2 = 0, l2 = index.count; i2 < l2; i2 += 3){\n                (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)($e7beda6ce58ad8bf$var$triangle2, i2, index, pos);\n                $e7beda6ce58ad8bf$var$triangle2.needsUpdate = true;\n                if ($e7beda6ce58ad8bf$var$triangle.intersectsTriangle($e7beda6ce58ad8bf$var$triangle2)) return true;\n            }\n        }\n    } else {\n        const left = nodeIndex32 + 8;\n        const right = uint32Array[nodeIndex32 + 6];\n        (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(left), float32Array, $e7beda6ce58ad8bf$var$boundingBox);\n        const leftIntersection = cachedObb.intersectsBox($e7beda6ce58ad8bf$var$boundingBox) && $e7beda6ce58ad8bf$var$_intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (leftIntersection) return true;\n        (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)((0, $8c79b2483f36f80e$export$b5b7e27a1440579d)(right), float32Array, $e7beda6ce58ad8bf$var$boundingBox);\n        const rightIntersection = cachedObb.intersectsBox($e7beda6ce58ad8bf$var$boundingBox) && $e7beda6ce58ad8bf$var$_intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (rightIntersection) return true;\n        return false;\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\n\n\n/*********************************************************************/ /* This file is generated from \"closestPointToGeometry.template.js\". */ /*********************************************************************/ const $525a48157a09a04c$var$tempMatrix = /* @__PURE__ */ new (0, $e06gU.Matrix4)();\nconst $525a48157a09a04c$var$obb = /* @__PURE__ */ new (0, $2210a8ccded54a38$export$4ccecd8ac6ee0e58)();\nconst $525a48157a09a04c$var$obb2 = /* @__PURE__ */ new (0, $2210a8ccded54a38$export$4ccecd8ac6ee0e58)();\nconst $525a48157a09a04c$var$temp1 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $525a48157a09a04c$var$temp2 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $525a48157a09a04c$var$temp3 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $525a48157a09a04c$var$temp4 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nfunction $525a48157a09a04c$export$334b669407b5ec06(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) otherGeometry.computeBoundingBox();\n    $525a48157a09a04c$var$obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    $525a48157a09a04c$var$obb.needsUpdate = true;\n    const geometry = bvh.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = (0, $a7a12bd8496afd7c$export$2622f4315304edad).getPrimitive();\n    const triangle2 = (0, $a7a12bd8496afd7c$export$2622f4315304edad).getPrimitive();\n    let tempTarget1 = $525a48157a09a04c$var$temp1;\n    let tempTargetDest1 = $525a48157a09a04c$var$temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n        tempTarget2 = $525a48157a09a04c$var$temp3;\n        tempTargetDest2 = $525a48157a09a04c$var$temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    $525a48157a09a04c$var$tempMatrix.copy(geometryToBvh).invert();\n    $525a48157a09a04c$var$obb2.matrix.copy($525a48157a09a04c$var$tempMatrix);\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            return $525a48157a09a04c$var$obb.distanceToBox(box);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            if (score < closestDistance && score < maxThreshold) {\n                // if we know the triangles of this bounds will be intersected next then\n                // save the bounds to use during triangle checks.\n                if (isLeaf) {\n                    $525a48157a09a04c$var$obb2.min.copy(box.min);\n                    $525a48157a09a04c$var$obb2.max.copy(box.max);\n                    $525a48157a09a04c$var$obb2.needsUpdate = true;\n                }\n                return true;\n            }\n            return false;\n        },\n        intersectsRange: (offset, count)=>{\n            if (otherGeometry.boundsTree) {\n                // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n                // the closest bounds in the other geometry to check.\n                const otherBvh = otherGeometry.boundsTree;\n                return otherBvh.shapecast({\n                    boundsTraverseOrder: (box)=>{\n                        return $525a48157a09a04c$var$obb2.distanceToBox(box);\n                    },\n                    intersectsBounds: (box, isLeaf, score)=>{\n                        return score < closestDistance && score < maxThreshold;\n                    },\n                    intersectsRange: (otherOffset, otherCount)=>{\n                        for(let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++){\n                            const ti2 = otherBvh.resolveTriangleIndex(i2);\n                            (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle2, 3 * ti2, otherIndex, otherPos);\n                            triangle2.a.applyMatrix4(geometryToBvh);\n                            triangle2.b.applyMatrix4(geometryToBvh);\n                            triangle2.c.applyMatrix4(geometryToBvh);\n                            triangle2.needsUpdate = true;\n                            for(let i = offset, l = offset + count; i < l; i++){\n                                const ti = bvh.resolveTriangleIndex(i);\n                                (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle, 3 * ti, index, pos);\n                                triangle.needsUpdate = true;\n                                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                                if (dist < closestDistance) {\n                                    tempTargetDest1.copy(tempTarget1);\n                                    if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                                    closestDistance = dist;\n                                    closestDistanceTriIndex = i;\n                                    closestDistanceOtherTriIndex = i2;\n                                }\n                                // stop traversal if we find a point that's under the given threshold\n                                if (dist < minThreshold) return true;\n                            }\n                        }\n                    }\n                });\n            } else {\n                // If no bounds tree then we'll just check every triangle.\n                const triCount = (0, $512bf92b30757ce0$export$c56c51fae37b2d63)(otherGeometry);\n                for(let i2 = 0, l2 = triCount; i2 < l2; i2++){\n                    (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle2, 3 * i2, otherIndex, otherPos);\n                    triangle2.a.applyMatrix4(geometryToBvh);\n                    triangle2.b.applyMatrix4(geometryToBvh);\n                    triangle2.c.applyMatrix4(geometryToBvh);\n                    triangle2.needsUpdate = true;\n                    for(let i = offset, l = offset + count; i < l; i++){\n                        const ti = bvh.resolveTriangleIndex(i);\n                        (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle, 3 * ti, index, pos);\n                        triangle.needsUpdate = true;\n                        const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                        if (dist < closestDistance) {\n                            tempTargetDest1.copy(tempTarget1);\n                            if (tempTargetDest2) tempTargetDest2.copy(tempTarget2);\n                            closestDistance = dist;\n                            closestDistanceTriIndex = i;\n                            closestDistanceOtherTriIndex = i2;\n                        }\n                        // stop traversal if we find a point that's under the given threshold\n                        if (dist < minThreshold) return true;\n                    }\n                }\n            }\n        }\n    });\n    (0, $a7a12bd8496afd7c$export$2622f4315304edad).releasePrimitive(triangle);\n    (0, $a7a12bd8496afd7c$export$2622f4315304edad).releasePrimitive(triangle2);\n    if (closestDistance === Infinity) return null;\n    if (!target1.point) target1.point = tempTargetDest1.clone();\n    else target1.point.copy(tempTargetDest1);\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();\n        else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4($525a48157a09a04c$var$tempMatrix);\n        tempTargetDest1.applyMatrix4($525a48157a09a04c$var$tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\n/******************************************************/ /* This file is generated from \"bvhcast.template.js\". */ /******************************************************/ const $0cb92652a15353e8$var$tempMatrix = new (0, $e06gU.Matrix4)();\nconst $0cb92652a15353e8$var$aabb = /* @__PURE__ */ new (0, $e06gU.Box3)();\nconst $0cb92652a15353e8$var$aabb2 = /* @__PURE__ */ new (0, $e06gU.Box3)();\nfunction $0cb92652a15353e8$export$4e2970292710be2c(bvh, otherBvh, matrixToLocal, callbacks) {\n    // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n    // than an approach that walks down the tree (see bvhcast.js file for more info).\n    let { intersectsRanges: intersectsRanges, intersectsTriangles: intersectsTriangles } = callbacks;\n    const indexAttr = bvh.geometry.index;\n    const positionAttr = bvh.geometry.attributes.position;\n    const otherIndexAttr = otherBvh.geometry.index;\n    const otherPositionAttr = otherBvh.geometry.attributes.position;\n    $0cb92652a15353e8$var$tempMatrix.copy(matrixToLocal).invert();\n    const triangle = (0, $a7a12bd8496afd7c$export$2622f4315304edad).getPrimitive();\n    const triangle2 = (0, $a7a12bd8496afd7c$export$2622f4315304edad).getPrimitive();\n    if (intersectsTriangles) {\n        const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2)=>{\n            for(let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++){\n                const ti2 = otherBvh.resolveTriangleIndex(i2);\n                (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle2, ti2 * 3, otherIndexAttr, otherPositionAttr);\n                triangle2.a.applyMatrix4(matrixToLocal);\n                triangle2.b.applyMatrix4(matrixToLocal);\n                triangle2.c.applyMatrix4(matrixToLocal);\n                triangle2.needsUpdate = true;\n                for(let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++){\n                    const ti1 = bvh.resolveTriangleIndex(i1);\n                    (0, $eb6f5960b3eb8549$export$32f7fa781964ae30)(triangle, ti1 * 3, indexAttr, positionAttr);\n                    triangle.needsUpdate = true;\n                    if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) return true;\n                }\n            }\n            return false;\n        };\n        if (intersectsRanges) {\n            const originalIntersectsRanges = intersectsRanges;\n            intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n                if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n                return true;\n            };\n        } else intersectsRanges = iterateOverDoubleTriangles;\n    }\n    otherBvh.getBoundingBox($0cb92652a15353e8$var$aabb2);\n    $0cb92652a15353e8$var$aabb2.applyMatrix4(matrixToLocal);\n    const result = bvh.shapecast({\n        intersectsBounds: (box)=>$0cb92652a15353e8$var$aabb2.intersectsBox(box),\n        intersectsRange: (offset1, count1, contained, depth1, nodeIndex1, box)=>{\n            $0cb92652a15353e8$var$aabb.copy(box);\n            $0cb92652a15353e8$var$aabb.applyMatrix4($0cb92652a15353e8$var$tempMatrix);\n            return otherBvh.shapecast({\n                intersectsBounds: (box)=>$0cb92652a15353e8$var$aabb.intersectsBox(box),\n                intersectsRange: (offset2, count2, contained, depth2, nodeIndex2)=>{\n                    return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n                }\n            });\n        }\n    });\n    (0, $a7a12bd8496afd7c$export$2622f4315304edad).releasePrimitive(triangle);\n    (0, $a7a12bd8496afd7c$export$2622f4315304edad).releasePrimitive(triangle2);\n    return result;\n}\n\n\nfunction $38253ed0649349ad$export$9c28fa8114adc339() {\n    return typeof SharedArrayBuffer !== \"undefined\";\n}\n\n\nconst $d1f63a316b8768c2$var$obb = /* @__PURE__ */ new (0, $2210a8ccded54a38$export$4ccecd8ac6ee0e58)();\nconst $d1f63a316b8768c2$var$tempBox = /* @__PURE__ */ new (0, $e06gU.Box3)();\nclass $d1f63a316b8768c2$export$9d614b3bc2c4eacf {\n    static serialize(bvh, options = {}) {\n        options = {\n            cloneBuffers: true,\n            ...options\n        };\n        const geometry = bvh.geometry;\n        const rootData = bvh._roots;\n        const indirectBuffer = bvh._indirectBuffer;\n        const indexAttribute = geometry.getIndex();\n        let result;\n        if (options.cloneBuffers) result = {\n            roots: rootData.map((root)=>root.slice()),\n            index: indexAttribute.array.slice(),\n            indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null\n        };\n        else result = {\n            roots: rootData,\n            index: indexAttribute.array,\n            indirectBuffer: indirectBuffer\n        };\n        return result;\n    }\n    static deserialize(data, geometry, options = {}) {\n        options = {\n            setIndex: true,\n            indirect: Boolean(data.indirectBuffer),\n            ...options\n        };\n        const { index: index, roots: roots, indirectBuffer: indirectBuffer } = data;\n        const bvh = new $d1f63a316b8768c2$export$9d614b3bc2c4eacf(geometry, {\n            ...options,\n            [(0, $bc798809290ffd6b$export$abef70518a11a6ba)]: true\n        });\n        bvh._roots = roots;\n        bvh._indirectBuffer = indirectBuffer || null;\n        if (options.setIndex) {\n            const indexAttribute = geometry.getIndex();\n            if (indexAttribute === null) {\n                const newIndex = new (0, $e06gU.BufferAttribute)(data.index, 1, false);\n                geometry.setIndex(newIndex);\n            } else if (indexAttribute.array !== index) {\n                indexAttribute.array.set(index);\n                indexAttribute.needsUpdate = true;\n            }\n        }\n        return bvh;\n    }\n    get indirect() {\n        return !!this._indirectBuffer;\n    }\n    constructor(geometry, options = {}){\n        if (!geometry.isBufferGeometry) throw new Error(\"MeshBVH: Only BufferGeometries are supported.\");\n        else if (geometry.index && geometry.index.isInterleavedBufferAttribute) throw new Error(\"MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.\");\n        // default options\n        options = Object.assign({\n            strategy: (0, $bc798809290ffd6b$export$91c2158bc24c63d4),\n            maxDepth: 40,\n            maxLeafTris: 10,\n            verbose: true,\n            useSharedArrayBuffer: false,\n            setBoundingBox: true,\n            onProgress: null,\n            indirect: false,\n            // undocumented options\n            // Whether to skip generating the tree. Used for deserialization.\n            [(0, $bc798809290ffd6b$export$abef70518a11a6ba)]: false\n        }, options);\n        if (options.useSharedArrayBuffer && !(0, $38253ed0649349ad$export$9c28fa8114adc339)()) throw new Error(\"MeshBVH: SharedArrayBuffer is not available.\");\n        // retain references to the geometry so we can use them it without having to\n        // take a geometry reference in every function.\n        this.geometry = geometry;\n        this._roots = null;\n        this._indirectBuffer = null;\n        if (!options[0, $bc798809290ffd6b$export$abef70518a11a6ba]) {\n            (0, $1b5942106133d63e$export$e63bca57f220b8e3)(this, options);\n            if (!geometry.boundingBox && options.setBoundingBox) geometry.boundingBox = this.getBoundingBox(new (0, $e06gU.Box3)());\n        }\n        const { _indirectBuffer: _indirectBuffer } = this;\n        this.resolveTriangleIndex = options.indirect ? (i)=>_indirectBuffer[i] : (i)=>i;\n    }\n    refit(nodeIndices = null) {\n        const refitFunc = this.indirect ? (0, $f4d14018db659d90$export$40f4af49b81ca898) : (0, $d6886d66b20a1b65$export$8eb1eda96b2e6d7a);\n        return refitFunc(this, nodeIndices);\n    }\n    traverse(callback, rootIndex = 0) {\n        const buffer = this._roots[rootIndex];\n        const uint32Array = new Uint32Array(buffer);\n        const uint16Array = new Uint16Array(buffer);\n        _traverse(0);\n        function _traverse(node32Index, depth = 0) {\n            const node16Index = node32Index * 2;\n            const isLeaf = uint16Array[node16Index + 15] === (0, $bc798809290ffd6b$export$661fddb62bfe0e42);\n            if (isLeaf) {\n                const offset = uint32Array[node32Index + 6];\n                const count = uint16Array[node16Index + 14];\n                callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n            } else {\n                // TODO: use node functions here\n                const left = node32Index + (0, $bc798809290ffd6b$export$a08e7d18fbc53be5) / 4;\n                const right = uint32Array[node32Index + 6];\n                const splitAxis = uint32Array[node32Index + 7];\n                const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n                if (!stopTraversal) {\n                    _traverse(left, depth + 1);\n                    _traverse(right, depth + 1);\n                }\n            }\n        }\n    }\n    /* Core Cast Functions */ raycast(ray, materialOrSide = (0, $e06gU.FrontSide)) {\n        const roots = this._roots;\n        const geometry = this.geometry;\n        const intersects = [];\n        const isMaterial = materialOrSide.isMaterial;\n        const isArrayMaterial = Array.isArray(materialOrSide);\n        const groups = geometry.groups;\n        const side = isMaterial ? materialOrSide.side : materialOrSide;\n        const raycastFunc = this.indirect ? (0, $c34151c023e22e2c$export$1999205ebe856279) : (0, $06f35bd135b4cbcc$export$630e89aab3ddc1d6);\n        for(let i = 0, l = roots.length; i < l; i++){\n            const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n            const startCount = intersects.length;\n            raycastFunc(this, i, materialSide, ray, intersects);\n            if (isArrayMaterial) {\n                const materialIndex = groups[i].materialIndex;\n                for(let j = startCount, jl = intersects.length; j < jl; j++)intersects[j].face.materialIndex = materialIndex;\n            }\n        }\n        return intersects;\n    }\n    raycastFirst(ray, materialOrSide = (0, $e06gU.FrontSide)) {\n        const roots = this._roots;\n        const geometry = this.geometry;\n        const isMaterial = materialOrSide.isMaterial;\n        const isArrayMaterial = Array.isArray(materialOrSide);\n        let closestResult = null;\n        const groups = geometry.groups;\n        const side = isMaterial ? materialOrSide.side : materialOrSide;\n        const raycastFirstFunc = this.indirect ? (0, $c27191358c129b43$export$44e48d4cf2fe0609) : (0, $8094198f7e753a2d$export$1fa457bc72ef1a2a);\n        for(let i = 0, l = roots.length; i < l; i++){\n            const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n            const result = raycastFirstFunc(this, i, materialSide, ray);\n            if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n                closestResult = result;\n                if (isArrayMaterial) result.face.materialIndex = groups[i].materialIndex;\n            }\n        }\n        return closestResult;\n    }\n    intersectsGeometry(otherGeometry, geomToMesh) {\n        let result = false;\n        const roots = this._roots;\n        const intersectsGeometryFunc = this.indirect ? (0, $e7beda6ce58ad8bf$export$80dca0df80ee0084) : (0, $40028eca76a25282$export$b2f96b0abaf94e0a);\n        for(let i = 0, l = roots.length; i < l; i++){\n            result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);\n            if (result) break;\n        }\n        return result;\n    }\n    shapecast(callbacks) {\n        const triangle = (0, $a7a12bd8496afd7c$export$2622f4315304edad).getPrimitive();\n        const iterateFunc = this.indirect ? (0, $30624a994ba6e57c$export$dae1f8efdced590b) : (0, $9474092dcc9c56eb$export$be1391b7aa79c0f6);\n        let { boundsTraverseOrder: boundsTraverseOrder, intersectsBounds: intersectsBounds, intersectsRange: intersectsRange, intersectsTriangle: intersectsTriangle } = callbacks;\n        // wrap the intersectsRange function\n        if (intersectsRange && intersectsTriangle) {\n            const originalIntersectsRange = intersectsRange;\n            intersectsRange = (offset, count, contained, depth, nodeIndex)=>{\n                if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n                return true;\n            };\n        } else if (!intersectsRange) {\n            if (intersectsTriangle) intersectsRange = (offset, count, contained, depth)=>{\n                return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n            };\n            else intersectsRange = (offset, count, contained)=>{\n                return contained;\n            };\n        }\n        // run shapecast\n        let result = false;\n        let byteOffset = 0;\n        const roots = this._roots;\n        for(let i = 0, l = roots.length; i < l; i++){\n            const root = roots[i];\n            result = (0, $59a851f097f5ef7e$export$963c78622ed2c172)(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n            if (result) break;\n            byteOffset += root.byteLength;\n        }\n        (0, $a7a12bd8496afd7c$export$2622f4315304edad).releasePrimitive(triangle);\n        return result;\n    }\n    bvhcast(otherBvh, matrixToLocal, callbacks) {\n        const bvhcastFunc = this.indirect ? (0, $0cb92652a15353e8$export$4e2970292710be2c) : (0, $15ccf80f37db9874$export$a2253c6980b92559);\n        return bvhcastFunc(this, otherBvh, matrixToLocal, callbacks);\n    }\n    /* Derived Cast Functions */ intersectsBox(box, boxToMesh) {\n        $d1f63a316b8768c2$var$obb.set(box.min, box.max, boxToMesh);\n        $d1f63a316b8768c2$var$obb.needsUpdate = true;\n        return this.shapecast({\n            intersectsBounds: (box)=>$d1f63a316b8768c2$var$obb.intersectsBox(box),\n            intersectsTriangle: (tri)=>$d1f63a316b8768c2$var$obb.intersectsTriangle(tri)\n        });\n    }\n    intersectsSphere(sphere) {\n        return this.shapecast({\n            intersectsBounds: (box)=>sphere.intersectsBox(box),\n            intersectsTriangle: (tri)=>tri.intersectsSphere(sphere)\n        });\n    }\n    closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n        const closestPointToGeometryFunc = this.indirect ? (0, $525a48157a09a04c$export$334b669407b5ec06) : (0, $c82df4aa752dbd95$export$5912902c175a555e);\n        return closestPointToGeometryFunc(this, otherGeometry, geometryToBvh, target1, target2, minThreshold, maxThreshold);\n    }\n    closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n        return (0, $452345387fe1f65a$export$96ec44700e587d99)(this, point, target, minThreshold, maxThreshold);\n    }\n    getBoundingBox(target) {\n        target.makeEmpty();\n        const roots = this._roots;\n        roots.forEach((buffer)=>{\n            (0, $d5323e54f8bf740a$export$40b9a5e446bf11e0)(0, new Float32Array(buffer), $d1f63a316b8768c2$var$tempBox);\n            target.union($d1f63a316b8768c2$var$tempBox);\n        });\n        return target;\n    }\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\nconst $3e2a3abaa10886a8$var$EPSILON = 1e-16;\nconst $3e2a3abaa10886a8$var$UP_VECTOR = /* @__PURE__ */ new (0, $e06gU.Vector3)(0, 1, 0);\nconst $3e2a3abaa10886a8$var$_dir = new (0, $e06gU.Vector3)();\nfunction $3e2a3abaa10886a8$export$cec4aea73fa71fc5(line) {\n    line.delta($3e2a3abaa10886a8$var$_dir).normalize();\n    return Math.abs($3e2a3abaa10886a8$var$_dir.dot($3e2a3abaa10886a8$var$UP_VECTOR)) >= 1.0 - $3e2a3abaa10886a8$var$EPSILON;\n}\nfunction $3e2a3abaa10886a8$export$97cada60b6f00a63(tri) {\n    if (tri.needsUpdate) tri.update();\n    return Math.abs(tri.plane.normal.dot($3e2a3abaa10886a8$var$UP_VECTOR)) <= $3e2a3abaa10886a8$var$EPSILON;\n}\nfunction $3e2a3abaa10886a8$export$6ce1ecae0cd1cc55(tri, line) {\n    // if this is the same line as on the triangle\n    const { start: start, end: end } = line;\n    const triPoints = tri.points;\n    let startMatches = false;\n    let endMatches = false;\n    for(let i = 0; i < 3; i++){\n        const tp = triPoints[i];\n        if (!startMatches && start.distanceToSquared(tp) <= $3e2a3abaa10886a8$var$EPSILON) startMatches = true;\n        if (!endMatches && end.distanceToSquared(tp) <= $3e2a3abaa10886a8$var$EPSILON) endMatches = true;\n        if (startMatches && endMatches) return true;\n    }\n    return startMatches && endMatches;\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n// Modified version of js EdgesGeometry logic to handle silhouette edges\nconst $2cd02d3dec669c62$var$EPSILON = 1e-16;\nconst $2cd02d3dec669c62$var$UP_VECTOR = /* @__PURE__ */ new (0, $e06gU.Vector3)(0, 1, 0);\nconst $2cd02d3dec669c62$var$_v0 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $2cd02d3dec669c62$var$_v1 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $2cd02d3dec669c62$var$_normal = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $2cd02d3dec669c62$var$_triangle = /* @__PURE__ */ new (0, $e06gU.Triangle)();\nfunction $2cd02d3dec669c62$export$b2d7c053833d1662(geometry, projectionDir = $2cd02d3dec669c62$var$UP_VECTOR, thresholdAngle = 1) {\n    const edges = [];\n    const precisionPoints = 4;\n    const precision = Math.pow(10, precisionPoints);\n    const thresholdDot = Math.cos((0, $e06gU.MathUtils).DEG2RAD * thresholdAngle);\n    const indexAttr = geometry.getIndex();\n    const positionAttr = geometry.getAttribute(\"position\");\n    const indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n    const indexArr = [\n        0,\n        0,\n        0\n    ];\n    const vertKeys = [\n        \"a\",\n        \"b\",\n        \"c\"\n    ];\n    const hashes = new Array(3);\n    const edgeData = {};\n    for(let i = 0; i < indexCount; i += 3){\n        if (indexAttr) {\n            indexArr[0] = indexAttr.getX(i);\n            indexArr[1] = indexAttr.getX(i + 1);\n            indexArr[2] = indexAttr.getX(i + 2);\n        } else {\n            indexArr[0] = i;\n            indexArr[1] = i + 1;\n            indexArr[2] = i + 2;\n        }\n        const { a: a, b: b, c: c } = $2cd02d3dec669c62$var$_triangle;\n        a.fromBufferAttribute(positionAttr, indexArr[0]);\n        b.fromBufferAttribute(positionAttr, indexArr[1]);\n        c.fromBufferAttribute(positionAttr, indexArr[2]);\n        $2cd02d3dec669c62$var$_triangle.getNormal($2cd02d3dec669c62$var$_normal);\n        // create hashes for the edge from the vertices\n        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;\n        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;\n        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;\n        // skip degenerate triangles\n        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) continue;\n        // iterate over every edge\n        for(let j = 0; j < 3; j++){\n            // get the first and next vertex making up the edge\n            const jNext = (j + 1) % 3;\n            const vecHash0 = hashes[j];\n            const vecHash1 = hashes[jNext];\n            const v0 = $2cd02d3dec669c62$var$_triangle[vertKeys[j]];\n            const v1 = $2cd02d3dec669c62$var$_triangle[vertKeys[jNext]];\n            const hash = `${vecHash0}_${vecHash1}`;\n            const reverseHash = `${vecHash1}_${vecHash0}`;\n            if (reverseHash in edgeData && edgeData[reverseHash]) {\n                // if we found a sibling edge add it into the vertex array if\n                // it meets the angle threshold and delete the edge from the map.\n                const otherNormal = edgeData[reverseHash].normal;\n                const meetsThreshold = $2cd02d3dec669c62$var$_normal.dot(otherNormal) <= thresholdDot;\n                // get the dot product relative to the projection angle and\n                // add an epsilon for nearly vertical triangles\n                let normDot = projectionDir.dot($2cd02d3dec669c62$var$_normal);\n                normDot = Math.abs(normDot) < $2cd02d3dec669c62$var$EPSILON ? 0 : normDot;\n                let otherDot = projectionDir.dot(otherNormal);\n                otherDot = Math.abs(otherDot) < $2cd02d3dec669c62$var$EPSILON ? 0 : otherDot;\n                const projectionThreshold = Math.sign(normDot) !== Math.sign(otherDot);\n                if (meetsThreshold || projectionThreshold) {\n                    const line = new (0, $e06gU.Line3)();\n                    line.start.copy(v0);\n                    line.end.copy(v1);\n                    edges.push(line);\n                }\n                edgeData[reverseHash] = null;\n            } else if (!(hash in edgeData)) // if we've already got an edge here then skip adding a new one\n            edgeData[hash] = {\n                index0: indexArr[j],\n                index1: indexArr[jNext],\n                normal: $2cd02d3dec669c62$var$_normal.clone()\n            };\n        }\n    }\n    // iterate over all remaining, unmatched edges and add them to the vertex array\n    for(const key in edgeData)if (edgeData[key]) {\n        const { index0: index0, index1: index1 } = edgeData[key];\n        $2cd02d3dec669c62$var$_v0.fromBufferAttribute(positionAttr, index0);\n        $2cd02d3dec669c62$var$_v1.fromBufferAttribute(positionAttr, index1);\n        const line = new (0, $e06gU.Line3)();\n        line.start.copy($2cd02d3dec669c62$var$_v0);\n        line.end.copy($2cd02d3dec669c62$var$_v1);\n        edges.push(line);\n    }\n    return edges;\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\nconst $627e7388cda991d0$var$_line = /* @__PURE__ */ new (0, $e06gU.Line3)();\nfunction $627e7388cda991d0$export$84bed164e326c2f0(overlaps) {\n    overlaps.sort((a, b)=>{\n        return a[0] - b[0];\n    });\n    for(let i = 1; i < overlaps.length; i++){\n        const overlap = overlaps[i];\n        const prevOverlap = overlaps[i - 1];\n        if (prevOverlap[1] >= overlap[0]) {\n            prevOverlap[1] = Math.max(prevOverlap[1], overlap[1]);\n            overlaps.splice(i, 1);\n            i--;\n        }\n    }\n}\nfunction $627e7388cda991d0$export$fbbde8a5b23b7b65(line, overlaps, target = []) {\n    $627e7388cda991d0$export$84bed164e326c2f0(overlaps);\n    const invOverlaps = [\n        [\n            0,\n            1\n        ]\n    ];\n    for(let i = 0, l = overlaps.length; i < l; i++){\n        const invOverlap = invOverlaps[i];\n        const overlap = overlaps[i];\n        invOverlap[1] = overlap[0];\n        invOverlaps.push(new Float32Array([\n            overlap[1],\n            1\n        ]));\n    }\n    for(let i = 0, l = invOverlaps.length; i < l; i++){\n        const { start: start, end: end } = line;\n        $627e7388cda991d0$var$_line.start.lerpVectors(start, end, invOverlaps[i][0]);\n        $627e7388cda991d0$var$_line.end.lerpVectors(start, end, invOverlaps[i][1]);\n        target.push(new Float32Array([\n            $627e7388cda991d0$var$_line.start.x,\n            $627e7388cda991d0$var$_line.start.y,\n            $627e7388cda991d0$var$_line.start.z,\n            $627e7388cda991d0$var$_line.end.x,\n            $627e7388cda991d0$var$_line.end.y,\n            $627e7388cda991d0$var$_line.end.z\n        ]));\n    }\n    return target;\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\nconst $aab05f562594c8e7$var$EPSILON = 1e-16;\nconst $aab05f562594c8e7$var$UP_VECTOR = /* @__PURE__ */ new (0, $e06gU.Vector3)(0, 1, 0);\nconst $aab05f562594c8e7$var$_plane = /* @__PURE__ */ new (0, $e06gU.Plane)();\nconst $aab05f562594c8e7$var$_planeHit = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $aab05f562594c8e7$var$_lineDirection = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nfunction $aab05f562594c8e7$export$3240a8dc8bb0ce4c(tri, line, lineTarget) {\n    // if the triangle is insignificant then skip it\n    if ((0, $3e2a3abaa10886a8$export$97cada60b6f00a63)(tri)) return false;\n    // update triangle if needed\n    if (tri.needsUpdate) tri.update();\n    // if the plane is not facing up then flip the direction\n    $aab05f562594c8e7$var$_plane.copy(tri.plane);\n    if ($aab05f562594c8e7$var$_plane.normal.dot($aab05f562594c8e7$var$UP_VECTOR) < 0) {\n        $aab05f562594c8e7$var$_plane.normal.multiplyScalar(-1);\n        $aab05f562594c8e7$var$_plane.constant *= -1;\n    }\n    const startDist = $aab05f562594c8e7$var$_plane.distanceToPoint(line.start);\n    const endDist = $aab05f562594c8e7$var$_plane.distanceToPoint(line.end);\n    const isStartOnPlane = Math.abs(startDist) < $aab05f562594c8e7$var$EPSILON;\n    const isEndOnPlane = Math.abs(endDist) < $aab05f562594c8e7$var$EPSILON;\n    const isStartBelow = startDist < 0;\n    const isEndBelow = endDist < 0;\n    // if the line and plane are coplanar then return that we can't trim\n    line.delta($aab05f562594c8e7$var$_lineDirection).normalize();\n    if (Math.abs($aab05f562594c8e7$var$_plane.normal.dot($aab05f562594c8e7$var$_lineDirection)) < $aab05f562594c8e7$var$EPSILON) {\n        if (isStartOnPlane || !isStartBelow) return false;\n        else {\n            lineTarget.copy(line);\n            return true;\n        }\n    }\n    // find the point that's below the plane. If both points are below the plane\n    // then we assume we're dealing with floating point error\n    if (isStartBelow && isEndBelow) {\n        // if the whole line is below then just copy that\n        lineTarget.copy(line);\n        return true;\n    } else if (!isStartBelow && !isEndBelow) // if it's wholly above then skip it\n    return false;\n    else {\n        let didHit = $aab05f562594c8e7$var$_plane.intersectLine(line, $aab05f562594c8e7$var$_planeHit);\n        if (!didHit) {\n            if (isStartOnPlane) {\n                $aab05f562594c8e7$var$_planeHit.copy(line.start);\n                didHit = true;\n            }\n            if (isEndOnPlane) {\n                $aab05f562594c8e7$var$_planeHit.copy(line.end);\n                didHit = true;\n            }\n        }\n        if (didHit) {\n            if (isStartBelow) {\n                lineTarget.start.copy(line.start);\n                lineTarget.end.copy($aab05f562594c8e7$var$_planeHit);\n                return true;\n            } else if (isEndBelow) {\n                lineTarget.end.copy(line.end);\n                lineTarget.start.copy($aab05f562594c8e7$var$_planeHit);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\nconst $485089c6d0563e10$var$AREA_EPSILON = 1e-16;\nconst $485089c6d0563e10$var$DIST_EPSILON = 1e-16;\nconst $485089c6d0563e10$var$_orthoPlane = /* @__PURE__ */ new (0, $e06gU.Plane)();\nconst $485089c6d0563e10$var$_edgeLine = /* @__PURE__ */ new (0, $e06gU.Line3)();\nconst $485089c6d0563e10$var$_point = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $485089c6d0563e10$var$_vec = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $485089c6d0563e10$var$_tri = /* @__PURE__ */ new (0, $277ed51eec8cb2f4$export$a37f7ec1c23dfacf)();\nconst $485089c6d0563e10$var$_line = /* @__PURE__ */ new (0, $e06gU.Line3)();\nconst $485089c6d0563e10$var$_triLine = /* @__PURE__ */ new (0, $e06gU.Line3)();\nconst $485089c6d0563e10$var$_dir = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $485089c6d0563e10$var$_triDir = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nfunction $485089c6d0563e10$export$87b006ababf09c4d(line, triangle, lineTarget = new (0, $e06gU.Line3)()) {\n    // flatten the shapes\n    $485089c6d0563e10$var$_tri.copy(triangle);\n    $485089c6d0563e10$var$_tri.a.y = 0;\n    $485089c6d0563e10$var$_tri.b.y = 0;\n    $485089c6d0563e10$var$_tri.c.y = 0;\n    $485089c6d0563e10$var$_tri.update();\n    $485089c6d0563e10$var$_line.copy(line);\n    $485089c6d0563e10$var$_line.start.y = 0;\n    $485089c6d0563e10$var$_line.end.y = 0;\n    // if the triangle is degenerate then return no overlap\n    if ($485089c6d0563e10$var$_tri.getArea() <= $485089c6d0563e10$var$AREA_EPSILON) return null;\n    $485089c6d0563e10$var$_line.delta($485089c6d0563e10$var$_dir).normalize();\n    $485089c6d0563e10$var$_dir.cross($485089c6d0563e10$var$_tri.plane.normal).normalize();\n    $485089c6d0563e10$var$_orthoPlane.setFromNormalAndCoplanarPoint($485089c6d0563e10$var$_dir, $485089c6d0563e10$var$_line.start);\n    // find the line of intersection of the triangle along the plane if it exists\n    let intersectCount = 0;\n    const { points: points } = $485089c6d0563e10$var$_tri;\n    for(let i = 0; i < 3; i++){\n        const p1 = points[i];\n        const p2 = points[(i + 1) % 3];\n        $485089c6d0563e10$var$_edgeLine.start.copy(p1);\n        $485089c6d0563e10$var$_edgeLine.end.copy(p2);\n        const startIntersects = Math.abs($485089c6d0563e10$var$_orthoPlane.distanceToPoint($485089c6d0563e10$var$_edgeLine.start)) < $485089c6d0563e10$var$DIST_EPSILON;\n        const endIntersects = Math.abs($485089c6d0563e10$var$_orthoPlane.distanceToPoint($485089c6d0563e10$var$_edgeLine.end)) < $485089c6d0563e10$var$DIST_EPSILON;\n        const edgeIntersects = $485089c6d0563e10$var$_orthoPlane.intersectLine($485089c6d0563e10$var$_edgeLine, $485089c6d0563e10$var$_point);\n        if (edgeIntersects && !endIntersects || startIntersects) {\n            if (startIntersects && !edgeIntersects) $485089c6d0563e10$var$_point.copy($485089c6d0563e10$var$_edgeLine.start);\n            if (intersectCount === 0) $485089c6d0563e10$var$_triLine.start.copy($485089c6d0563e10$var$_point);\n            else $485089c6d0563e10$var$_triLine.end.copy($485089c6d0563e10$var$_point);\n            intersectCount++;\n            if (intersectCount === 2) break;\n        }\n    }\n    if (intersectCount === 2) {\n        // find the intersect line if any\n        $485089c6d0563e10$var$_line.delta($485089c6d0563e10$var$_dir).normalize();\n        $485089c6d0563e10$var$_triLine.delta($485089c6d0563e10$var$_triDir).normalize();\n        // swap edges so they're facing in the same direction\n        if ($485089c6d0563e10$var$_dir.dot($485089c6d0563e10$var$_triDir) < 0) {\n            let tmp = $485089c6d0563e10$var$_triLine.start;\n            $485089c6d0563e10$var$_triLine.start = $485089c6d0563e10$var$_triLine.end;\n            $485089c6d0563e10$var$_triLine.end = tmp;\n        }\n        // check if the edges are overlapping\n        const s1 = 0;\n        const e1 = $485089c6d0563e10$var$_vec.subVectors($485089c6d0563e10$var$_line.end, $485089c6d0563e10$var$_line.start).dot($485089c6d0563e10$var$_dir);\n        const s2 = $485089c6d0563e10$var$_vec.subVectors($485089c6d0563e10$var$_triLine.start, $485089c6d0563e10$var$_line.start).dot($485089c6d0563e10$var$_dir);\n        const e2 = $485089c6d0563e10$var$_vec.subVectors($485089c6d0563e10$var$_triLine.end, $485089c6d0563e10$var$_line.start).dot($485089c6d0563e10$var$_dir);\n        const separated1 = e1 <= s2;\n        const separated2 = e2 <= s1;\n        if (separated1 || separated2) return null;\n        line.at(Math.max(s1, s2) / $485089c6d0563e10$var$_line.distance(), lineTarget.start);\n        line.at(Math.min(e1, e2) / $485089c6d0563e10$var$_line.distance(), lineTarget.end);\n        return lineTarget;\n    }\n    return null;\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\nconst $e911a95ad6b2a32e$var$DIST_EPSILON = 1e-16;\nconst $e911a95ad6b2a32e$var$_dir = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $e911a95ad6b2a32e$var$_v0 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $e911a95ad6b2a32e$var$_v1 = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nfunction $e911a95ad6b2a32e$export$23512680614f2620(line, overlapLine, overlapsTarget) {\n    line.delta($e911a95ad6b2a32e$var$_dir);\n    $e911a95ad6b2a32e$var$_v0.subVectors(overlapLine.start, line.start);\n    $e911a95ad6b2a32e$var$_v1.subVectors(overlapLine.end, line.start);\n    const length = $e911a95ad6b2a32e$var$_dir.length();\n    let d0 = $e911a95ad6b2a32e$var$_v0.length() / length;\n    let d1 = $e911a95ad6b2a32e$var$_v1.length() / length;\n    d0 = Math.min(Math.max(d0, 0), 1);\n    d1 = Math.min(Math.max(d1, 0), 1);\n    if (!(Math.abs(d0 - d1) <= $e911a95ad6b2a32e$var$DIST_EPSILON)) {\n        overlapsTarget.push(new Float32Array([\n            d0,\n            d1\n        ]));\n        return true;\n    }\n    return false;\n}\n\n\n\nvar $e06gU = parcelRequire(\"e06gU\");\n\n\nconst $f98ba1c508cee43d$var$OFFSET_EPSILON = 1e-6;\nconst $f98ba1c508cee43d$var$_tri = new (0, $277ed51eec8cb2f4$export$a37f7ec1c23dfacf)();\nconst $f98ba1c508cee43d$var$_line = new (0, $e06gU.Line3)();\nfunction* $f98ba1c508cee43d$export$983ba676a1dedbe3(bvh, iterationTime = 30) {\n    const edges = [];\n    const geometry = bvh.geometry;\n    const index = geometry.index;\n    const posAttr = geometry.attributes.position;\n    const vertCount = index ? index.count : posAttr;\n    let time = performance.now();\n    for(let i = 0; i < vertCount; i += 3){\n        let i0 = i + 0;\n        let i1 = i + 1;\n        let i2 = i + 2;\n        if (index) {\n            i0 = index.getX(i0);\n            i1 = index.getX(i1);\n            i2 = index.getX(i2);\n        }\n        const { a: a, b: b, c: c } = $f98ba1c508cee43d$var$_tri;\n        a.fromBufferAttribute(posAttr, i0);\n        b.fromBufferAttribute(posAttr, i1);\n        c.fromBufferAttribute(posAttr, i2);\n        $f98ba1c508cee43d$var$_tri.needsUpdate = true;\n        $f98ba1c508cee43d$var$_tri.update();\n        bvh.shapecast({\n            intersectsBounds: (box)=>{\n                return box.intersectsTriangle($f98ba1c508cee43d$var$_tri);\n            },\n            intersectsTriangle: (tri2)=>{\n                if ($f98ba1c508cee43d$var$_tri.equals(tri2)) return false;\n                if (tri2.needsUpdate) tri2.update();\n                if (Math.abs($f98ba1c508cee43d$var$_tri.plane.normal.dot(tri2.plane.normal)) > 1 - 1e-6) return false;\n                if ($f98ba1c508cee43d$var$_tri.intersectsTriangle(tri2, $f98ba1c508cee43d$var$_line, true) && !(0, $3e2a3abaa10886a8$export$6ce1ecae0cd1cc55)($f98ba1c508cee43d$var$_tri, $f98ba1c508cee43d$var$_line) && !(0, $3e2a3abaa10886a8$export$6ce1ecae0cd1cc55)(tri2, $f98ba1c508cee43d$var$_line)) {\n                    $f98ba1c508cee43d$var$_line.start.y += $f98ba1c508cee43d$var$OFFSET_EPSILON;\n                    $f98ba1c508cee43d$var$_line.end.y += $f98ba1c508cee43d$var$OFFSET_EPSILON;\n                    edges.push($f98ba1c508cee43d$var$_line.clone());\n                }\n            }\n        });\n        const delta = performance.now() - time;\n        if (delta > iterationTime) {\n            yield;\n            time = performance.now();\n        }\n    }\n    return edges;\n}\n\n\n// these shared variables are not used across \"yield\" boundaries in the\n// generator so there's no risk of overwriting another tasks data\nconst $1481377db44180ba$var$DIST_THRESHOLD = 1e-10;\nconst $1481377db44180ba$var$UP_VECTOR = /* @__PURE__ */ new (0, $e06gU.Vector3)(0, 1, 0);\nconst $1481377db44180ba$var$_beneathLine = /* @__PURE__ */ new (0, $e06gU.Line3)();\nconst $1481377db44180ba$var$_ray = /* @__PURE__ */ new (0, $e06gU.Ray)();\nconst $1481377db44180ba$var$_vec = /* @__PURE__ */ new (0, $e06gU.Vector3)();\nconst $1481377db44180ba$var$_overlapLine = /* @__PURE__ */ new (0, $e06gU.Line3)();\nclass $1481377db44180ba$var$EdgeSet {\n    constructor(){\n        this.edges = [];\n    }\n    getLineGeometry(y = 0) {\n        const edges = this.edges;\n        const edgeArray = new Float32Array(edges.length * 6);\n        let c = 0;\n        for(let i = 0, l = edges.length; i < l; i++){\n            const line = edges[i];\n            edgeArray[c++] = line[0];\n            edgeArray[c++] = y;\n            edgeArray[c++] = line[2];\n            edgeArray[c++] = line[3];\n            edgeArray[c++] = y;\n            edgeArray[c++] = line[5];\n        }\n        const edgeGeom = new (0, $e06gU.BufferGeometry)();\n        const edgeBuffer = new (0, $e06gU.BufferAttribute)(edgeArray, 3, true);\n        edgeGeom.setAttribute(\"position\", edgeBuffer);\n        return edgeGeom;\n    }\n}\nclass $1481377db44180ba$export$4776387f3c0e5209 {\n    constructor(){\n        this.sortEdges = true;\n        this.iterationTime = 30;\n        this.angleThreshold = 50;\n        this.includeIntersectionEdges = true;\n    }\n    generateAsync(geometry, options = {}) {\n        return new Promise((resolve, reject)=>{\n            const { signal: signal } = options;\n            const task = this.generate(geometry, options);\n            run();\n            function run() {\n                if (signal && signal.aborted) {\n                    reject(new Error(\"ProjectionGenerator: Process aborted via AbortSignal.\"));\n                    return;\n                }\n                const result = task.next();\n                if (result.done) resolve(result.value);\n                else requestAnimationFrame(run);\n            }\n        });\n    }\n    *generate(bvh, options = {}) {\n        const { onProgress: onProgress } = options;\n        const { sortEdges: sortEdges, iterationTime: iterationTime, angleThreshold: angleThreshold, includeIntersectionEdges: includeIntersectionEdges } = this;\n        if (bvh instanceof (0, $e06gU.BufferGeometry)) bvh = new (0, $d1f63a316b8768c2$export$9d614b3bc2c4eacf)(bvh, {\n            maxLeafTris: 1\n        });\n        // find the set of edges of intersecting triangles\n        const geometry = bvh.geometry;\n        let edges = (0, $2cd02d3dec669c62$export$b2d7c053833d1662)(geometry, $1481377db44180ba$var$UP_VECTOR, angleThreshold);\n        if (includeIntersectionEdges) {\n            const results = yield* (0, $f98ba1c508cee43d$export$983ba676a1dedbe3)(bvh, iterationTime);\n            edges = edges.concat(results);\n        }\n        // sort the edges from lowest to highest\n        if (sortEdges) edges.sort((a, b)=>{\n            return Math.min(a.start.y, a.end.y) - Math.min(b.start.y, b.end.y);\n        });\n        yield;\n        // trim the candidate edges\n        const finalEdges = new $1481377db44180ba$var$EdgeSet();\n        let time = performance.now();\n        for(let i = 0, l = edges.length; i < l; i++){\n            const line = edges[i];\n            if ((0, $3e2a3abaa10886a8$export$cec4aea73fa71fc5)(line)) continue;\n            const lowestLineY = Math.min(line.start.y, line.end.y);\n            const highestLineY = Math.max(line.start.y, line.end.y);\n            const hiddenOverlaps = [];\n            bvh.shapecast({\n                intersectsBounds: (box)=>{\n                    // expand the bounding box to the bottom height of the line\n                    box.min.y = Math.min(lowestLineY - 1e-6, box.min.y);\n                    // get the line as a ray\n                    const { origin: origin, direction: direction } = $1481377db44180ba$var$_ray;\n                    origin.copy(line.start);\n                    line.delta(direction).normalize();\n                    // if the ray is inside the box then we intersect it\n                    if (box.containsPoint(origin)) return true;\n                    // check if the line segment intersects the box\n                    if ($1481377db44180ba$var$_ray.intersectBox(box, $1481377db44180ba$var$_vec)) return origin.distanceToSquared($1481377db44180ba$var$_vec) < line.distanceSq();\n                    return false;\n                },\n                intersectsTriangle: (tri)=>{\n                    // skip the triangle if the triangle is completely below the line\n                    const highestTriangleY = Math.max(tri.a.y, tri.b.y, tri.c.y);\n                    if (highestTriangleY <= lowestLineY) return false;\n                    // if the projected triangle is just a line then don't check it\n                    if ((0, $3e2a3abaa10886a8$export$97cada60b6f00a63)(tri)) return false;\n                    // if this line lies on a triangle edge then don't check for visual overlaps\n                    // with this triangle\n                    if ((0, $3e2a3abaa10886a8$export$6ce1ecae0cd1cc55)(tri, line)) return false;\n                    // Retrieve the portion of line that is below the plane - and skip the triangle if none\n                    // of it is\n                    const lowestTriangleY = Math.min(tri.a.y, tri.b.y, tri.c.y);\n                    if (highestLineY < lowestTriangleY) $1481377db44180ba$var$_beneathLine.copy(line);\n                    else if (!(0, $aab05f562594c8e7$export$3240a8dc8bb0ce4c)(tri, line, $1481377db44180ba$var$_beneathLine)) return false;\n                    // Cull overly small edges\n                    if ($1481377db44180ba$var$_beneathLine.distance() < $1481377db44180ba$var$DIST_THRESHOLD) return false;\n                    // compress the edge overlaps so we can easily tell if the whole edge is hidden already\n                    // and exit early\n                    if ((0, $485089c6d0563e10$export$87b006ababf09c4d)($1481377db44180ba$var$_beneathLine, tri, $1481377db44180ba$var$_overlapLine) && (0, $e911a95ad6b2a32e$export$23512680614f2620)(line, $1481377db44180ba$var$_overlapLine, hiddenOverlaps)) (0, $627e7388cda991d0$export$84bed164e326c2f0)(hiddenOverlaps);\n                    // if we're hiding the edge entirely now then skip further checks\n                    if (hiddenOverlaps.length !== 0) {\n                        const [d0, d1] = hiddenOverlaps[hiddenOverlaps.length - 1];\n                        return d0 === 0.0 && d1 === 1.0;\n                    }\n                    return false;\n                }\n            });\n            // convert the overlap points to proper lines\n            (0, $627e7388cda991d0$export$fbbde8a5b23b7b65)(line, hiddenOverlaps, finalEdges.edges);\n            const delta = performance.now() - time;\n            if (delta > iterationTime) {\n                if (onProgress) {\n                    const progress = i / edges.length;\n                    onProgress(progress, finalEdges);\n                }\n                yield;\n                time = performance.now();\n            }\n        }\n        return finalEdges.getLineGeometry(0);\n    }\n}\n\n\nonmessage = function({ data: data }) {\n    let prevTime = performance.now();\n    function onProgressCallback(progress) {\n        const currTime = performance.now();\n        if (currTime - prevTime >= 10 || progress === 1.0) {\n            postMessage({\n                error: null,\n                progress: progress\n            });\n            prevTime = currTime;\n        }\n    }\n    try {\n        const { index: index, position: position, options: options } = data;\n        const geometry = new (0, $e06gU.BufferGeometry)();\n        geometry.setIndex(new (0, $e06gU.BufferAttribute)(index, 1, false));\n        geometry.setAttribute(\"position\", new (0, $e06gU.BufferAttribute)(position, 3, false));\n        const generator = new (0, $1481377db44180ba$export$4776387f3c0e5209)();\n        generator.sortEdges = options.sortEdges ?? generator.sortEdges;\n        generator.angleThreshold = options.angleThreshold ?? generator.angleThreshold;\n        generator.includeIntersectionEdges = options.includeIntersectionEdges ?? generator.includeIntersectionEdges;\n        const task = generator.generate(geometry, {\n            onProgress: onProgressCallback\n        });\n        let result = task.next();\n        while(!result.done)result = task.next();\n        const resultLines = result.value.attributes.position.array;\n        postMessage({\n            result: resultLines,\n            error: null,\n            progress: 1\n        }, [\n            resultLines.buffer\n        ]);\n    } catch (error) {\n        postMessage({\n            error: error,\n            progress: 1\n        });\n    }\n};\n\n})();\n//# sourceMappingURL=projectionAsync.worker.28971622.js.map\n","import { BufferAttribute, BufferGeometry } from 'three';\nimport { ProjectionGenerator } from '../ProjectionGenerator.js';\n\nonmessage = function ( { data } ) {\n\n\tlet prevTime = performance.now();\n\tfunction onProgressCallback( progress ) {\n\n\t\tconst currTime = performance.now();\n\t\tif ( currTime - prevTime >= 10 || progress === 1.0 ) {\n\n\t\t\tpostMessage( {\n\n\t\t\t\terror: null,\n\t\t\t\tprogress,\n\n\t\t\t} );\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t}\n\n\ttry {\n\n\t\tconst { index, position, options } = data;\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( index, 1, false ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( position, 3, false ) );\n\n\t\tconst generator = new ProjectionGenerator();\n\t\tgenerator.sortEdges = options.sortEdges ?? generator.sortEdges;\n\t\tgenerator.angleThreshold = options.angleThreshold ?? generator.angleThreshold;\n\t\tgenerator.includeIntersectionEdges = options.includeIntersectionEdges ?? generator.includeIntersectionEdges;\n\n\t\tconst task = generator.generate( geometry, {\n\t\t\tonProgress: onProgressCallback,\n\t\t} );\n\n\t\tlet result = task.next();\n\t\twhile ( ! result.done ) {\n\n\t\t\tresult = task.next();\n\n\t\t}\n\n\t\tconst resultLines = result.value.attributes.position.array;\n\t\tpostMessage( {\n\n\t\t\tresult: resultLines,\n\t\t\terror: null,\n\t\t\tprogress: 1,\n\n\t\t}, [ resultLines.buffer ] );\n\n\t} catch ( error ) {\n\n\t\tpostMessage( {\n\n\t\t\terror,\n\t\t\tprogress: 1,\n\n\t\t} );\n\n\t}\n\n};\n","import {\n\tBufferGeometry,\n\tVector3,\n\tLine3,\n\tRay,\n\tBufferAttribute,\n} from 'three';\nimport { MeshBVH } from 'three-mesh-bvh';\nimport {\n\tisYProjectedTriangleDegenerate,\n\tisLineTriangleEdge,\n\tisYProjectedLineDegenerate,\n} from './utils/triangleLineUtils.js';\nimport { generateEdges } from './utils/generateEdges.js';\nimport { compressEdgeOverlaps, overlapsToLines } from './utils/overlapUtils.js';\nimport { trimToBeneathTriPlane } from './utils/trimToBeneathTriPlane.js';\nimport { getProjectedLineOverlap } from './utils/getProjectedLineOverlap.js';\nimport { appendOverlapRange } from './utils/getProjectedOverlaps.js';\nimport { generateIntersectionEdges } from './utils/generateIntersectionEdges.js';\n\n// these shared variables are not used across \"yield\" boundaries in the\n// generator so there's no risk of overwriting another tasks data\nconst DIST_THRESHOLD = 1e-10;\nconst UP_VECTOR = /* @__PURE__ */ new Vector3( 0, 1, 0 );\nconst _beneathLine = /* @__PURE__ */ new Line3();\nconst _ray = /* @__PURE__ */ new Ray();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _overlapLine = /* @__PURE__ */ new Line3();\n\nclass EdgeSet {\n\n\tconstructor() {\n\n\t\tthis.edges = [];\n\n\t}\n\n\tgetLineGeometry( y = 0 ) {\n\n\t\tconst edges = this.edges;\n\t\tconst edgeArray = new Float32Array( edges.length * 6 );\n\t\tlet c = 0;\n\t\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\n\n\t\t\tconst line = edges[ i ];\n\t\t\tedgeArray[ c ++ ] = line[ 0 ];\n\t\t\tedgeArray[ c ++ ] = y;\n\t\t\tedgeArray[ c ++ ] = line[ 2 ];\n\t\t\tedgeArray[ c ++ ] = line[ 3 ];\n\t\t\tedgeArray[ c ++ ] = y;\n\t\t\tedgeArray[ c ++ ] = line[ 5 ];\n\n\t\t}\n\n\t\tconst edgeGeom = new BufferGeometry();\n\t\tconst edgeBuffer = new BufferAttribute( edgeArray, 3, true );\n\t\tedgeGeom.setAttribute( 'position', edgeBuffer );\n\t\treturn edgeGeom;\n\n\t}\n\n}\n\nexport class ProjectionGenerator {\n\n\tconstructor() {\n\n\t\tthis.sortEdges = true;\n\t\tthis.iterationTime = 30;\n\t\tthis.angleThreshold = 50;\n\t\tthis.includeIntersectionEdges = true;\n\n\t}\n\n\tgenerateAsync( geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tconst { signal } = options;\n\t\t\tconst task = this.generate( geometry, options );\n\t\t\trun();\n\n\t\t\tfunction run() {\n\n\t\t\t\tif ( signal && signal.aborted ) {\n\n\t\t\t\t\treject( new Error( 'ProjectionGenerator: Process aborted via AbortSignal.' ) );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst result = task.next();\n\t\t\t\tif ( result.done ) {\n\n\t\t\t\t\tresolve( result.value );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trequestAnimationFrame( run );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} );\n\n\t}\n\n\t*generate( bvh, options = {} ) {\n\n\t\tconst { onProgress } = options;\n\t\tconst { sortEdges, iterationTime, angleThreshold, includeIntersectionEdges } = this;\n\n\t\tif ( bvh instanceof BufferGeometry ) {\n\n\t\t\tbvh = new MeshBVH( bvh, { maxLeafTris: 1 } );\n\n\t\t}\n\n\t\t// find the set of edges of intersecting triangles\n\t\tconst geometry = bvh.geometry;\n\t\tlet edges = generateEdges( geometry, UP_VECTOR, angleThreshold );\n\t\tif ( includeIntersectionEdges ) {\n\n\t\t\tconst results = yield* generateIntersectionEdges( bvh, iterationTime );\n\t\t\tedges = edges.concat( results );\n\n\t\t}\n\n\t\t// sort the edges from lowest to highest\n\t\tif ( sortEdges ) {\n\n\t\t\tedges.sort( ( a, b ) => {\n\n\t\t\t\treturn Math.min( a.start.y, a.end.y ) - Math.min( b.start.y, b.end.y );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tyield;\n\n\t\t// trim the candidate edges\n\t\tconst finalEdges = new EdgeSet();\n\t\tlet time = performance.now();\n\t\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\n\n\t\t\tconst line = edges[ i ];\n\t\t\tif ( isYProjectedLineDegenerate( line ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst lowestLineY = Math.min( line.start.y, line.end.y );\n\t\t\tconst highestLineY = Math.max( line.start.y, line.end.y );\n\t\t\tconst hiddenOverlaps = [];\n\t\t\tbvh.shapecast( {\n\n\t\t\t\tintersectsBounds: box => {\n\n\t\t\t\t\t// expand the bounding box to the bottom height of the line\n\t\t\t\t\tbox.min.y = Math.min( lowestLineY - 1e-6, box.min.y );\n\n\t\t\t\t\t// get the line as a ray\n\t\t\t\t\tconst { origin, direction } = _ray;\n\t\t\t\t\torigin.copy( line.start );\n\t\t\t\t\tline.delta( direction ).normalize();\n\n\t\t\t\t\t// if the ray is inside the box then we intersect it\n\t\t\t\t\tif ( box.containsPoint( origin ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if the line segment intersects the box\n\t\t\t\t\tif ( _ray.intersectBox( box, _vec ) ) {\n\n\t\t\t\t\t\treturn origin.distanceToSquared( _vec ) < line.distanceSq();\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t// skip the triangle if the triangle is completely below the line\n\t\t\t\t\tconst highestTriangleY = Math.max( tri.a.y, tri.b.y, tri.c.y );\n\t\t\t\t\tif ( highestTriangleY <= lowestLineY ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if the projected triangle is just a line then don't check it\n\t\t\t\t\tif ( isYProjectedTriangleDegenerate( tri ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if this line lies on a triangle edge then don't check for visual overlaps\n\t\t\t\t\t// with this triangle\n\t\t\t\t\tif ( isLineTriangleEdge( tri, line ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Retrieve the portion of line that is below the plane - and skip the triangle if none\n\t\t\t\t\t// of it is\n\t\t\t\t\tconst lowestTriangleY = Math.min( tri.a.y, tri.b.y, tri.c.y );\n\t\t\t\t\tif ( highestLineY < lowestTriangleY ) {\n\n\t\t\t\t\t\t_beneathLine.copy( line );\n\n\t\t\t\t\t} else if ( ! trimToBeneathTriPlane( tri, line, _beneathLine ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Cull overly small edges\n\t\t\t\t\tif ( _beneathLine.distance() < DIST_THRESHOLD ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// compress the edge overlaps so we can easily tell if the whole edge is hidden already\n\t\t\t\t\t// and exit early\n\t\t\t\t\tif (\n\t\t\t\t\t\tgetProjectedLineOverlap( _beneathLine, tri, _overlapLine ) &&\n\t\t\t\t\t\tappendOverlapRange( line, _overlapLine, hiddenOverlaps )\n\t\t\t\t\t) {\n\n\t\t\t\t\t\tcompressEdgeOverlaps( hiddenOverlaps );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if we're hiding the edge entirely now then skip further checks\n\t\t\t\t\tif ( hiddenOverlaps.length !== 0 ) {\n\n\t\t\t\t\t\tconst [ d0, d1 ] = hiddenOverlaps[ hiddenOverlaps.length - 1 ];\n\t\t\t\t\t\treturn d0 === 0.0 && d1 === 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t} );\n\n\t\t\t// convert the overlap points to proper lines\n\t\t\toverlapsToLines( line, hiddenOverlaps, finalEdges.edges );\n\n\t\t\tconst delta = performance.now() - time;\n\t\t\tif ( delta > iterationTime ) {\n\n\t\t\t\tif ( onProgress ) {\n\n\t\t\t\t\tconst progress = i / edges.length;\n\t\t\t\t\tonProgress( progress, finalEdges );\n\n\t\t\t\t}\n\n\t\t\t\tyield;\n\t\t\t\ttime = performance.now();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn finalEdges.getLineGeometry( 0 );\n\n\t}\n\n}\n","import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\nimport { bvhcast } from './cast/bvhcast.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { bvhcast_indirect } from './cast/bvhcast_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\t\t\tindirect: false,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst { _indirectBuffer } = this;\n\t\tthis.resolveTriangleIndex = options.indirect ? i => _indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tconst bvhcastFunc = this.indirect ? bvhcast_indirect : bvhcast;\n\t\treturn bvhcastFunc( this, otherBvh, matrixToLocal, callbacks );\n\n\t}\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n","import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, getCentroidBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\n\nfunction generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nfunction buildTree( bvh, options ) {\n\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t// We can't use the geometry bounding box if it's available because it may be out of date.\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tconst onProgress = options.onProgress;\n\tconst totalTriangles = getTriCount( geometry );\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tlet reachedMaxDepth = false;\n\n\tconst fullBounds = new Float32Array( 6 );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geometry, fullBounds );\n\tconst partionFunc = options.indirect ? partition_indirect : partition;\n\n\tconst roots = [];\n\tconst ranges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst range = ranges[ 0 ];\n\t\tconst root = new MeshBVHNode();\n\t\troot.boundingData = fullBounds;\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( bvh, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\tbvh._roots = packedRoots;\n\treturn;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n","import { FLOAT32_EPSILON } from '../Constants.js';\nimport { makeEmptyBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nexport function getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, fullBounds ) {\n\n\t// clear the bounds to empty\n\tmakeEmptyBounds( fullBounds );\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\tconst normalized = posAttr.normalized;\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t}\n\n}\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\tconst tempPoint = new Vector3();\n\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t// find the edge that intersects the other triangle plane\n\t\tconst points = tri.points;\n\t\tlet count = 0;\n\t\tlet startPointIntersection = - 1;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst { start, end } = edge;\n\t\t\tstart.copy( points[ i ] );\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\tedge.delta( dir );\n\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\tcount = 2;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\ttempPoint.copy( start );\n\n\t\t\t}\n\n\t\t\t// ignore the end point\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t// the start point if necessary\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcount ++;\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","import { Vector3 } from 'three';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nfunction raycast( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","import { Box3 } from 'three';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\n\nconst _boundingBox = /* @__PURE__ */ new Box3();\nexport function intersectRay( nodeIndex32, array, ray, target ) {\n\n\tarrayToBox( nodeIndex32, array, _boundingBox );\n\treturn ray.intersectBox( _boundingBox, target );\n\n}\n","import { Vector3 } from 'three';\nimport { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nconst _xyzFields = [ 'x', 'y', 'z' ];\nfunction raycastFirst( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, _boxIntersection );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, _boxIntersection );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { Matrix4, Box3 } from 'three';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/******************************************************/\n/* This file is generated from \"bvhcast.template.js\". */\n/******************************************************/\n\nconst tempMatrix = new Matrix4();\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nfunction bvhcast( bvh, otherBvh, matrixToLocal, callbacks ) {\n\n\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\tlet {\n\t\tintersectsRanges,\n\t\tintersectsTriangles,\n\t} = callbacks;\n\n\tconst indexAttr = bvh.geometry.index;\n\tconst positionAttr = bvh.geometry.attributes.position;\n\n\tconst otherIndexAttr = otherBvh.geometry.index;\n\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\ttempMatrix.copy( matrixToLocal ).invert();\n\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tif ( intersectsTriangles ) {\n\n\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\n\n\n\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\n\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\n\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\tif ( intersectsRanges ) {\n\n\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t}\n\n\t}\n\n\totherBvh.getBoundingBox( aabb2 );\n\taabb2.applyMatrix4( matrixToLocal );\n\tconst result = bvh.shapecast( {\n\n\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\taabb.copy( box );\n\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t},\n\n\t\t\t} );\n\n\t\t}\n\n\t} );\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\treturn result;\n\n}\n\nexport { bvhcast };\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { Vector3 } from 'three';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nfunction raycast_indirect( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, _boxIntersection ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { Vector3 } from 'three';\nimport { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\nconst _xyzFields = [ 'x', 'y', 'z' ];\nfunction raycastFirst_indirect( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, _boxIntersection );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, _boxIntersection );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","import { Matrix4, Box3 } from 'three';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/******************************************************/\n/* This file is generated from \"bvhcast.template.js\". */\n/******************************************************/\n\nconst tempMatrix = new Matrix4();\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nfunction bvhcast_indirect( bvh, otherBvh, matrixToLocal, callbacks ) {\n\n\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\tlet {\n\t\tintersectsRanges,\n\t\tintersectsTriangles,\n\t} = callbacks;\n\n\tconst indexAttr = bvh.geometry.index;\n\tconst positionAttr = bvh.geometry.attributes.position;\n\n\tconst otherIndexAttr = otherBvh.geometry.index;\n\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\ttempMatrix.copy( matrixToLocal ).invert();\n\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tif ( intersectsTriangles ) {\n\n\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, otherIndexAttr, otherPositionAttr );\n\n\n\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\tconst ti1 = bvh.resolveTriangleIndex( i1 );\n\t\t\t\t\tsetTriangle( triangle, ti1 * 3, indexAttr, positionAttr );\n\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\tif ( intersectsRanges ) {\n\n\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t}\n\n\t}\n\n\totherBvh.getBoundingBox( aabb2 );\n\taabb2.applyMatrix4( matrixToLocal );\n\tconst result = bvh.shapecast( {\n\n\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\taabb.copy( box );\n\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t},\n\n\t\t\t} );\n\n\t\t}\n\n\t} );\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\treturn result;\n\n}\n\nexport { bvhcast_indirect };\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n","import { Vector3 } from 'three';\n\nconst EPSILON = 1e-16;\nconst UP_VECTOR = /* @__PURE__ */ new Vector3( 0, 1, 0 );\nconst _dir = new Vector3();\n\nexport function isYProjectedLineDegenerate( line ) {\n\n\tline.delta( _dir ).normalize();\n\treturn Math.abs( _dir.dot( UP_VECTOR ) ) >= 1.0 - EPSILON;\n\n}\n\n// checks whether the y-projected triangle will be degenerate\nexport function isYProjectedTriangleDegenerate( tri ) {\n\n\tif ( tri.needsUpdate ) {\n\n\t\ttri.update();\n\n\t}\n\n\treturn Math.abs( tri.plane.normal.dot( UP_VECTOR ) ) <= EPSILON;\n\n}\n\n// Is the provided line exactly an edge on the triangle\nexport function isLineTriangleEdge( tri, line ) {\n\n\t// if this is the same line as on the triangle\n\tconst { start, end } = line;\n\tconst triPoints = tri.points;\n\tlet startMatches = false;\n\tlet endMatches = false;\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst tp = triPoints[ i ];\n\t\tif ( ! startMatches && start.distanceToSquared( tp ) <= EPSILON ) {\n\n\t\t\tstartMatches = true;\n\n\t\t}\n\n\t\tif ( ! endMatches && end.distanceToSquared( tp ) <= EPSILON ) {\n\n\t\t\tendMatches = true;\n\n\t\t}\n\n\t\tif ( startMatches && endMatches ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn startMatches && endMatches;\n\n}\n","import { Vector3, Triangle, Line3, MathUtils } from 'three';\n\n// Modified version of js EdgesGeometry logic to handle silhouette edges\nconst EPSILON = 1e-16;\nconst UP_VECTOR = /* @__PURE__ */ new Vector3( 0, 1, 0 );\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\nconst _normal = /* @__PURE__ */ new Vector3();\nconst _triangle = /* @__PURE__ */ new Triangle();\n\nexport function generateEdges( geometry, projectionDir = UP_VECTOR, thresholdAngle = 1 ) {\n\n\tconst edges = [];\n\n\tconst precisionPoints = 4;\n\tconst precision = Math.pow( 10, precisionPoints );\n\tconst thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );\n\n\tconst indexAttr = geometry.getIndex();\n\tconst positionAttr = geometry.getAttribute( 'position' );\n\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\tconst indexArr = [ 0, 0, 0 ];\n\tconst vertKeys = [ 'a', 'b', 'c' ];\n\tconst hashes = new Array( 3 );\n\n\tconst edgeData = {};\n\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\tif ( indexAttr ) {\n\n\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t} else {\n\n\t\t\tindexArr[ 0 ] = i;\n\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t}\n\n\t\tconst { a, b, c } = _triangle;\n\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t_triangle.getNormal( _normal );\n\n\t\t// create hashes for the edge from the vertices\n\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t// skip degenerate triangles\n\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// iterate over every edge\n\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t// get the first and next vertex making up the edge\n\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\tconst otherNormal = edgeData[ reverseHash ].normal;\n\t\t\t\tconst meetsThreshold = _normal.dot( otherNormal ) <= thresholdDot;\n\n\t\t\t\t// get the dot product relative to the projection angle and\n\t\t\t\t// add an epsilon for nearly vertical triangles\n\t\t\t\tlet normDot = projectionDir.dot( _normal );\n\t\t\t\tnormDot = Math.abs( normDot ) < EPSILON ? 0 : normDot;\n\n\t\t\t\tlet otherDot = projectionDir.dot( otherNormal );\n\t\t\t\totherDot = Math.abs( otherDot ) < EPSILON ? 0 : otherDot;\n\n\t\t\t\tconst projectionThreshold = Math.sign( normDot ) !== Math.sign( otherDot );\n\t\t\t\tif ( meetsThreshold || projectionThreshold ) {\n\n\t\t\t\t\tconst line = new Line3();\n\t\t\t\t\tline.start.copy( v0 );\n\t\t\t\t\tline.end.copy( v1 );\n\t\t\t\t\tedges.push( line );\n\n\t\t\t\t}\n\n\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\tfor ( const key in edgeData ) {\n\n\t\tif ( edgeData[ key ] ) {\n\n\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t_v1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\tconst line = new Line3();\n\t\t\tline.start.copy( _v0 );\n\t\t\tline.end.copy( _v1 );\n\t\t\tedges.push( line );\n\n\t\t}\n\n\t}\n\n\treturn edges;\n\n}\n","import { Line3 } from 'three';\n\nconst _line = /* @__PURE__ */ new Line3();\n\n// compresses the given edge overlaps into a minimal set of representative objects\nexport function compressEdgeOverlaps( overlaps ) {\n\n\toverlaps.sort( ( a, b ) => {\n\n\t\treturn a[ 0 ] - b[ 0 ];\n\n\t} );\n\n\tfor ( let i = 1; i < overlaps.length; i ++ ) {\n\n\t\tconst overlap = overlaps[ i ];\n\t\tconst prevOverlap = overlaps[ i - 1 ];\n\t\tif ( prevOverlap[ 1 ] >= overlap[ 0 ] ) {\n\n\t\t\tprevOverlap[ 1 ] = Math.max( prevOverlap[ 1 ], overlap[ 1 ] );\n\t\t\toverlaps.splice( i, 1 );\n\t\t\ti --;\n\n\t\t}\n\n\t}\n\n}\n\n\n// Converts the given array of overlaps into line segments\nexport function overlapsToLines( line, overlaps, target = [] ) {\n\n\tcompressEdgeOverlaps( overlaps );\n\n\tconst invOverlaps = [[ 0, 1 ]];\n\tfor ( let i = 0, l = overlaps.length; i < l; i ++ ) {\n\n\t\tconst invOverlap = invOverlaps[ i ];\n\t\tconst overlap = overlaps[ i ];\n\t\tinvOverlap[ 1 ] = overlap[ 0 ];\n\t\tinvOverlaps.push( new Float32Array( [ overlap[ 1 ], 1 ] ) );\n\n\t}\n\n\tfor ( let i = 0, l = invOverlaps.length; i < l; i ++ ) {\n\n\t\tconst { start, end } = line;\n\t\t_line.start.lerpVectors( start, end, invOverlaps[ i ][ 0 ] );\n\t\t_line.end.lerpVectors( start, end, invOverlaps[ i ][ 1 ] );\n\n\t\ttarget.push( new Float32Array( [\n\t\t\t_line.start.x,\n\t\t\t_line.start.y,\n\t\t\t_line.start.z,\n\n\t\t\t_line.end.x,\n\t\t\t_line.end.y,\n\t\t\t_line.end.z,\n\t\t] ) );\n\n\t}\n\n\treturn target;\n\n}\n","import { Plane, Vector3 } from 'three';\nimport { isYProjectedTriangleDegenerate } from './triangleLineUtils.js';\n\nconst EPSILON = 1e-16;\nconst UP_VECTOR = /* @__PURE__ */ new Vector3( 0, 1, 0 );\nconst _plane = /* @__PURE__ */ new Plane();\nconst _planeHit = /* @__PURE__ */ new Vector3();\nconst _lineDirection = /* @__PURE__ */ new Vector3();\nexport function trimToBeneathTriPlane( tri, line, lineTarget ) {\n\n\t// if the triangle is insignificant then skip it\n\tif ( isYProjectedTriangleDegenerate( tri ) ) {\n\n\t\treturn false;\n\n\t}\n\n\t// update triangle if needed\n\tif ( tri.needsUpdate ) {\n\n\t\ttri.update();\n\n\t}\n\n\t// if the plane is not facing up then flip the direction\n\t_plane.copy( tri.plane );\n\tif ( _plane.normal.dot( UP_VECTOR ) < 0 ) {\n\n\t\t_plane.normal.multiplyScalar( - 1 );\n\t\t_plane.constant *= - 1;\n\n\t}\n\n\tconst startDist = _plane.distanceToPoint( line.start );\n\tconst endDist = _plane.distanceToPoint( line.end );\n\tconst isStartOnPlane = Math.abs( startDist ) < EPSILON;\n\tconst isEndOnPlane = Math.abs( endDist ) < EPSILON;\n\tconst isStartBelow = startDist < 0;\n\tconst isEndBelow = endDist < 0;\n\n\t// if the line and plane are coplanar then return that we can't trim\n\tline.delta( _lineDirection ).normalize();\n\tif ( Math.abs( _plane.normal.dot( _lineDirection ) ) < EPSILON ) {\n\n\t\tif ( isStartOnPlane || ! isStartBelow ) {\n\n\t\t\treturn false;\n\n\t\t} else {\n\n\t\t\tlineTarget.copy( line );\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\t// find the point that's below the plane. If both points are below the plane\n\t// then we assume we're dealing with floating point error\n\tif ( isStartBelow && isEndBelow ) {\n\n\t\t// if the whole line is below then just copy that\n\t\tlineTarget.copy( line );\n\t\treturn true;\n\n\t} else if ( ! isStartBelow && ! isEndBelow ) {\n\n\t\t// if it's wholly above then skip it\n\t\treturn false;\n\n\t} else {\n\n\t\tlet didHit = _plane.intersectLine( line, _planeHit );\n\t\tif ( ! didHit ) {\n\n\t\t\tif ( isStartOnPlane ) {\n\n\t\t\t\t_planeHit.copy( line.start );\n\t\t\t\tdidHit = true;\n\n\t\t\t}\n\n\t\t\tif ( isEndOnPlane ) {\n\n\t\t\t\t_planeHit.copy( line.end );\n\t\t\t\tdidHit = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( didHit ) {\n\n\t\t\tif ( isStartBelow ) {\n\n\t\t\t\tlineTarget.start.copy( line.start );\n\t\t\t\tlineTarget.end.copy( _planeHit );\n\t\t\t\treturn true;\n\n\t\t\t} else if ( isEndBelow ) {\n\n\t\t\t\tlineTarget.end.copy( line.end );\n\t\t\t\tlineTarget.start.copy( _planeHit );\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n","import { Vector3, Line3, Plane } from 'three';\nimport { ExtendedTriangle } from 'three-mesh-bvh';\n\nconst AREA_EPSILON = 1e-16;\nconst DIST_EPSILON = 1e-16;\nconst _orthoPlane = /* @__PURE__ */ new Plane();\nconst _edgeLine = /* @__PURE__ */ new Line3();\nconst _point = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _tri = /* @__PURE__ */ new ExtendedTriangle();\nconst _line = /* @__PURE__ */ new Line3();\nconst _triLine = /* @__PURE__ */ new Line3();\nconst _dir = /* @__PURE__ */ new Vector3();\nconst _triDir = /* @__PURE__ */ new Vector3();\n\n// Returns the portion of the line that is overlapping the triangle when projected\n// TODO: rename this, remove need for tri update, plane\nexport function getProjectedLineOverlap( line, triangle, lineTarget = new Line3() ) {\n\n\t// flatten the shapes\n\t_tri.copy( triangle );\n\t_tri.a.y = 0;\n\t_tri.b.y = 0;\n\t_tri.c.y = 0;\n\t_tri.update();\n\n\t_line.copy( line );\n\t_line.start.y = 0;\n\t_line.end.y = 0;\n\n\t// if the triangle is degenerate then return no overlap\n\tif ( _tri.getArea() <= AREA_EPSILON ) {\n\n\t\treturn null;\n\n\t}\n\n\t_line.delta( _dir ).normalize();\n\t_dir.cross( _tri.plane.normal ).normalize();\n\t_orthoPlane.setFromNormalAndCoplanarPoint( _dir, _line.start );\n\n\t// find the line of intersection of the triangle along the plane if it exists\n\tlet intersectCount = 0;\n\tconst { points } = _tri;\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst p1 = points[ i ];\n\t\tconst p2 = points[ ( i + 1 ) % 3 ];\n\n\t\t_edgeLine.start.copy( p1 );\n\t\t_edgeLine.end.copy( p2 );\n\t\tconst startIntersects = Math.abs( _orthoPlane.distanceToPoint( _edgeLine.start ) ) < DIST_EPSILON;\n\t\tconst endIntersects = Math.abs( _orthoPlane.distanceToPoint( _edgeLine.end ) ) < DIST_EPSILON;\n\t\tconst edgeIntersects = _orthoPlane.intersectLine( _edgeLine, _point );\n\t\tif ( edgeIntersects && ! endIntersects || startIntersects ) {\n\n\t\t\tif ( startIntersects && ! edgeIntersects ) {\n\n\t\t\t\t_point.copy( _edgeLine.start );\n\n\t\t\t}\n\n\t\t\tif ( intersectCount === 0 ) {\n\n\t\t\t\t_triLine.start.copy( _point );\n\n\t\t\t} else {\n\n\t\t\t\t_triLine.end.copy( _point );\n\n\t\t\t}\n\n\t\t\tintersectCount ++;\n\t\t\tif ( intersectCount === 2 ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( intersectCount === 2 ) {\n\n\t\t// find the intersect line if any\n\t\t_line.delta( _dir ).normalize();\n\t\t_triLine.delta( _triDir ).normalize();\n\n\t\t// swap edges so they're facing in the same direction\n\t\tif ( _dir.dot( _triDir ) < 0 ) {\n\n\t\t\tlet tmp = _triLine.start;\n\t\t\t_triLine.start = _triLine.end;\n\t\t\t_triLine.end = tmp;\n\n\t\t}\n\n\t\t// check if the edges are overlapping\n\t\tconst s1 = 0;\n\t\tconst e1 = _vec.subVectors( _line.end, _line.start ).dot( _dir );\n\t\tconst s2 = _vec.subVectors( _triLine.start, _line.start ).dot( _dir );\n\t\tconst e2 = _vec.subVectors( _triLine.end, _line.start ).dot( _dir );\n\t\tconst separated1 = e1 <= s2;\n\t\tconst separated2 = e2 <= s1;\n\n\t\tif ( separated1 || separated2 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tline.at(\n\t\t\tMath.max( s1, s2 ) / _line.distance(),\n\t\t\tlineTarget.start,\n\t\t);\n\n\t\tline.at(\n\t\t\tMath.min( e1, e2 ) / _line.distance(),\n\t\t\tlineTarget.end,\n\t\t);\n\n\t\treturn lineTarget;\n\n\t}\n\n\treturn null;\n\n}\n","import { Vector3 } from 'three';\n\nconst DIST_EPSILON = 1e-16;\nconst _dir = /* @__PURE__ */ new Vector3();\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\nexport function appendOverlapRange( line, overlapLine, overlapsTarget ) {\n\n\tline.delta( _dir );\n\t_v0.subVectors( overlapLine.start, line.start );\n\t_v1.subVectors( overlapLine.end, line.start );\n\n\tconst length = _dir.length();\n\tlet d0 = _v0.length() / length;\n\tlet d1 = _v1.length() / length;\n\n\td0 = Math.min( Math.max( d0, 0 ), 1 );\n\td1 = Math.min( Math.max( d1, 0 ), 1 );\n\n\tif ( ! ( Math.abs( d0 - d1 ) <= DIST_EPSILON ) ) {\n\n\t\toverlapsTarget.push( new Float32Array( [ d0, d1 ] ) );\n\t\treturn true;\n\n\t}\n\n\treturn false;\n\n}\n","import { Line3 } from 'three';\nimport { ExtendedTriangle } from 'three-mesh-bvh';\nimport { isLineTriangleEdge } from './triangleLineUtils.js';\n\nconst OFFSET_EPSILON = 1e-6;\nconst _tri = new ExtendedTriangle();\nconst _line = new Line3();\nexport function* generateIntersectionEdges( bvh, iterationTime = 30 ) {\n\n\tconst edges = [];\n\tconst geometry = bvh.geometry;\n\tconst index = geometry.index;\n\tconst posAttr = geometry.attributes.position;\n\tconst vertCount = index ? index.count : posAttr;\n\n\tlet time = performance.now();\n\tfor ( let i = 0; i < vertCount; i += 3 ) {\n\n\t\tlet i0 = i + 0;\n\t\tlet i1 = i + 1;\n\t\tlet i2 = i + 2;\n\t\tif ( index ) {\n\n\t\t\ti0 = index.getX( i0 );\n\t\t\ti1 = index.getX( i1 );\n\t\t\ti2 = index.getX( i2 );\n\n\t\t}\n\n\t\tconst { a, b, c } = _tri;\n\t\ta.fromBufferAttribute( posAttr, i0 );\n\t\tb.fromBufferAttribute( posAttr, i1 );\n\t\tc.fromBufferAttribute( posAttr, i2 );\n\t\t_tri.needsUpdate = true;\n\t\t_tri.update();\n\n\t\tbvh.shapecast( {\n\n\t\t\tintersectsBounds: box => {\n\n\t\t\t\treturn box.intersectsTriangle( _tri );\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: tri2 => {\n\n\t\t\t\tif ( _tri.equals( tri2 ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tri2.needsUpdate ) {\n\n\t\t\t\t\ttri2.update();\n\n\t\t\t\t}\n\n\t\t\t\tif ( Math.abs( _tri.plane.normal.dot( tri2.plane.normal ) ) > 1 - 1e-6 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t_tri.intersectsTriangle( tri2, _line, true ) &&\n\t\t\t\t\t! isLineTriangleEdge( _tri, _line ) &&\n\t\t\t\t\t! isLineTriangleEdge( tri2, _line )\n\t\t\t\t) {\n\n\t\t\t\t\t_line.start.y += OFFSET_EPSILON;\n\t\t\t\t\t_line.end.y += OFFSET_EPSILON;\n\t\t\t\t\tedges.push( _line.clone() );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t} );\n\n\t\tconst delta = performance.now() - time;\n\t\tif ( delta > iterationTime ) {\n\n\t\t\tyield;\n\t\t\ttime = performance.now();\n\n\t\t}\n\n\t}\n\n\treturn edges;\n\n}\n"],"names":["$59a851f097f5ef7e$var$_box1","$59a851f097f5ef7e$var$_box2","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","importScripts","$e06gU","$bc798809290ffd6b$export$abef70518a11a6ba","Symbol","$512bf92b30757ce0$export$c56c51fae37b2d63","geo","$512bf92b30757ce0$export$bb010cc24ecaa644","index","count","attributes","position","$512bf92b30757ce0$export$8c9d42783264c26e","triCount","drawRange","start","end","offset","Math","max","floor","min","$512bf92b30757ce0$export$fd7a16c461f5043c","groups","length","ranges","rangeBoundaries","Set","drawRangeStart","drawRangeEnd","group","groupStart","groupEnd","add","sortedBoundaries","Array","from","values","sort","a","b","i","push","$d5323e54f8bf740a$export$40b9a5e446bf11e0","nodeIndex32","array","target","x","y","z","$d5323e54f8bf740a$export$dcdc414399b99746","bounds","splitDimIdx","splitDist","Infinity","dist","$d5323e54f8bf740a$export$a8a7063dce01a911","aVal","bVal","d","d3","$d5323e54f8bf740a$export$c989e53c4b24c2f5","startIndex","triangleBounds","tCenter","tHalf","tMin","tMax","$d5323e54f8bf740a$export$dbf4320364dc239e","d0","d1","d2","$faecb3eca4385fa9$export$becd1e645219fa23","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","$62809835080ba262$var$binsSort","candidate","$62809835080ba262$var$sahBins","fill","map","Float32Array","rightCacheBounds","leftCacheBounds","$62809835080ba262$var$leftBounds","$5f1fa9198ab38bd9$export$6f473cc5f89b0a1c","constructor","$dc07fa3855e86015$export$b29f828819edca8d","indirectBuffer","split","left","right","pos","axisOffset","axis","t0","tb","$aace0473d446b8ef$export$7cee363d477551d0","t","$34f95eced4ec08e7$export$f758e41ecdcd8e69","setFromPointsField","points","field","l","p","val","setFromPoints","dot","isSeparated","other","prototype","setFromBox","Vector3","box","boxMin","boxMax","$1300ab831e41e936$export$479eef7c8f1b846c","dir1","dir2","v02","l1","l2","result","v0","v2","subVectors","d0232","d3210","v32","d3232","d0210","d1010","v10","denom","$1300ab831e41e936$export$b09f296caca7547a","paramResult","Vector2","temp1","temp2","target1","target2","at","closestPointToPoint","p2","closestPoint","distanceToSquared","closestPoint2","copy","$1300ab831e41e936$export$eed3a6606b3adc41","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","center","c","closestPoint1","distanceTo","closestPoint3","plane","getPlane","dp","abs","distanceToPoint","pp","projectPoint","cp","containsPoint","$277ed51eec8cb2f4$var$isNearZero","value","$277ed51eec8cb2f4$export$a37f7ec1c23dfacf","Triangle","args","isExtendedTriangle","satAxes","satBounds","Sphere","needsUpdate","intersectsSphere","update","axis0","sab0","getNormal","axis1","sab1","axis2","sab2","axis3","sab3","setFromNormalAndCoplanarPoint","closestPointToSegment","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","sqrt","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","dir","tempDir","edge1","edge2","tempPoint","triIntersectPlane","tri","targetEdge","startPointIntersection","delta","startIntersects","normal","doesIntersect","intersectLine","point","suppressLog","plane1","plane2","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","sa1","i2","sa2","crossVectors","console","warn","set","count1","count2","tmp","s1","e1","s2","e2","separated1","distanceToTriangle","cornerFields","line1","line2","lineTarget","getCenter","otherVec","thisVec","f11","f12","f21","f22","$2210a8ccded54a38$export$4ccecd8ac6ee0e58","matrix","isOrientedBox","Matrix4","invMatrix","alignedSatBounds","v","applyMatrix4","minVec","pi","invert","intersectsBox","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","clamp","distanceToBox","xyzFields","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","p1","f1","f2","f3","$4a3ee1d4de1c7643$export$bf300c504651112a","getNewPrimitive","_getNewPrimitive","_primitives","getPrimitive","primitives","pop","releasePrimitive","primitive","$a7a12bd8496afd7c$export$2622f4315304edad","$8c79b2483f36f80e$export$bc7cbaf27fbe938e","n16","uint16Array","$8c79b2483f36f80e$export$d61684373eacdf61","$00672725876edc9e$export$7451c73ce907854f","float32Array","uint32Array","stack","prevBuffer","setBuffer","buffer","Uint16Array","Uint32Array","clearBuffer","$59a851f097f5ef7e$var$boxStack","$59a851f097f5ef7e$var$boxPool","Box3","$452345387fe1f65a$var$temp","$452345387fe1f65a$var$temp1","$7db34e138f2585de$var$_vA","$7db34e138f2585de$var$_vB","$7db34e138f2585de$var$_vC","$7db34e138f2585de$var$_uvA","$7db34e138f2585de$var$_uvB","$7db34e138f2585de$var$_uvC","$7db34e138f2585de$var$_normalA","$7db34e138f2585de$var$_normalB","$7db34e138f2585de$var$_normalC","$7db34e138f2585de$var$_intersectionPoint","$7db34e138f2585de$export$1a557053019a130b","side","ray","intersections","triOffset","getX","uv","uv1","intersection","$7db34e138f2585de$var$checkBufferGeometryIntersection","fromBufferAttribute","$7db34e138f2585de$var$checkIntersection","pA","pB","pC","intersect","BackSide","intersectTriangle","DoubleSide","distance","origin","clone","getInterpolation","direction","multiplyScalar","face","materialIndex","faceIndex","$eb6f5960b3eb8549$export$32f7fa781964ae30","ta","tc","i0","getY","getZ","$9474092dcc9c56eb$export$be1391b7aa79c0f6","bvh","intersectsTriangleFunc","contained","depth","geometry","$d6886d66b20a1b65$export$8eb1eda96b2e6d7a","nodeIndices","isArray","indexArr","posAttr","byteOffset","roots","_roots","_traverse","node32Index","force","node16Index","isLeaf","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","byteLength","$c6fa00580fc66263$var$_boundingBox","$c6fa00580fc66263$export$d5a069a08bb68982","intersectBox","$06f35bd135b4cbcc$var$_boxIntersection","$06f35bd135b4cbcc$export$630e89aab3ddc1d6","root","intersects","$06f35bd135b4cbcc$var$_raycast","nodeIndex16","n32","_indirectBuffer","leftIndex","rightIndex","$8094198f7e753a2d$var$_boxIntersection","$8094198f7e753a2d$var$_xyzFields","$8094198f7e753a2d$export$1fa457bc72ef1a2a","$8094198f7e753a2d$var$_raycastFirst","res","c1","c2","splitAxis","xyzAxis","rayDir","leftToRight","c1Intersection","c1Result","isOutside","c2Intersection","c2Result","$40028eca76a25282$var$boundingBox","$40028eca76a25282$var$triangle","$40028eca76a25282$var$triangle2","$40028eca76a25282$var$invertedMat","$40028eca76a25282$var$obb","$40028eca76a25282$var$obb2","$40028eca76a25282$export$b2f96b0abaf94e0a","otherGeometry","geometryToBvh","$40028eca76a25282$var$_intersectsGeometry","cachedObb","boundingBox","computeBoundingBox","thisGeometry","thisIndex","thisPos","boundsTree","shapecast","intersectsBounds","leftIntersection","rightIntersection","$c82df4aa752dbd95$var$tempMatrix","$c82df4aa752dbd95$var$obb","$c82df4aa752dbd95$var$obb2","$c82df4aa752dbd95$var$temp1","$c82df4aa752dbd95$var$temp2","$c82df4aa752dbd95$var$temp3","$c82df4aa752dbd95$var$temp4","$c82df4aa752dbd95$export$5912902c175a555e","minThreshold","maxThreshold","otherPos","otherIndex","triangle2","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","boundsTraverseOrder","score","intersectsRange","otherBvh","otherOffset","otherCount","tempTargetDest1","sub","$15ccf80f37db9874$var$tempMatrix","$15ccf80f37db9874$var$aabb","$15ccf80f37db9874$var$aabb2","$15ccf80f37db9874$export$a2253c6980b92559","matrixToLocal","callbacks","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","iterateOverDoubleTriangles","offset1","offset2","depth1","index1","depth2","originalIntersectsRanges","getBoundingBox","nodeIndex1","nodeIndex2","$30624a994ba6e57c$export$dae1f8efdced590b","resolveTriangleIndex","$f4d14018db659d90$export$40f4af49b81ca898","j","$c34151c023e22e2c$var$_boxIntersection","$c34151c023e22e2c$export$1999205ebe856279","$c34151c023e22e2c$var$_raycast","$c27191358c129b43$var$_boxIntersection","$c27191358c129b43$var$_xyzFields","$c27191358c129b43$export$44e48d4cf2fe0609","$c27191358c129b43$var$_raycastFirst","$e7beda6ce58ad8bf$var$boundingBox","$e7beda6ce58ad8bf$var$triangle","$e7beda6ce58ad8bf$var$triangle2","$e7beda6ce58ad8bf$var$invertedMat","$e7beda6ce58ad8bf$var$obb","$e7beda6ce58ad8bf$var$obb2","$e7beda6ce58ad8bf$export$80dca0df80ee0084","$e7beda6ce58ad8bf$var$_intersectsGeometry","ti","$525a48157a09a04c$var$tempMatrix","$525a48157a09a04c$var$obb","$525a48157a09a04c$var$obb2","$525a48157a09a04c$var$temp1","$525a48157a09a04c$var$temp2","$525a48157a09a04c$var$temp3","$525a48157a09a04c$var$temp4","$525a48157a09a04c$export$334b669407b5ec06","ti2","$0cb92652a15353e8$var$tempMatrix","$0cb92652a15353e8$var$aabb","$0cb92652a15353e8$var$aabb2","$0cb92652a15353e8$export$4e2970292710be2c","ti1","$d1f63a316b8768c2$var$obb","$d1f63a316b8768c2$var$tempBox","$d1f63a316b8768c2$export$9d614b3bc2c4eacf","serialize","options","cloneBuffers","rootData","indexAttribute","getIndex","slice","deserialize","data","setIndex","indirect","Boolean","newIndex","BufferAttribute","isBufferGeometry","isInterleavedBufferAttribute","Object","assign","strategy","maxDepth","maxLeafTris","verbose","useSharedArrayBuffer","setBoundingBox","onProgress","SharedArrayBuffer","$1b5942106133d63e$var$generateIndirectBuffer","useUint32","byteCount","ArrayBuffer","vertexCount","finalGroup","total","forEach","BufferConstructor","$512bf92b30757ce0$export$62808f0201824da2","$1b5942106133d63e$var$buildTree","indexArray","totalTriangles","reachedMaxDepth","fullBounds","cacheCentroidBoundingData","normalized","posArr","bufferOffset","stride","getters","tri3","tri6","ai","bi","ci","el","halfExtents","el2","partionFunc","range","boundingData","splitNode","triggerProgress","trianglesProcessed","node","centroidBoundingData","nodeBoundingData","$62809835080ba262$var$getAverage","avg","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","axisRight","axisLength","binWidth","$62809835080ba262$var$BIN_COUNT","truncatedBins","bin","splitCount","splice","leftCount","rightCount","leftBounds","rightBounds","leftProb","rightProb","cost","triCenter","relativeCenter","binIndex","lastBin","source","nextBin","binCount","splitOffset","lcount","rcount","packedRoots","nodeCount","countNodes","populateBuffer","stride4Offset","stride2Offset","nextUnusedPointer","refit","refitFunc","traverse","callback","rootIndex","stopTraversal","raycast","materialOrSide","FrontSide","isMaterial","isArrayMaterial","raycastFunc","materialSide","startCount","jl","raycastFirst","closestResult","raycastFirstFunc","intersectsGeometry","geomToMesh","intersectsGeometryFunc","iterateFunc","originalIntersectsRange","nodeIndex","$59a851f097f5ef7e$var$shapecastTraverse","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","score1","score2","box1","box2","c1StopTraversal","c2StopTraversal","temp","isC1Leaf","getLeftOffset","getRightEndOffset","isC2Leaf","bvhcast","bvhcastFunc","boxToMesh","closestPointToGeometry","closestPointToGeometryFunc","minThresholdSq","maxThresholdSq","triIndex","makeEmpty","union","$3e2a3abaa10886a8$var$UP_VECTOR","$3e2a3abaa10886a8$var$_dir","$3e2a3abaa10886a8$export$97cada60b6f00a63","$3e2a3abaa10886a8$export$6ce1ecae0cd1cc55","line","triPoints","startMatches","endMatches","tp","$2cd02d3dec669c62$var$UP_VECTOR","$2cd02d3dec669c62$var$_v0","$2cd02d3dec669c62$var$_v1","$2cd02d3dec669c62$var$_normal","$2cd02d3dec669c62$var$_triangle","$627e7388cda991d0$var$_line","$627e7388cda991d0$export$84bed164e326c2f0","overlaps","overlap","prevOverlap","$aab05f562594c8e7$var$UP_VECTOR","$aab05f562594c8e7$var$_plane","$aab05f562594c8e7$var$_planeHit","$aab05f562594c8e7$var$_lineDirection","$485089c6d0563e10$var$_orthoPlane","$485089c6d0563e10$var$_edgeLine","$485089c6d0563e10$var$_point","$485089c6d0563e10$var$_vec","$485089c6d0563e10$var$_tri","$485089c6d0563e10$var$_line","$485089c6d0563e10$var$_triLine","$485089c6d0563e10$var$_dir","$485089c6d0563e10$var$_triDir","$e911a95ad6b2a32e$var$_dir","$e911a95ad6b2a32e$var$_v0","$e911a95ad6b2a32e$var$_v1","$f98ba1c508cee43d$var$_tri","$f98ba1c508cee43d$var$_line","$1481377db44180ba$var$UP_VECTOR","$1481377db44180ba$var$_beneathLine","$1481377db44180ba$var$_ray","Ray","$1481377db44180ba$var$_vec","$1481377db44180ba$var$_overlapLine","$1481377db44180ba$var$EdgeSet","edges","getLineGeometry","edgeArray","edgeGeom","BufferGeometry","edgeBuffer","setAttribute","$1481377db44180ba$export$4776387f3c0e5209","sortEdges","iterationTime","angleThreshold","includeIntersectionEdges","generateAsync","Promise","resolve","reject","signal","task","generate","run","aborted","next","done","requestAnimationFrame","projectionDir","thresholdAngle","thresholdDot","cos","MathUtils","DEG2RAD","getAttribute","indexCount","vertKeys","hashes","edgeData","round","jNext","vecHash0","vecHash1","v1","hash","reverseHash","otherNormal","meetsThreshold","normDot","otherDot","projectionThreshold","sign","index0","key","results","vertCount","time","performance","now","tri2","equals","concat","finalEdges","normalize","lowestLineY","highestLineY","hiddenOverlaps","distanceSq","highestTriangleY","lowestTriangleY","constant","startDist","endDist","isStartOnPlane","isStartBelow","isEndBelow","didHit","getArea","cross","intersectCount","endIntersects","edgeIntersects","overlapLine","overlapsTarget","invOverlaps","invOverlap","lerpVectors","progress","onmessage","prevTime","generator","currTime","postMessage","error","resultLines"],"version":3,"file":"projectionAsync.worker.28971622.js.map"}