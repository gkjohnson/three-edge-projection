{"version":3,"file":"SilhouetteGenerator-BthsVxbf.js","sources":["../../../node_modules/clipper2-js/fesm2020/clipper2-js.mjs","../../../src/utils/compressPoints.js","../../../src/utils/triangleIsInsidePaths.js","../../../src/SilhouetteGenerator.js"],"sourcesContent":["/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  15 October 2022                                                 *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2022                                         *\r\n* Purpose   :  Minkowski Sum and Difference                                    *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\nclass Minkowski {\r\n    static minkowskiInternal(pattern, path, isSum, isClosed) {\r\n        const delta = isClosed ? 0 : 1;\r\n        const patLen = pattern.length;\r\n        const pathLen = path.length;\r\n        const tmp = [];\r\n        for (const pathPt of path) {\r\n            const path2 = [];\r\n            if (isSum) {\r\n                for (const basePt of pattern)\r\n                    path2.push({ x: pathPt.x + basePt.x, y: pathPt.y + basePt.y });\r\n            }\r\n            else {\r\n                for (const basePt of pattern)\r\n                    path2.push({ x: pathPt.x - basePt.x, y: pathPt.y - basePt.y });\r\n            }\r\n            tmp.push(path2);\r\n        }\r\n        const result = [];\r\n        let g = isClosed ? pathLen - 1 : 0;\r\n        let h = patLen - 1;\r\n        for (let i = delta; i < pathLen; i++) {\r\n            for (let j = 0; j < patLen; j++) {\r\n                const quad = [tmp[g][h], tmp[i][h], tmp[i][j], tmp[g][j]];\r\n                if (!Clipper.isPositive(quad))\r\n                    result.push(Clipper.reversePath(quad));\r\n                else\r\n                    result.push(quad);\r\n                h = j;\r\n            }\r\n            g = i;\r\n        }\r\n        return result;\r\n    }\r\n    static sum(pattern, path, isClosed) {\r\n        return Clipper.Union(this.minkowskiInternal(pattern, path, true, isClosed), undefined, FillRule.NonZero);\r\n    }\r\n    static diff(pattern, path, isClosed) {\r\n        return Clipper.Union(this.minkowskiInternal(pattern, path, false, isClosed), undefined, FillRule.NonZero);\r\n    }\r\n}\n\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  7 August 2023                                                   *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  Path Offset (Inflate/Shrink)                                    *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\nvar JoinType;\r\n(function (JoinType) {\r\n    JoinType[JoinType[\"Square\"] = 0] = \"Square\";\r\n    JoinType[JoinType[\"Round\"] = 1] = \"Round\";\r\n    JoinType[JoinType[\"Miter\"] = 2] = \"Miter\";\r\n})(JoinType || (JoinType = {}));\r\nvar EndType;\r\n(function (EndType) {\r\n    EndType[EndType[\"Polygon\"] = 0] = \"Polygon\";\r\n    EndType[EndType[\"Joined\"] = 1] = \"Joined\";\r\n    EndType[EndType[\"Butt\"] = 2] = \"Butt\";\r\n    EndType[EndType[\"Square\"] = 3] = \"Square\";\r\n    EndType[EndType[\"Round\"] = 4] = \"Round\";\r\n})(EndType || (EndType = {}));\r\nclass Group {\r\n    constructor(paths, joinType, endType = EndType.Polygon) {\r\n        this.inPaths = [...paths]; // creates a shallow copy of paths\r\n        this.joinType = joinType;\r\n        this.endType = endType;\r\n        this.outPath = [];\r\n        this.outPaths = [];\r\n        this.pathsReversed = false;\r\n    }\r\n}\r\nclass PointD {\r\n    constructor(xOrPt, yOrScale) {\r\n        if (typeof xOrPt === 'number' && typeof yOrScale === 'number') {\r\n            this.x = xOrPt;\r\n            this.y = yOrScale;\r\n        }\r\n        else if (xOrPt instanceof PointD) {\r\n            if (yOrScale !== undefined) {\r\n                this.x = xOrPt.x * yOrScale;\r\n                this.y = xOrPt.y * yOrScale;\r\n            }\r\n            else {\r\n                this.x = xOrPt.x;\r\n                this.y = xOrPt.y;\r\n            }\r\n        }\r\n        else {\r\n            this.x = xOrPt.x * (yOrScale || 1);\r\n            this.y = xOrPt.y * (yOrScale || 1);\r\n        }\r\n    }\r\n    toString(precision = 2) {\r\n        return `${this.x.toFixed(precision)},${this.y.toFixed(precision)}`;\r\n    }\r\n    static equals(lhs, rhs) {\r\n        return InternalClipper.isAlmostZero(lhs.x - rhs.x) &&\r\n            InternalClipper.isAlmostZero(lhs.y - rhs.y);\r\n    }\r\n    static notEquals(lhs, rhs) {\r\n        return !InternalClipper.isAlmostZero(lhs.x - rhs.x) ||\r\n            !InternalClipper.isAlmostZero(lhs.y - rhs.y);\r\n    }\r\n    equals(obj) {\r\n        if (obj instanceof PointD) {\r\n            return PointD.equals(this, obj);\r\n        }\r\n        return false;\r\n    }\r\n    negate() {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n    }\r\n}\r\nclass ClipperOffset {\r\n    constructor(miterLimit = 2.0, arcTolerance = 0.0, preserveCollinear = false, reverseSolution = false) {\r\n        this._groupList = [];\r\n        this._normals = [];\r\n        this._solution = [];\r\n        this.MiterLimit = miterLimit;\r\n        this.ArcTolerance = arcTolerance;\r\n        this.MergeGroups = true;\r\n        this.PreserveCollinear = preserveCollinear;\r\n        this.ReverseSolution = reverseSolution;\r\n    }\r\n    clear() {\r\n        this._groupList = [];\r\n    }\r\n    addPath(path, joinType, endType) {\r\n        if (path.length === 0)\r\n            return;\r\n        const pp = [path];\r\n        this.addPaths(pp, joinType, endType);\r\n    }\r\n    addPaths(paths, joinType, endType) {\r\n        if (paths.length === 0)\r\n            return;\r\n        this._groupList.push(new Group(paths, joinType, endType));\r\n    }\r\n    executeInternal(delta) {\r\n        this._solution = [];\r\n        if (this._groupList.length === 0)\r\n            return;\r\n        if (Math.abs(delta) < 0.5) {\r\n            for (const group of this._groupList) {\r\n                for (const path of group.inPaths) {\r\n                    this._solution.push(path);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._delta = delta;\r\n            this._mitLimSqr = (this.MiterLimit <= 1 ? 2.0 : 2.0 / this.sqr(this.MiterLimit));\r\n            for (const group of this._groupList) {\r\n                this.doGroupOffset(group);\r\n            }\r\n        }\r\n    }\r\n    sqr(value) {\r\n        return value * value;\r\n    }\r\n    execute(delta, solution) {\r\n        solution.length = 0;\r\n        this.executeInternal(delta);\r\n        if (this._groupList.length === 0)\r\n            return;\r\n        // clean up self-intersections ...\r\n        const c = new Clipper64();\r\n        c.preserveCollinear = this.PreserveCollinear;\r\n        // the solution should retain the orientation of the input\r\n        c.reverseSolution = this.ReverseSolution !== this._groupList[0].pathsReversed;\r\n        c.addSubjectPaths(this._solution);\r\n        if (this._groupList[0].pathsReversed)\r\n            c.execute(ClipType.Union, FillRule.Negative, solution);\r\n        else\r\n            c.execute(ClipType.Union, FillRule.Positive, solution);\r\n    }\r\n    executePolytree(delta, polytree) {\r\n        polytree.clear();\r\n        this.executeInternal(delta);\r\n        if (this._groupList.length === 0)\r\n            return;\r\n        // clean up self-intersections ...\r\n        const c = new Clipper64();\r\n        c.preserveCollinear = this.PreserveCollinear;\r\n        // the solution should retain the orientation of the input\r\n        c.reverseSolution = this.ReverseSolution !== this._groupList[0].pathsReversed;\r\n        c.addSubjectPaths(this._solution);\r\n        if (this._groupList[0].pathsReversed)\r\n            c.executePolyTree(ClipType.Union, FillRule.Negative, polytree);\r\n        else\r\n            c.executePolyTree(ClipType.Union, FillRule.Positive, polytree);\r\n    }\r\n    static getUnitNormal(pt1, pt2) {\r\n        let dx = pt2.x - pt1.x;\r\n        let dy = pt2.y - pt1.y;\r\n        if (dx === 0 && dy === 0)\r\n            return new PointD(0, 0);\r\n        const f = 1.0 / Math.sqrt(dx * dx + dy * dy);\r\n        dx *= f;\r\n        dy *= f;\r\n        return new PointD(dy, -dx);\r\n    }\r\n    executeCallback(deltaCallback, solution) {\r\n        this.DeltaCallback = deltaCallback;\r\n        this.execute(1.0, solution);\r\n    }\r\n    static getBoundsAndLowestPolyIdx(paths) {\r\n        const rec = new Rect64(false); // ie invalid rect\r\n        let lpX = Number.MIN_SAFE_INTEGER;\r\n        let index = -1;\r\n        for (let i = 0; i < paths.length; i++) {\r\n            for (const pt of paths[i]) {\r\n                if (pt.y >= rec.bottom) {\r\n                    if (pt.y > rec.bottom || pt.x < lpX) {\r\n                        index = i;\r\n                        lpX = pt.x;\r\n                        rec.bottom = pt.y;\r\n                    }\r\n                }\r\n                else if (pt.y < rec.top)\r\n                    rec.top = pt.y;\r\n                if (pt.x > rec.right)\r\n                    rec.right = pt.x;\r\n                else if (pt.x < rec.left)\r\n                    rec.left = pt.x;\r\n            }\r\n        }\r\n        return { index, rec };\r\n    }\r\n    static translatePoint(pt, dx, dy) {\r\n        return new PointD(pt.x + dx, pt.y + dy);\r\n    }\r\n    static reflectPoint(pt, pivot) {\r\n        return new PointD(pivot.x + (pivot.x - pt.x), pivot.y + (pivot.y - pt.y));\r\n    }\r\n    static almostZero(value, epsilon = 0.001) {\r\n        return Math.abs(value) < epsilon;\r\n    }\r\n    static hypotenuse(x, y) {\r\n        return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n    }\r\n    static normalizeVector(vec) {\r\n        const h = this.hypotenuse(vec.x, vec.y);\r\n        if (this.almostZero(h))\r\n            return new PointD(0, 0);\r\n        const inverseHypot = 1 / h;\r\n        return new PointD(vec.x * inverseHypot, vec.y * inverseHypot);\r\n    }\r\n    static getAvgUnitVector(vec1, vec2) {\r\n        return this.normalizeVector(new PointD(vec1.x + vec2.x, vec1.y + vec2.y));\r\n    }\r\n    static intersectPoint(pt1a, pt1b, pt2a, pt2b) {\r\n        if (InternalClipper.isAlmostZero(pt1a.x - pt1b.x)) { //vertical\r\n            if (InternalClipper.isAlmostZero(pt2a.x - pt2b.x))\r\n                return new PointD(0, 0);\r\n            const m2 = (pt2b.y - pt2a.y) / (pt2b.x - pt2a.x);\r\n            const b2 = pt2a.y - m2 * pt2a.x;\r\n            return new PointD(pt1a.x, m2 * pt1a.x + b2);\r\n        }\r\n        if (InternalClipper.isAlmostZero(pt2a.x - pt2b.x)) { //vertical\r\n            const m1 = (pt1b.y - pt1a.y) / (pt1b.x - pt1a.x);\r\n            const b1 = pt1a.y - m1 * pt1a.x;\r\n            return new PointD(pt2a.x, m1 * pt2a.x + b1);\r\n        }\r\n        else {\r\n            const m1 = (pt1b.y - pt1a.y) / (pt1b.x - pt1a.x);\r\n            const b1 = pt1a.y - m1 * pt1a.x;\r\n            const m2 = (pt2b.y - pt2a.y) / (pt2b.x - pt2a.x);\r\n            const b2 = pt2a.y - m2 * pt2a.x;\r\n            if (InternalClipper.isAlmostZero(m1 - m2))\r\n                return new PointD(0, 0);\r\n            const x = (b2 - b1) / (m1 - m2);\r\n            return new PointD(x, m1 * x + b1);\r\n        }\r\n    }\r\n    getPerpendic(pt, norm) {\r\n        return new Point64(pt.x + norm.x * this._groupDelta, pt.y + norm.y * this._groupDelta);\r\n    }\r\n    getPerpendicD(pt, norm) {\r\n        return new PointD(pt.x + norm.x * this._groupDelta, pt.y + norm.y * this._groupDelta);\r\n    }\r\n    doSquare(group, path, j, k) {\r\n        let vec;\r\n        if (j === k) {\r\n            vec = new PointD(this._normals[j].y, -this._normals[j].x);\r\n        }\r\n        else {\r\n            vec = ClipperOffset.getAvgUnitVector(new PointD(-this._normals[k].y, this._normals[k].x), new PointD(this._normals[j].y, -this._normals[j].x));\r\n        }\r\n        const absDelta = Math.abs(this._groupDelta);\r\n        // now offset the original vertex delta units along unit vector\r\n        let ptQ = new PointD(path[j].x, path[j].y);\r\n        ptQ = ClipperOffset.translatePoint(ptQ, absDelta * vec.x, absDelta * vec.y);\r\n        // get perpendicular vertices\r\n        const pt1 = ClipperOffset.translatePoint(ptQ, this._groupDelta * vec.y, this._groupDelta * -vec.x);\r\n        const pt2 = ClipperOffset.translatePoint(ptQ, this._groupDelta * -vec.y, this._groupDelta * vec.x);\r\n        // get 2 vertices along one edge offset\r\n        const pt3 = this.getPerpendicD(path[k], this._normals[k]);\r\n        if (j === k) {\r\n            const pt4 = new PointD(pt3.x + vec.x * this._groupDelta, pt3.y + vec.y * this._groupDelta);\r\n            const pt = ClipperOffset.intersectPoint(pt1, pt2, pt3, pt4);\r\n            //get the second intersect point through reflection\r\n            group.outPath.push(new Point64(ClipperOffset.reflectPoint(pt, ptQ).x, ClipperOffset.reflectPoint(pt, ptQ).y));\r\n            group.outPath.push(new Point64(pt.x, pt.y));\r\n        }\r\n        else {\r\n            const pt4 = this.getPerpendicD(path[j], this._normals[k]);\r\n            const pt = ClipperOffset.intersectPoint(pt1, pt2, pt3, pt4);\r\n            group.outPath.push(new Point64(pt.x, pt.y));\r\n            //get the second intersect point through reflection\r\n            group.outPath.push(new Point64(ClipperOffset.reflectPoint(pt, ptQ).x, ClipperOffset.reflectPoint(pt, ptQ).y));\r\n        }\r\n    }\r\n    doMiter(group, path, j, k, cosA) {\r\n        const q = this._groupDelta / (cosA + 1);\r\n        group.outPath.push(new Point64(path[j].x + (this._normals[k].x + this._normals[j].x) * q, path[j].y + (this._normals[k].y + this._normals[j].y) * q));\r\n    }\r\n    doRound(group, path, j, k, angle) {\r\n        if (typeof this.DeltaCallback !== \"undefined\") {\r\n            const absDelta = Math.abs(this._groupDelta);\r\n            const arcTol = this.ArcTolerance > 0.01\r\n                ? this.ArcTolerance\r\n                : Math.log10(2 + absDelta) * InternalClipper.defaultArcTolerance;\r\n            const stepsPer360 = Math.PI / Math.acos(1 - arcTol / absDelta);\r\n            this._stepSin = Math.sin((2 * Math.PI) / stepsPer360);\r\n            this._stepCos = Math.cos((2 * Math.PI) / stepsPer360);\r\n            if (this._groupDelta < 0.0)\r\n                this._stepSin = -this._stepSin;\r\n            this._stepsPerRad = stepsPer360 / (2 * Math.PI);\r\n        }\r\n        const pt = path[j];\r\n        let offsetVec = new PointD(this._normals[k].x * this._groupDelta, this._normals[k].y * this._groupDelta);\r\n        if (j === k)\r\n            offsetVec.negate();\r\n        group.outPath.push(new Point64(pt.x + offsetVec.x, pt.y + offsetVec.y));\r\n        if (angle > -Math.PI + 0.01) {\r\n            const steps = Math.ceil(this._stepsPerRad * Math.abs(angle));\r\n            for (let i = 1; i < steps; i++) {\r\n                offsetVec = new PointD(offsetVec.x * this._stepCos - this._stepSin * offsetVec.y, offsetVec.x * this._stepSin + offsetVec.y * this._stepCos);\r\n                group.outPath.push(new Point64(pt.x + offsetVec.x, pt.y + offsetVec.y));\r\n            }\r\n        }\r\n        group.outPath.push(this.getPerpendic(pt, this._normals[j]));\r\n    }\r\n    buildNormals(path) {\r\n        const cnt = path.length;\r\n        this._normals = [];\r\n        this._normals.length = cnt;\r\n        for (let i = 0; i < cnt - 1; i++) {\r\n            this._normals.push(ClipperOffset.getUnitNormal(path[i], path[i + 1]));\r\n        }\r\n        this._normals.push(ClipperOffset.getUnitNormal(path[cnt - 1], path[0]));\r\n    }\r\n    crossProduct(vec1, vec2) {\r\n        return (vec1.y * vec2.x - vec2.y * vec1.x);\r\n    }\r\n    dotProduct(vec1, vec2) {\r\n        return (vec1.x * vec2.x + vec1.y * vec2.y);\r\n    }\r\n    offsetPoint(group, path, j, k) {\r\n        const sinA = this.crossProduct(this._normals[j], this._normals[k]);\r\n        let cosA = this.dotProduct(this._normals[j], this._normals[k]);\r\n        if (sinA > 1.0)\r\n            cosA = 1.0;\r\n        else if (sinA < -1.0)\r\n            cosA = -1.0;\r\n        if (typeof this.DeltaCallback !== \"undefined\") {\r\n            this._groupDelta = this.DeltaCallback(path, this._normals, j, k);\r\n            if (group.pathsReversed)\r\n                this._groupDelta = -this._groupDelta;\r\n        }\r\n        if (Math.abs(this._groupDelta) < ClipperOffset.Tolerance) {\r\n            group.outPath.push(path[j]);\r\n            return;\r\n        }\r\n        if (cosA > 0.999) {\r\n            this.doMiter(group, path, j, k, cosA);\r\n        }\r\n        else if (cosA > -0.99 && (sinA * this._groupDelta < 0)) {\r\n            group.outPath.push(this.getPerpendic(path[j], this._normals[k]));\r\n            group.outPath.push(path[j]);\r\n            group.outPath.push(this.getPerpendic(path[j], this._normals[j]));\r\n        }\r\n        else if (this._joinType === JoinType.Miter) {\r\n            if (cosA > this._mitLimSqr - 1) {\r\n                this.doMiter(group, path, j, k, cosA);\r\n            }\r\n            else {\r\n                this.doSquare(group, path, j, k);\r\n            }\r\n        }\r\n        else if (cosA > 0.99 || this._joinType === JoinType.Square) {\r\n            this.doSquare(group, path, j, k);\r\n        }\r\n        else {\r\n            this.doRound(group, path, j, k, Math.atan2(sinA, cosA));\r\n        }\r\n        k = j;\r\n    }\r\n    offsetPolygon(group, path) {\r\n        const area = Clipper.area(path);\r\n        if ((area < 0) !== (this._groupDelta < 0)) {\r\n            const rect = Clipper.getBounds(path);\r\n            if (Math.abs(this._groupDelta) * 2 > rect.width)\r\n                return;\r\n        }\r\n        group.outPath = [];\r\n        const cnt = path.length;\r\n        const prev = cnt - 1;\r\n        for (let i = 0; i < cnt; i++) {\r\n            this.offsetPoint(group, path, i, prev);\r\n        }\r\n        group.outPaths.push(group.outPath);\r\n    }\r\n    offsetOpenJoined(group, path) {\r\n        this.offsetPolygon(group, path);\r\n        path = Clipper.reversePath(path);\r\n        this.buildNormals(path);\r\n        this.offsetPolygon(group, path);\r\n    }\r\n    offsetOpenPath(group, path) {\r\n        group.outPath = [];\r\n        const highI = path.length - 1;\r\n        if (typeof this.DeltaCallback !== \"undefined\") {\r\n            this._groupDelta = this.DeltaCallback(path, this._normals, 0, 0);\r\n        }\r\n        if (Math.abs(this._groupDelta) < ClipperOffset.Tolerance) {\r\n            group.outPath.push(path[0]);\r\n        }\r\n        else {\r\n            switch (this._endType) {\r\n                case EndType.Butt:\r\n                    group.outPath.push(new Point64(path[0].x - this._normals[0].x * this._groupDelta, path[0].y - this._normals[0].y * this._groupDelta));\r\n                    group.outPath.push(this.getPerpendic(path[0], this._normals[0]));\r\n                    break;\r\n                case EndType.Round:\r\n                    this.doRound(group, path, 0, 0, Math.PI);\r\n                    break;\r\n                default:\r\n                    this.doSquare(group, path, 0, 0);\r\n                    break;\r\n            }\r\n        }\r\n        for (let i = 1, k = 0; i < highI; i++) {\r\n            this.offsetPoint(group, path, i, k);\r\n        }\r\n        for (let i = highI; i > 0; i--) {\r\n            this._normals[i] = new PointD(-this._normals[i - 1].x, -this._normals[i - 1].y);\r\n        }\r\n        this._normals[0] = this._normals[highI];\r\n        if (typeof this.DeltaCallback !== \"undefined\") {\r\n            this._groupDelta = this.DeltaCallback(path, this._normals, highI, highI);\r\n        }\r\n        if (Math.abs(this._groupDelta) < ClipperOffset.Tolerance) {\r\n            group.outPath.push(path[highI]);\r\n        }\r\n        else {\r\n            switch (this._endType) {\r\n                case EndType.Butt:\r\n                    group.outPath.push(new Point64(path[highI].x - this._normals[highI].x * this._groupDelta, path[highI].y - this._normals[highI].y * this._groupDelta));\r\n                    group.outPath.push(this.getPerpendic(path[highI], this._normals[highI]));\r\n                    break;\r\n                case EndType.Round:\r\n                    this.doRound(group, path, highI, highI, Math.PI);\r\n                    break;\r\n                default:\r\n                    this.doSquare(group, path, highI, highI);\r\n                    break;\r\n            }\r\n        }\r\n        for (let i = highI, k = 0; i > 0; i--) {\r\n            this.offsetPoint(group, path, i, k);\r\n        }\r\n        group.outPaths.push(group.outPath);\r\n    }\r\n    doGroupOffset(group) {\r\n        if (group.endType == EndType.Polygon) {\r\n            const { index } = ClipperOffset.getBoundsAndLowestPolyIdx(group.inPaths);\r\n            if (index < 0)\r\n                return;\r\n            const area = Clipper.area(group.inPaths[index]);\r\n            group.pathsReversed = area < 0;\r\n            if (group.pathsReversed) {\r\n                this._groupDelta = -this._delta;\r\n            }\r\n            else {\r\n                this._groupDelta = this._delta;\r\n            }\r\n        }\r\n        else {\r\n            group.pathsReversed = false;\r\n            this._groupDelta = Math.abs(this._delta) * 0.5;\r\n        }\r\n        const absDelta = Math.abs(this._groupDelta);\r\n        this._joinType = group.joinType;\r\n        this._endType = group.endType;\r\n        if (!this.DeltaCallback &&\r\n            (group.joinType == JoinType.Round || group.endType == EndType.Round)) {\r\n            const arcTol = this.ArcTolerance > 0.01\r\n                ? this.ArcTolerance\r\n                : Math.log10(2 + absDelta) * InternalClipper.defaultArcTolerance;\r\n            const stepsPer360 = Math.PI / Math.acos(1 - arcTol / absDelta);\r\n            this._stepSin = Math.sin((2 * Math.PI) / stepsPer360);\r\n            this._stepCos = Math.cos((2 * Math.PI) / stepsPer360);\r\n            if (this._groupDelta < 0.0) {\r\n                this._stepSin = -this._stepSin;\r\n            }\r\n            this._stepsPerRad = stepsPer360 / (2 * Math.PI);\r\n        }\r\n        const isJoined = group.endType == EndType.Joined || group.endType == EndType.Polygon;\r\n        for (const p of group.inPaths) {\r\n            const path = Clipper.stripDuplicates(p, isJoined);\r\n            const cnt = path.length;\r\n            if (cnt === 0 || (cnt < 3 && this._endType == EndType.Polygon)) {\r\n                continue;\r\n            }\r\n            if (cnt == 1) {\r\n                group.outPath = [];\r\n                if (group.endType == EndType.Round) {\r\n                    const r = absDelta;\r\n                    group.outPath = Clipper.ellipse(path[0], r, r);\r\n                }\r\n                else {\r\n                    const d = Math.ceil(this._groupDelta);\r\n                    const r = new Rect64(path[0].x - d, path[0].y - d, path[0].x - d, path[0].y - d);\r\n                    group.outPath = r.asPath();\r\n                }\r\n                group.outPaths.push(group.outPath);\r\n            }\r\n            else {\r\n                if (cnt == 2 && group.endType == EndType.Joined) {\r\n                    if (group.joinType == JoinType.Round) {\r\n                        this._endType = EndType.Round;\r\n                    }\r\n                    else {\r\n                        this._endType = EndType.Square;\r\n                    }\r\n                }\r\n                this.buildNormals(path);\r\n                if (this._endType == EndType.Polygon) {\r\n                    this.offsetPolygon(group, path);\r\n                }\r\n                else if (this._endType == EndType.Joined) {\r\n                    this.offsetOpenJoined(group, path);\r\n                }\r\n                else {\r\n                    this.offsetOpenPath(group, path);\r\n                }\r\n            }\r\n        }\r\n        this._solution.push(...group.outPaths);\r\n        group.outPaths = [];\r\n    }\r\n}\r\nClipperOffset.Tolerance = 1.0E-12;\n\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  6 August 2023                                                   *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  FAST rectangular clipping                                       *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\nclass OutPt2 {\r\n    constructor(pt) {\r\n        this.pt = pt;\r\n        this.ownerIdx = 0;\r\n    }\r\n}\r\nvar Location;\r\n(function (Location) {\r\n    Location[Location[\"left\"] = 0] = \"left\";\r\n    Location[Location[\"top\"] = 1] = \"top\";\r\n    Location[Location[\"right\"] = 2] = \"right\";\r\n    Location[Location[\"bottom\"] = 3] = \"bottom\";\r\n    Location[Location[\"inside\"] = 4] = \"inside\";\r\n})(Location || (Location = {}));\r\nclass RectClip64 {\r\n    constructor(rect) {\r\n        this.currIdx = -1;\r\n        this.rect = rect;\r\n        this.mp = rect.midPoint();\r\n        this.rectPath = rect.asPath();\r\n        this.results = [];\r\n        this.edges = Array(8).fill(undefined).map(() => []);\r\n    }\r\n    add(pt, startingNewPath = false) {\r\n        let currIdx = this.results.length;\r\n        let result;\r\n        if (currIdx === 0 || startingNewPath) {\r\n            result = new OutPt2(pt);\r\n            this.results.push(result);\r\n            result.ownerIdx = currIdx;\r\n            result.prev = result;\r\n            result.next = result;\r\n        }\r\n        else {\r\n            currIdx--;\r\n            const prevOp = this.results[currIdx];\r\n            if (prevOp.pt === pt)\r\n                return prevOp;\r\n            result = new OutPt2(pt);\r\n            result.ownerIdx = currIdx;\r\n            result.next = prevOp.next;\r\n            prevOp.next.prev = result;\r\n            prevOp.next = result;\r\n            result.prev = prevOp;\r\n            this.results[currIdx] = result;\r\n        }\r\n        return result;\r\n    }\r\n    static path1ContainsPath2(path1, path2) {\r\n        let ioCount = 0;\r\n        for (const pt of path2) {\r\n            const pip = InternalClipper.pointInPolygon(pt, path1);\r\n            switch (pip) {\r\n                case PointInPolygonResult.IsInside:\r\n                    ioCount--;\r\n                    break;\r\n                case PointInPolygonResult.IsOutside:\r\n                    ioCount++;\r\n                    break;\r\n            }\r\n            if (Math.abs(ioCount) > 1)\r\n                break;\r\n        }\r\n        return ioCount <= 0;\r\n    }\r\n    static isClockwise(prev, curr, prevPt, currPt, rectMidPoint) {\r\n        if (this.areOpposites(prev, curr))\r\n            return InternalClipper.crossProduct(prevPt, rectMidPoint, currPt) < 0;\r\n        else\r\n            return this.headingClockwise(prev, curr);\r\n    }\r\n    static areOpposites(prev, curr) {\r\n        return Math.abs(prev - curr) === 2;\r\n    }\r\n    static headingClockwise(prev, curr) {\r\n        return (prev + 1) % 4 === curr;\r\n    }\r\n    static getAdjacentLocation(loc, isClockwise) {\r\n        const delta = isClockwise ? 1 : 3;\r\n        return (loc + delta) % 4;\r\n    }\r\n    static unlinkOp(op) {\r\n        if (op.next === op)\r\n            return undefined;\r\n        op.prev.next = op.next;\r\n        op.next.prev = op.prev;\r\n        return op.next;\r\n    }\r\n    static unlinkOpBack(op) {\r\n        if (op.next === op)\r\n            return undefined;\r\n        op.prev.next = op.next;\r\n        op.next.prev = op.prev;\r\n        return op.prev;\r\n    }\r\n    static getEdgesForPt(pt, rec) {\r\n        let result = 0;\r\n        if (pt.x === rec.left)\r\n            result = 1;\r\n        else if (pt.x === rec.right)\r\n            result = 4;\r\n        if (pt.y === rec.top)\r\n            result += 2;\r\n        else if (pt.y === rec.bottom)\r\n            result += 8;\r\n        return result;\r\n    }\r\n    static isHeadingClockwise(pt1, pt2, edgeIdx) {\r\n        switch (edgeIdx) {\r\n            case 0: return pt2.y < pt1.y;\r\n            case 1: return pt2.x > pt1.x;\r\n            case 2: return pt2.y > pt1.y;\r\n            default: return pt2.x < pt1.x;\r\n        }\r\n    }\r\n    static hasHorzOverlap(left1, right1, left2, right2) {\r\n        return (left1.x < right2.x) && (right1.x > left2.x);\r\n    }\r\n    static hasVertOverlap(top1, bottom1, top2, bottom2) {\r\n        return (top1.y < bottom2.y) && (bottom1.y > top2.y);\r\n    }\r\n    static addToEdge(edge, op) {\r\n        if (op.edge)\r\n            return;\r\n        op.edge = edge;\r\n        edge.push(op);\r\n    }\r\n    static uncoupleEdge(op) {\r\n        if (!op.edge)\r\n            return;\r\n        for (let i = 0; i < op.edge.length; i++) {\r\n            const op2 = op.edge[i];\r\n            if (op2 === op) {\r\n                op.edge[i] = undefined;\r\n                break;\r\n            }\r\n        }\r\n        op.edge = undefined;\r\n    }\r\n    static setNewOwner(op, newIdx) {\r\n        op.ownerIdx = newIdx;\r\n        let op2 = op.next;\r\n        while (op2 !== op) {\r\n            op2.ownerIdx = newIdx;\r\n            op2 = op2.next;\r\n        }\r\n    }\r\n    addCorner(prev, curr) {\r\n        if (RectClip64.headingClockwise(prev, curr))\r\n            this.add(this.rectPath[prev]);\r\n        else\r\n            this.add(this.rectPath[curr]);\r\n    }\r\n    addCornerByRef(loc, isClockwise) {\r\n        if (isClockwise) {\r\n            this.add(this.rectPath[loc]);\r\n            loc = RectClip64.getAdjacentLocation(loc, true);\r\n        }\r\n        else {\r\n            loc = RectClip64.getAdjacentLocation(loc, false);\r\n            this.add(this.rectPath[loc]);\r\n        }\r\n    }\r\n    static getLocation(rec, pt) {\r\n        let loc;\r\n        if (pt.x === rec.left && pt.y >= rec.top && pt.y <= rec.bottom) {\r\n            loc = Location.left; // pt on rec\r\n            return { success: false, loc };\r\n        }\r\n        if (pt.x === rec.right && pt.y >= rec.top && pt.y <= rec.bottom) {\r\n            loc = Location.right; // pt on rec\r\n            return { success: false, loc };\r\n        }\r\n        if (pt.y === rec.top && pt.x >= rec.left && pt.x <= rec.right) {\r\n            loc = Location.top; // pt on rec\r\n            return { success: false, loc };\r\n        }\r\n        if (pt.y === rec.bottom && pt.x >= rec.left && pt.x <= rec.right) {\r\n            loc = Location.bottom; // pt on rec\r\n            return { success: false, loc };\r\n        }\r\n        if (pt.x < rec.left)\r\n            loc = Location.left;\r\n        else if (pt.x > rec.right)\r\n            loc = Location.right;\r\n        else if (pt.y < rec.top)\r\n            loc = Location.top;\r\n        else if (pt.y > rec.bottom)\r\n            loc = Location.bottom;\r\n        else\r\n            loc = Location.inside;\r\n        return { success: true, loc };\r\n    }\r\n    static getIntersection(rectPath, p, p2, loc) {\r\n        // gets the pt of intersection between rectPath and segment(p, p2) that's closest to 'p'\r\n        // when result == false, loc will remain unchanged\r\n        let ip = new Point64();\r\n        switch (loc) {\r\n            case Location.left:\r\n                if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n                }\r\n                else if (p.y < rectPath[0].y && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n                    loc = Location.top;\r\n                }\r\n                else if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n                    loc = Location.bottom;\r\n                }\r\n                else {\r\n                    return { success: false, loc, ip };\r\n                }\r\n                break;\r\n            case Location.right:\r\n                if (InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n                }\r\n                else if (p.y < rectPath[0].y && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n                    loc = Location.top;\r\n                }\r\n                else if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n                    loc = Location.bottom;\r\n                }\r\n                else {\r\n                    return { success: false, loc, ip };\r\n                }\r\n                break;\r\n            case Location.top:\r\n                if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n                }\r\n                else if (p.x < rectPath[0].x && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n                    loc = Location.left;\r\n                }\r\n                else if (p.x > rectPath[1].x && InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n                    loc = Location.right;\r\n                }\r\n                else {\r\n                    return { success: false, loc, ip };\r\n                }\r\n                break;\r\n            case Location.bottom:\r\n                if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n                }\r\n                else if (p.x < rectPath[3].x && InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n                    loc = Location.left;\r\n                }\r\n                else if (p.x > rectPath[2].x && InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n                    loc = Location.right;\r\n                }\r\n                else {\r\n                    return { success: false, loc, ip };\r\n                }\r\n                break;\r\n            case Location.inside:\r\n                if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[3]).ip;\r\n                    loc = Location.left;\r\n                }\r\n                else if (InternalClipper.segsIntersect(p, p2, rectPath[0], rectPath[1], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[0], rectPath[1]).ip;\r\n                    loc = Location.top;\r\n                }\r\n                else if (InternalClipper.segsIntersect(p, p2, rectPath[1], rectPath[2], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[1], rectPath[2]).ip;\r\n                    loc = Location.right;\r\n                }\r\n                else if (InternalClipper.segsIntersect(p, p2, rectPath[2], rectPath[3], true)) {\r\n                    ip = InternalClipper.getIntersectPt(p, p2, rectPath[2], rectPath[3]).ip;\r\n                    loc = Location.bottom;\r\n                }\r\n                else {\r\n                    return { success: false, loc, ip };\r\n                }\r\n                break;\r\n        }\r\n        return { success: true, loc, ip };\r\n    }\r\n    getNextLocation(path, context) {\r\n        switch (context.loc) {\r\n            case Location.left:\r\n                while (context.i <= context.highI && path[context.i].x <= this.rect.left)\r\n                    context.i++;\r\n                if (context.i > context.highI)\r\n                    break;\r\n                if (path[context.i].x >= this.rect.right)\r\n                    context.loc = Location.right;\r\n                else if (path[context.i].y <= this.rect.top)\r\n                    context.loc = Location.top;\r\n                else if (path[context.i].y >= this.rect.bottom)\r\n                    context.loc = Location.bottom;\r\n                else\r\n                    context.loc = Location.inside;\r\n                break;\r\n            case Location.top:\r\n                while (context.i <= context.highI && path[context.i].y <= this.rect.top)\r\n                    context.i++;\r\n                if (context.i > context.highI)\r\n                    break;\r\n                if (path[context.i].y >= this.rect.bottom)\r\n                    context.loc = Location.bottom;\r\n                else if (path[context.i].x <= this.rect.left)\r\n                    context.loc = Location.left;\r\n                else if (path[context.i].x >= this.rect.right)\r\n                    context.loc = Location.right;\r\n                else\r\n                    context.loc = Location.inside;\r\n                break;\r\n            case Location.right:\r\n                while (context.i <= context.highI && path[context.i].x >= this.rect.right)\r\n                    context.i++;\r\n                if (context.i > context.highI)\r\n                    break;\r\n                if (path[context.i].x <= this.rect.left)\r\n                    context.loc = Location.left;\r\n                else if (path[context.i].y <= this.rect.top)\r\n                    context.loc = Location.top;\r\n                else if (path[context.i].y >= this.rect.bottom)\r\n                    context.loc = Location.bottom;\r\n                else\r\n                    context.loc = Location.inside;\r\n                break;\r\n            case Location.bottom:\r\n                while (context.i <= context.highI && path[context.i].y >= this.rect.bottom)\r\n                    context.i++;\r\n                if (context.i > context.highI)\r\n                    break;\r\n                if (path[context.i].y <= this.rect.top)\r\n                    context.loc = Location.top;\r\n                else if (path[context.i].x <= this.rect.left)\r\n                    context.loc = Location.left;\r\n                else if (path[context.i].x >= this.rect.right)\r\n                    context.loc = Location.right;\r\n                else\r\n                    context.loc = Location.inside;\r\n                break;\r\n            case Location.inside:\r\n                while (context.i <= context.highI) {\r\n                    if (path[context.i].x < this.rect.left)\r\n                        context.loc = Location.left;\r\n                    else if (path[context.i].x > this.rect.right)\r\n                        context.loc = Location.right;\r\n                    else if (path[context.i].y > this.rect.bottom)\r\n                        context.loc = Location.bottom;\r\n                    else if (path[context.i].y < this.rect.top)\r\n                        context.loc = Location.top;\r\n                    else {\r\n                        this.add(path[context.i]);\r\n                        context.i++;\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    executeInternal(path) {\r\n        if (path.length < 3 || this.rect.isEmpty())\r\n            return;\r\n        const startLocs = [];\r\n        let firstCross = Location.inside;\r\n        let crossingLoc = firstCross, prev = firstCross;\r\n        let i;\r\n        const highI = path.length - 1;\r\n        let result = RectClip64.getLocation(this.rect, path[highI]);\r\n        let loc = result.loc;\r\n        if (!result.success) {\r\n            i = highI - 1;\r\n            while (i >= 0 && !result.success) {\r\n                i--;\r\n                result = RectClip64.getLocation(this.rect, path[i]);\r\n                prev = result.loc;\r\n            }\r\n            if (i < 0) {\r\n                for (const pt of path) {\r\n                    this.add(pt);\r\n                }\r\n                return;\r\n            }\r\n            if (prev == Location.inside)\r\n                loc = Location.inside;\r\n        }\r\n        const startingLoc = loc;\r\n        ///////////////////////////////////////////////////\r\n        i = 0;\r\n        while (i <= highI) {\r\n            prev = loc;\r\n            const prevCrossLoc = crossingLoc;\r\n            this.getNextLocation(path, { loc, i, highI });\r\n            if (i > highI)\r\n                break;\r\n            const prevPt = (i == 0) ? path[highI] : path[i - 1];\r\n            crossingLoc = loc;\r\n            let result = RectClip64.getIntersection(this.rectPath, path[i], prevPt, crossingLoc);\r\n            const ip = result.ip;\r\n            if (!result.success) {\r\n                if (prevCrossLoc == Location.inside) {\r\n                    const isClockw = RectClip64.isClockwise(prev, loc, prevPt, path[i], this.mp);\r\n                    do {\r\n                        startLocs.push(prev);\r\n                        prev = RectClip64.getAdjacentLocation(prev, isClockw);\r\n                    } while (prev != loc);\r\n                    crossingLoc = prevCrossLoc;\r\n                }\r\n                else if (prev != Location.inside && prev != loc) {\r\n                    const isClockw = RectClip64.isClockwise(prev, loc, prevPt, path[i], this.mp);\r\n                    do {\r\n                        this.addCornerByRef(prev, isClockw);\r\n                    } while (prev != loc);\r\n                }\r\n                ++i;\r\n                continue;\r\n            }\r\n            ////////////////////////////////////////////////////\r\n            // we must be crossing the rect boundary to get here\r\n            ////////////////////////////////////////////////////\r\n            if (loc == Location.inside) {\r\n                if (firstCross == Location.inside) {\r\n                    firstCross = crossingLoc;\r\n                    startLocs.push(prev);\r\n                }\r\n                else if (prev != crossingLoc) {\r\n                    const isClockw = RectClip64.isClockwise(prev, crossingLoc, prevPt, path[i], this.mp);\r\n                    do {\r\n                        this.addCornerByRef(prev, isClockw);\r\n                    } while (prev != crossingLoc);\r\n                }\r\n            }\r\n            else if (prev != Location.inside) {\r\n                // passing right through rect. 'ip' here will be the second\r\n                // intersect pt but we'll also need the first intersect pt (ip2)\r\n                loc = prev;\r\n                result = RectClip64.getIntersection(this.rectPath, prevPt, path[i], loc);\r\n                const ip2 = result.ip;\r\n                if (prevCrossLoc != Location.inside && prevCrossLoc != loc)\r\n                    this.addCorner(prevCrossLoc, loc);\r\n                if (firstCross == Location.inside) {\r\n                    firstCross = loc;\r\n                    startLocs.push(prev);\r\n                }\r\n                loc = crossingLoc;\r\n                this.add(ip2);\r\n                if (ip == ip2) {\r\n                    loc = RectClip64.getLocation(this.rect, path[i]).loc;\r\n                    this.addCorner(crossingLoc, loc);\r\n                    crossingLoc = loc;\r\n                    continue;\r\n                }\r\n            }\r\n            else {\r\n                loc = crossingLoc;\r\n                if (firstCross == Location.inside)\r\n                    firstCross = crossingLoc;\r\n            }\r\n            this.add(ip);\r\n        } //while i <= highI\r\n        ///////////////////////////////////////////////////\r\n        if (firstCross == Location.inside) {\r\n            if (startingLoc != Location.inside) {\r\n                if (this.pathBounds.containsRect(this.rect) && RectClip64.path1ContainsPath2(path, this.rectPath)) {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        this.add(this.rectPath[j]);\r\n                        RectClip64.addToEdge(this.edges[j * 2], this.results[0]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (loc != Location.inside && (loc != firstCross || startLocs.length > 2)) {\r\n            if (startLocs.length > 0) {\r\n                prev = loc;\r\n                for (const loc2 of startLocs) {\r\n                    if (prev == loc2)\r\n                        continue;\r\n                    this.addCornerByRef(prev, RectClip64.headingClockwise(prev, loc2));\r\n                    prev = loc2;\r\n                }\r\n                loc = prev;\r\n            }\r\n            if (loc != firstCross)\r\n                this.addCornerByRef(loc, RectClip64.headingClockwise(loc, firstCross));\r\n        }\r\n    }\r\n    execute(paths) {\r\n        const result = [];\r\n        if (this.rect.isEmpty())\r\n            return result;\r\n        for (const path of paths) {\r\n            if (path.length < 3)\r\n                continue;\r\n            this.pathBounds = Clipper.getBounds(path);\r\n            if (!this.rect.intersects(this.pathBounds))\r\n                continue;\r\n            else if (this.rect.containsRect(this.pathBounds)) {\r\n                result.push(path);\r\n                continue;\r\n            }\r\n            this.executeInternal(path);\r\n            this.checkEdges();\r\n            for (let i = 0; i < 4; ++i)\r\n                this.tidyEdgePair(i, this.edges[i * 2], this.edges[i * 2 + 1]);\r\n            for (const op of this.results) {\r\n                const tmp = this.getPath(op);\r\n                if (tmp.length > 0)\r\n                    result.push(tmp);\r\n            }\r\n            this.results.length = 0;\r\n            for (let i = 0; i < 8; i++)\r\n                this.edges[i].length = 0;\r\n        }\r\n        return result;\r\n    }\r\n    checkEdges() {\r\n        for (let i = 0; i < this.results.length; i++) {\r\n            let op = this.results[i];\r\n            let op2 = op;\r\n            if (op === undefined)\r\n                continue;\r\n            do {\r\n                if (InternalClipper.crossProduct(op2.prev.pt, op2.pt, op2.next.pt) === 0) {\r\n                    if (op2 === op) {\r\n                        op2 = RectClip64.unlinkOpBack(op2);\r\n                        if (op2 === undefined)\r\n                            break;\r\n                        op = op2.prev;\r\n                    }\r\n                    else {\r\n                        op2 = RectClip64.unlinkOpBack(op2);\r\n                        if (op2 === undefined)\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    op2 = op2.next;\r\n                }\r\n            } while (op2 !== op);\r\n            if (op2 === undefined) {\r\n                this.results[i] = undefined;\r\n                continue;\r\n            }\r\n            this.results[i] = op2;\r\n            let edgeSet1 = RectClip64.getEdgesForPt(op.prev.pt, this.rect);\r\n            op2 = op;\r\n            do {\r\n                const edgeSet2 = RectClip64.getEdgesForPt(op2.pt, this.rect);\r\n                if (edgeSet2 !== 0 && op2.edge === undefined) {\r\n                    const combinedSet = (edgeSet1 & edgeSet2);\r\n                    for (let j = 0; j < 4; ++j) {\r\n                        if ((combinedSet & (1 << j)) !== 0) {\r\n                            if (RectClip64.isHeadingClockwise(op2.prev.pt, op2.pt, j))\r\n                                RectClip64.addToEdge(this.edges[j * 2], op2);\r\n                            else\r\n                                RectClip64.addToEdge(this.edges[j * 2 + 1], op2);\r\n                        }\r\n                    }\r\n                }\r\n                edgeSet1 = edgeSet2;\r\n                op2 = op2.next;\r\n            } while (op2 !== op);\r\n        }\r\n    }\r\n    tidyEdgePair(idx, cw, ccw) {\r\n        if (ccw.length === 0)\r\n            return;\r\n        const isHorz = (idx === 1 || idx === 3);\r\n        const cwIsTowardLarger = (idx === 1 || idx === 2);\r\n        let i = 0, j = 0;\r\n        let p1, p2, p1a, p2a, op, op2;\r\n        while (i < cw.length) {\r\n            p1 = cw[i];\r\n            if (!p1 || p1.next === p1.prev) {\r\n                cw[i++] = undefined;\r\n                j = 0;\r\n                continue;\r\n            }\r\n            const jLim = ccw.length;\r\n            while (j < jLim && (!ccw[j] || ccw[j].next === ccw[j].prev))\r\n                ++j;\r\n            if (j === jLim) {\r\n                ++i;\r\n                j = 0;\r\n                continue;\r\n            }\r\n            if (cwIsTowardLarger) {\r\n                p1 = cw[i].prev;\r\n                p1a = cw[i];\r\n                p2 = ccw[j];\r\n                p2a = ccw[j].prev;\r\n            }\r\n            else {\r\n                p1 = cw[i];\r\n                p1a = cw[i].prev;\r\n                p2 = ccw[j].prev;\r\n                p2a = ccw[j];\r\n            }\r\n            if ((isHorz && !RectClip64.hasHorzOverlap(p1.pt, p1a.pt, p2.pt, p2a.pt)) ||\r\n                (!isHorz && !RectClip64.hasVertOverlap(p1.pt, p1a.pt, p2.pt, p2a.pt))) {\r\n                ++j;\r\n                continue;\r\n            }\r\n            const isRejoining = cw[i].ownerIdx !== ccw[j].ownerIdx;\r\n            if (isRejoining) {\r\n                this.results[p2.ownerIdx] = undefined;\r\n                RectClip64.setNewOwner(p2, p1.ownerIdx);\r\n            }\r\n            if (cwIsTowardLarger) {\r\n                // p1 >> | >> p1a;\r\n                // p2 << | << p2a;\r\n                p1.next = p2;\r\n                p2.prev = p1;\r\n                p1a.prev = p2a;\r\n                p2a.next = p1a;\r\n            }\r\n            else {\r\n                // p1 << | << p1a;\r\n                // p2 >> | >> p2a;\r\n                p1.prev = p2;\r\n                p2.next = p1;\r\n                p1a.next = p2a;\r\n                p2a.prev = p1a;\r\n            }\r\n            if (!isRejoining) {\r\n                const new_idx = this.results.length;\r\n                this.results.push(p1a);\r\n                RectClip64.setNewOwner(p1a, new_idx);\r\n            }\r\n            if (cwIsTowardLarger) {\r\n                op = p2;\r\n                op2 = p1a;\r\n            }\r\n            else {\r\n                op = p1;\r\n                op2 = p2a;\r\n            }\r\n            this.results[op.ownerIdx] = op;\r\n            this.results[op2.ownerIdx] = op2;\r\n            // and now lots of work to get ready for the next loop\r\n            let opIsLarger, op2IsLarger;\r\n            if (isHorz) { // X\r\n                opIsLarger = op.pt.x > op.prev.pt.x;\r\n                op2IsLarger = op2.pt.x > op2.prev.pt.x;\r\n            }\r\n            else { // Y\r\n                opIsLarger = op.pt.y > op.prev.pt.y;\r\n                op2IsLarger = op2.pt.y > op2.prev.pt.y;\r\n            }\r\n            if ((op.next === op.prev) || (op.pt === op.prev.pt)) {\r\n                if (op2IsLarger === cwIsTowardLarger) {\r\n                    cw[i] = op2;\r\n                    ccw[j++] = undefined;\r\n                }\r\n                else {\r\n                    ccw[j] = op2;\r\n                    cw[i++] = undefined;\r\n                }\r\n            }\r\n            else if ((op2.next === op2.prev) || (op2.pt === op2.prev.pt)) {\r\n                if (opIsLarger === cwIsTowardLarger) {\r\n                    cw[i] = op;\r\n                    ccw[j++] = undefined;\r\n                }\r\n                else {\r\n                    ccw[j] = op;\r\n                    cw[i++] = undefined;\r\n                }\r\n            }\r\n            else if (opIsLarger === op2IsLarger) {\r\n                if (opIsLarger === cwIsTowardLarger) {\r\n                    cw[i] = op;\r\n                    RectClip64.uncoupleEdge(op2);\r\n                    RectClip64.addToEdge(cw, op2);\r\n                    ccw[j++] = undefined;\r\n                }\r\n                else {\r\n                    cw[i++] = undefined;\r\n                    ccw[j] = op2;\r\n                    RectClip64.uncoupleEdge(op);\r\n                    RectClip64.addToEdge(ccw, op);\r\n                    j = 0;\r\n                }\r\n            }\r\n            else {\r\n                if (opIsLarger === cwIsTowardLarger)\r\n                    cw[i] = op;\r\n                else\r\n                    ccw[j] = op;\r\n                if (op2IsLarger === cwIsTowardLarger)\r\n                    cw[i] = op2;\r\n                else\r\n                    ccw[j] = op2;\r\n            }\r\n        }\r\n    }\r\n    getPath(op) {\r\n        const result = new Path64();\r\n        if (!op || op.prev === op.next)\r\n            return result;\r\n        let op2 = op.next;\r\n        while (op2 && op2 !== op) {\r\n            if (InternalClipper.crossProduct(op2.prev.pt, op2.pt, op2.next.pt) === 0) {\r\n                op = op2.prev;\r\n                op2 = RectClip64.unlinkOp(op2);\r\n            }\r\n            else {\r\n                op2 = op2.next;\r\n            }\r\n        }\r\n        if (!op2)\r\n            return new Path64();\r\n        result.push(op.pt);\r\n        op2 = op.next;\r\n        while (op2 !== op) {\r\n            result.push(op2.pt);\r\n            op2 = op2.next;\r\n        }\r\n        return result;\r\n    }\r\n}\r\nclass RectClipLines64 extends RectClip64 {\r\n    constructor(rect) {\r\n        super(rect);\r\n    }\r\n    execute(paths) {\r\n        const result = new Paths64();\r\n        if (this.rect.isEmpty())\r\n            return result;\r\n        for (const path of paths) {\r\n            if (path.length < 2)\r\n                continue;\r\n            this.pathBounds = Clipper.getBounds(path);\r\n            if (!this.rect.intersects(this.pathBounds))\r\n                continue;\r\n            this.executeInternal(path);\r\n            for (const op of this.results) {\r\n                const tmp = this.getPath(op);\r\n                if (tmp.length > 0)\r\n                    result.push(tmp);\r\n            }\r\n            // Clean up after every loop\r\n            this.results.length = 0; // Clear the array\r\n            for (let i = 0; i < 8; i++) {\r\n                this.edges[i].length = 0; // Clear each array\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getPath(op) {\r\n        const result = new Path64();\r\n        if (!op || op === op.next)\r\n            return result;\r\n        op = op.next; // starting at path beginning \r\n        result.push(op.pt);\r\n        let op2 = op.next;\r\n        while (op2 !== op) {\r\n            result.push(op2.pt);\r\n            op2 = op2.next;\r\n        }\r\n        return result;\r\n    }\r\n    executeInternal(path) {\r\n        this.results = [];\r\n        if (path.length < 2 || this.rect.isEmpty())\r\n            return;\r\n        let prev = Location.inside;\r\n        let i = 1;\r\n        const highI = path.length - 1;\r\n        let result = RectClipLines64.getLocation(this.rect, path[0]);\r\n        let loc = result.loc;\r\n        if (!result.success) {\r\n            while (i <= highI && !result.success) {\r\n                i++;\r\n                result = RectClipLines64.getLocation(this.rect, path[i]);\r\n                prev = result.loc;\r\n            }\r\n            if (i > highI) {\r\n                for (const pt of path)\r\n                    this.add(pt);\r\n            }\r\n            if (prev == Location.inside)\r\n                loc = Location.inside;\r\n            i = 1;\r\n        }\r\n        if (loc == Location.inside)\r\n            this.add(path[0]);\r\n        while (i <= highI) {\r\n            prev = loc;\r\n            this.getNextLocation(path, { loc, i, highI });\r\n            if (i > highI)\r\n                break;\r\n            const prevPt = path[i - 1];\r\n            let crossingLoc = loc;\r\n            let result = RectClipLines64.getIntersection(this.rectPath, path[i], prevPt, crossingLoc);\r\n            const ip = result.ip;\r\n            crossingLoc = result.loc;\r\n            if (!result.success) {\r\n                i++;\r\n                continue;\r\n            }\r\n            if (loc == Location.inside) {\r\n                this.add(ip, true);\r\n            }\r\n            else if (prev !== Location.inside) {\r\n                crossingLoc = prev;\r\n                result = RectClipLines64.getIntersection(this.rectPath, prevPt, path[i], crossingLoc);\r\n                const ip2 = result.ip;\r\n                crossingLoc = result.loc;\r\n                this.add(ip2);\r\n                this.add(ip);\r\n            }\r\n            else {\r\n                this.add(ip);\r\n            }\r\n        }\r\n    }\r\n}\n\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  16 July 2023                                                    *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  This module contains simple functions that will likely cover    *\r\n*              most polygon boolean and offsetting needs, while also avoiding  *\r\n*              the inherent complexities of the other modules.                 *\r\n* Thanks    :  Special thanks to Thong Nguyen, Guus Kuiper, Phil Stopford,     *\r\n*           :  and Daniel Gosnell for their invaluable assistance with C#.     *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\nclass Clipper {\r\n    static get InvalidRect64() {\r\n        if (!Clipper.invalidRect64)\r\n            Clipper.invalidRect64 = new Rect64(false);\r\n        return this.invalidRect64;\r\n    }\r\n    static Intersect(subject, clip, fillRule) {\r\n        return this.BooleanOp(ClipType.Intersection, subject, clip, fillRule);\r\n    }\r\n    static Union(subject, clip, fillRule = FillRule.EvenOdd) {\r\n        return this.BooleanOp(ClipType.Union, subject, clip, fillRule);\r\n    }\r\n    static Difference(subject, clip, fillRule) {\r\n        return this.BooleanOp(ClipType.Difference, subject, clip, fillRule);\r\n    }\r\n    static Xor(subject, clip, fillRule) {\r\n        return this.BooleanOp(ClipType.Xor, subject, clip, fillRule);\r\n    }\r\n    static BooleanOp(clipType, subject, clip, fillRule = FillRule.EvenOdd) {\r\n        const solution = new Paths64();\r\n        if (!subject)\r\n            return solution;\r\n        const c = new Clipper64();\r\n        c.addPaths(subject, PathType.Subject);\r\n        if (clip)\r\n            c.addPaths(clip, PathType.Clip);\r\n        c.execute(clipType, fillRule, solution);\r\n        return solution;\r\n    }\r\n    //public static BooleanOp(clipType: ClipType, subject: Paths64, clip: Paths64, polytree: PolyTree64, fillRule: FillRule): void {\r\n    //  if (!subject) return;\r\n    //  const c: Clipper64 = new Clipper64();\r\n    //  c.addPaths(subject, PathType.Subject);\r\n    //  if (clip)\r\n    //    c.addPaths(clip, PathType.Clip);\r\n    //  c.execute(clipType, fillRule, polytree);\r\n    //}\r\n    static InflatePaths(paths, delta, joinType, endType, miterLimit = 2.0) {\r\n        const co = new ClipperOffset(miterLimit);\r\n        co.addPaths(paths, joinType, endType);\r\n        const solution = new Paths64();\r\n        co.execute(delta, solution);\r\n        return solution;\r\n    }\r\n    static RectClipPaths(rect, paths) {\r\n        if (rect.isEmpty() || paths.length === 0)\r\n            return new Paths64();\r\n        const rc = new RectClip64(rect);\r\n        return rc.execute(paths);\r\n    }\r\n    static RectClip(rect, path) {\r\n        if (rect.isEmpty() || path.length === 0)\r\n            return new Paths64();\r\n        const tmp = new Paths64();\r\n        tmp.push(path);\r\n        return this.RectClipPaths(rect, tmp);\r\n    }\r\n    static RectClipLinesPaths(rect, paths) {\r\n        if (rect.isEmpty() || paths.length === 0)\r\n            return new Paths64();\r\n        const rc = new RectClipLines64(rect);\r\n        return rc.execute(paths);\r\n    }\r\n    static RectClipLines(rect, path) {\r\n        if (rect.isEmpty() || path.length === 0)\r\n            return new Paths64();\r\n        const tmp = new Paths64();\r\n        tmp.push(path);\r\n        return this.RectClipLinesPaths(rect, tmp);\r\n    }\r\n    static MinkowskiSum(pattern, path, isClosed) {\r\n        return Minkowski.sum(pattern, path, isClosed);\r\n    }\r\n    static MinkowskiDiff(pattern, path, isClosed) {\r\n        return Minkowski.diff(pattern, path, isClosed);\r\n    }\r\n    static area(path) {\r\n        // https://en.wikipedia.org/wiki/Shoelace_formula\r\n        let a = 0.0;\r\n        const cnt = path.length;\r\n        if (cnt < 3)\r\n            return 0.0;\r\n        let prevPt = path[cnt - 1];\r\n        for (const pt of path) {\r\n            a += (prevPt.y + pt.y) * (prevPt.x - pt.x);\r\n            prevPt = pt;\r\n        }\r\n        return a * 0.5;\r\n    }\r\n    static areaPaths(paths) {\r\n        let a = 0.0;\r\n        for (const path of paths)\r\n            a += this.area(path);\r\n        return a;\r\n    }\r\n    static isPositive(poly) {\r\n        return this.area(poly) >= 0;\r\n    }\r\n    static path64ToString(path) {\r\n        let result = \"\";\r\n        for (const pt of path)\r\n            result += pt.toString();\r\n        return result + '\\n';\r\n    }\r\n    static paths64ToString(paths) {\r\n        let result = \"\";\r\n        for (const path of paths)\r\n            result += this.path64ToString(path);\r\n        return result;\r\n    }\r\n    static offsetPath(path, dx, dy) {\r\n        const result = new Path64();\r\n        for (const pt of path)\r\n            result.push(new Point64(pt.x + dx, pt.y + dy));\r\n        return result;\r\n    }\r\n    static scalePoint64(pt, scale) {\r\n        const result = new Point64(Math.round(pt.x * scale), Math.round(pt.y * scale));\r\n        return result;\r\n    }\r\n    static scalePath(path, scale) {\r\n        if (InternalClipper.isAlmostZero(scale - 1))\r\n            return path;\r\n        const result = [];\r\n        for (const pt of path)\r\n            result.push({ x: pt.x * scale, y: pt.y * scale });\r\n        return result;\r\n    }\r\n    static scalePaths(paths, scale) {\r\n        if (InternalClipper.isAlmostZero(scale - 1))\r\n            return paths;\r\n        const result = [];\r\n        for (const path of paths)\r\n            result.push(this.scalePath(path, scale));\r\n        return result;\r\n    }\r\n    static translatePath(path, dx, dy) {\r\n        const result = [];\r\n        for (const pt of path) {\r\n            result.push({ x: pt.x + dx, y: pt.y + dy });\r\n        }\r\n        return result;\r\n    }\r\n    static translatePaths(paths, dx, dy) {\r\n        const result = [];\r\n        for (const path of paths) {\r\n            result.push(this.translatePath(path, dx, dy));\r\n        }\r\n        return result;\r\n    }\r\n    static reversePath(path) {\r\n        return [...path].reverse();\r\n    }\r\n    static reversePaths(paths) {\r\n        const result = [];\r\n        for (const t of paths) {\r\n            result.push(this.reversePath(t));\r\n        }\r\n        return result;\r\n    }\r\n    static getBounds(path) {\r\n        const result = Clipper.InvalidRect64;\r\n        for (const pt of path) {\r\n            if (pt.x < result.left)\r\n                result.left = pt.x;\r\n            if (pt.x > result.right)\r\n                result.right = pt.x;\r\n            if (pt.y < result.top)\r\n                result.top = pt.y;\r\n            if (pt.y > result.bottom)\r\n                result.bottom = pt.y;\r\n        }\r\n        return result.left === Number.MAX_SAFE_INTEGER ? new Rect64(0, 0, 0, 0) : result;\r\n    }\r\n    static getBoundsPaths(paths) {\r\n        const result = Clipper.InvalidRect64;\r\n        for (const path of paths) {\r\n            for (const pt of path) {\r\n                if (pt.x < result.left)\r\n                    result.left = pt.x;\r\n                if (pt.x > result.right)\r\n                    result.right = pt.x;\r\n                if (pt.y < result.top)\r\n                    result.top = pt.y;\r\n                if (pt.y > result.bottom)\r\n                    result.bottom = pt.y;\r\n            }\r\n        }\r\n        return result.left === Number.MAX_SAFE_INTEGER ? new Rect64(0, 0, 0, 0) : result;\r\n    }\r\n    static makePath(arr) {\r\n        const len = arr.length / 2;\r\n        const p = new Path64();\r\n        for (let i = 0; i < len; i++)\r\n            p.push(new Point64(arr[i * 2], arr[i * 2 + 1]));\r\n        return p;\r\n    }\r\n    static stripDuplicates(path, isClosedPath) {\r\n        const cnt = path.length;\r\n        const result = new Path64();\r\n        if (cnt === 0)\r\n            return result;\r\n        let lastPt = path[0];\r\n        result.push(lastPt);\r\n        for (let i = 1; i < cnt; i++)\r\n            if (lastPt !== path[i]) {\r\n                lastPt = path[i];\r\n                result.push(lastPt);\r\n            }\r\n        if (isClosedPath && lastPt === result[0])\r\n            result.pop();\r\n        return result;\r\n    }\r\n    static addPolyNodeToPaths(polyPath, paths) {\r\n        if (polyPath.polygon && polyPath.polygon.length > 0)\r\n            paths.push(polyPath.polygon);\r\n        for (let i = 0; i < polyPath.count; i++)\r\n            this.addPolyNodeToPaths(polyPath.children[i], paths);\r\n    }\r\n    static polyTreeToPaths64(polyTree) {\r\n        const result = new Paths64();\r\n        for (let i = 0; i < polyTree.count; i++) {\r\n            Clipper.addPolyNodeToPaths(polyTree.children[i], result);\r\n        }\r\n        return result;\r\n    }\r\n    static perpendicDistFromLineSqrd(pt, line1, line2) {\r\n        const a = pt.x - line1.x;\r\n        const b = pt.y - line1.y;\r\n        const c = line2.x - line1.x;\r\n        const d = line2.y - line1.y;\r\n        if (c === 0 && d === 0)\r\n            return 0;\r\n        return Clipper.sqr(a * d - c * b) / (c * c + d * d);\r\n    }\r\n    static rdp(path, begin, end, epsSqrd, flags) {\r\n        let idx = 0;\r\n        let max_d = 0;\r\n        while (end > begin && path[begin] === path[end]) {\r\n            flags[end--] = false;\r\n        }\r\n        for (let i = begin + 1; i < end; i++) {\r\n            const d = Clipper.perpendicDistFromLineSqrd(path[i], path[begin], path[end]);\r\n            if (d <= max_d)\r\n                continue;\r\n            max_d = d;\r\n            idx = i;\r\n        }\r\n        if (max_d <= epsSqrd)\r\n            return;\r\n        flags[idx] = true;\r\n        if (idx > begin + 1)\r\n            Clipper.rdp(path, begin, idx, epsSqrd, flags);\r\n        if (idx < end - 1)\r\n            Clipper.rdp(path, idx, end, epsSqrd, flags);\r\n    }\r\n    static ramerDouglasPeucker(path, epsilon) {\r\n        const len = path.length;\r\n        if (len < 5)\r\n            return path;\r\n        const flags = new Array(len).fill(false);\r\n        flags[0] = true;\r\n        flags[len - 1] = true;\r\n        Clipper.rdp(path, 0, len - 1, Clipper.sqr(epsilon), flags);\r\n        const result = [];\r\n        for (let i = 0; i < len; i++) {\r\n            if (flags[i])\r\n                result.push(path[i]);\r\n        }\r\n        return result;\r\n    }\r\n    static ramerDouglasPeuckerPaths(paths, epsilon) {\r\n        const result = [];\r\n        for (const path of paths) {\r\n            result.push(Clipper.ramerDouglasPeucker(path, epsilon));\r\n        }\r\n        return result;\r\n    }\r\n    static getNext(current, high, flags) {\r\n        current++;\r\n        while (current <= high && flags[current])\r\n            current++;\r\n        if (current <= high)\r\n            return current;\r\n        current = 0;\r\n        while (flags[current])\r\n            current++;\r\n        return current;\r\n    }\r\n    static getPrior(current, high, flags) {\r\n        if (current === 0)\r\n            current = high;\r\n        else\r\n            current--;\r\n        while (current > 0 && flags[current])\r\n            current--;\r\n        if (!flags[current])\r\n            return current;\r\n        current = high;\r\n        while (flags[current])\r\n            current--;\r\n        return current;\r\n    }\r\n    static sqr(value) {\r\n        return value * value;\r\n    }\r\n    static simplifyPath(path, epsilon, isClosedPath = false) {\r\n        const len = path.length;\r\n        const high = len - 1;\r\n        const epsSqr = this.sqr(epsilon);\r\n        if (len < 4)\r\n            return path;\r\n        const flags = new Array(len).fill(false);\r\n        const dsq = new Array(len).fill(0);\r\n        let prev = high;\r\n        let curr = 0;\r\n        let start, next, prior2, next2;\r\n        if (isClosedPath) {\r\n            dsq[0] = this.perpendicDistFromLineSqrd(path[0], path[high], path[1]);\r\n            dsq[high] = this.perpendicDistFromLineSqrd(path[high], path[0], path[high - 1]);\r\n        }\r\n        else {\r\n            dsq[0] = Number.MAX_VALUE;\r\n            dsq[high] = Number.MAX_VALUE;\r\n        }\r\n        for (let i = 1; i < high; i++) {\r\n            dsq[i] = this.perpendicDistFromLineSqrd(path[i], path[i - 1], path[i + 1]);\r\n        }\r\n        for (;;) {\r\n            if (dsq[curr] > epsSqr) {\r\n                start = curr;\r\n                do {\r\n                    curr = this.getNext(curr, high, flags);\r\n                } while (curr !== start && dsq[curr] > epsSqr);\r\n                if (curr === start)\r\n                    break;\r\n            }\r\n            prev = this.getPrior(curr, high, flags);\r\n            next = this.getNext(curr, high, flags);\r\n            if (next === prev)\r\n                break;\r\n            if (dsq[next] < dsq[curr]) {\r\n                flags[next] = true;\r\n                next = this.getNext(next, high, flags);\r\n                next2 = this.getNext(next, high, flags);\r\n                dsq[curr] = this.perpendicDistFromLineSqrd(path[curr], path[prev], path[next]);\r\n                if (next !== high || isClosedPath) {\r\n                    dsq[next] = this.perpendicDistFromLineSqrd(path[next], path[curr], path[next2]);\r\n                }\r\n                curr = next;\r\n            }\r\n            else {\r\n                flags[curr] = true;\r\n                curr = next;\r\n                next = this.getNext(next, high, flags);\r\n                prior2 = this.getPrior(prev, high, flags);\r\n                dsq[curr] = this.perpendicDistFromLineSqrd(path[curr], path[prev], path[next]);\r\n                if (prev !== 0 || isClosedPath) {\r\n                    dsq[prev] = this.perpendicDistFromLineSqrd(path[prev], path[prior2], path[curr]);\r\n                }\r\n            }\r\n        }\r\n        const result = [];\r\n        for (let i = 0; i < len; i++) {\r\n            if (!flags[i])\r\n                result.push(path[i]);\r\n        }\r\n        return result;\r\n    }\r\n    static simplifyPaths(paths, epsilon, isClosedPaths = false) {\r\n        const result = [];\r\n        for (const path of paths) {\r\n            result.push(this.simplifyPath(path, epsilon, isClosedPaths));\r\n        }\r\n        return result;\r\n    }\r\n    //private static getNext(current: number, high: number, flags: boolean[]): number {\r\n    //  current++;\r\n    //  while (current <= high && flags[current]) current++;\r\n    //  return current;\r\n    //}\r\n    //private static getPrior(current: number, high: number, flags: boolean[]): number {\r\n    //  if (current === 0) return high;\r\n    //  current--;\r\n    //  while (current > 0 && flags[current]) current--;\r\n    //  return current;\r\n    //}\r\n    static trimCollinear(path, isOpen = false) {\r\n        let len = path.length;\r\n        let i = 0;\r\n        if (!isOpen) {\r\n            while (i < len - 1 && InternalClipper.crossProduct(path[len - 1], path[i], path[i + 1]) === 0)\r\n                i++;\r\n            while (i < len - 1 && InternalClipper.crossProduct(path[len - 2], path[len - 1], path[i]) === 0)\r\n                len--;\r\n        }\r\n        if (len - i < 3) {\r\n            if (!isOpen || len < 2 || path[0] === path[1]) {\r\n                return [];\r\n            }\r\n            return path;\r\n        }\r\n        const result = [];\r\n        let last = path[i];\r\n        result.push(last);\r\n        for (i++; i < len - 1; i++) {\r\n            if (InternalClipper.crossProduct(last, path[i], path[i + 1]) === 0)\r\n                continue;\r\n            last = path[i];\r\n            result.push(last);\r\n        }\r\n        if (isOpen) {\r\n            result.push(path[len - 1]);\r\n        }\r\n        else if (InternalClipper.crossProduct(last, path[len - 1], result[0]) !== 0) {\r\n            result.push(path[len - 1]);\r\n        }\r\n        else {\r\n            while (result.length > 2 && InternalClipper.crossProduct(result[result.length - 1], result[result.length - 2], result[0]) === 0) {\r\n                result.pop();\r\n            }\r\n            if (result.length < 3)\r\n                result.splice(0, result.length);\r\n        }\r\n        return result;\r\n    }\r\n    static pointInPolygon(pt, polygon) {\r\n        return InternalClipper.pointInPolygon(pt, polygon);\r\n    }\r\n    static ellipse(center, radiusX, radiusY = 0, steps = 0) {\r\n        if (radiusX <= 0)\r\n            return [];\r\n        if (radiusY <= 0)\r\n            radiusY = radiusX;\r\n        if (steps <= 2)\r\n            steps = Math.ceil(Math.PI * Math.sqrt((radiusX + radiusY) / 2));\r\n        const si = Math.sin(2 * Math.PI / steps);\r\n        const co = Math.cos(2 * Math.PI / steps);\r\n        let dx = co, dy = si;\r\n        const result = [{ x: center.x + radiusX, y: center.y }];\r\n        for (let i = 1; i < steps; ++i) {\r\n            result.push({ x: center.x + radiusX * dx, y: center.y + radiusY * dy });\r\n            const x = dx * co - dy * si;\r\n            dy = dy * co + dx * si;\r\n            dx = x;\r\n        }\r\n        return result;\r\n    }\r\n    static showPolyPathStructure(pp, level) {\r\n        const spaces = ' '.repeat(level * 2);\r\n        const caption = pp.isHole ? \"Hole \" : \"Outer \";\r\n        if (pp.count === 0) {\r\n            console.log(spaces + caption);\r\n        }\r\n        else {\r\n            console.log(spaces + caption + `(${pp.count})`);\r\n            pp.forEach(child => this.showPolyPathStructure(child, level + 1));\r\n        }\r\n    }\r\n    static showPolyTreeStructure(polytree) {\r\n        console.log(\"Polytree Root\");\r\n        polytree.forEach(child => this.showPolyPathStructure(child, 1));\r\n    }\r\n}\n\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  27 August 2023                                                  *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  This is the main polygon clipping module                        *\r\n* Thanks    :  Special thanks to Thong Nguyen, Guus Kuiper, Phil Stopford,     *\r\n*           :  and Daniel Gosnell for their invaluable assistance with C#.     *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Engine.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\nvar PointInPolygonResult;\r\n(function (PointInPolygonResult) {\r\n    PointInPolygonResult[PointInPolygonResult[\"IsOn\"] = 0] = \"IsOn\";\r\n    PointInPolygonResult[PointInPolygonResult[\"IsInside\"] = 1] = \"IsInside\";\r\n    PointInPolygonResult[PointInPolygonResult[\"IsOutside\"] = 2] = \"IsOutside\";\r\n})(PointInPolygonResult || (PointInPolygonResult = {}));\r\nvar VertexFlags;\r\n(function (VertexFlags) {\r\n    VertexFlags[VertexFlags[\"None\"] = 0] = \"None\";\r\n    VertexFlags[VertexFlags[\"OpenStart\"] = 1] = \"OpenStart\";\r\n    VertexFlags[VertexFlags[\"OpenEnd\"] = 2] = \"OpenEnd\";\r\n    VertexFlags[VertexFlags[\"LocalMax\"] = 4] = \"LocalMax\";\r\n    VertexFlags[VertexFlags[\"LocalMin\"] = 8] = \"LocalMin\";\r\n})(VertexFlags || (VertexFlags = {}));\r\nclass Vertex {\r\n    constructor(pt, flags, prev) {\r\n        this.pt = pt;\r\n        this.flags = flags;\r\n        this.next = undefined;\r\n        this.prev = prev;\r\n    }\r\n}\r\nclass LocalMinima {\r\n    constructor(vertex, polytype, isOpen = false) {\r\n        this.vertex = vertex;\r\n        this.polytype = polytype;\r\n        this.isOpen = isOpen;\r\n    }\r\n    static equals(lm1, lm2) {\r\n        return lm1.vertex === lm2.vertex;\r\n    }\r\n    static notEquals(lm1, lm2) {\r\n        return lm1.vertex !== lm2.vertex;\r\n    }\r\n}\r\nclass IntersectNode {\r\n    constructor(pt, edge1, edge2) {\r\n        this.pt = pt;\r\n        this.edge1 = edge1;\r\n        this.edge2 = edge2;\r\n    }\r\n}\r\nclass OutPt {\r\n    constructor(pt, outrec) {\r\n        this.pt = pt;\r\n        this.outrec = outrec;\r\n        this.next = this;\r\n        this.prev = this;\r\n        this.horz = undefined;\r\n    }\r\n}\r\nvar JoinWith;\r\n(function (JoinWith) {\r\n    JoinWith[JoinWith[\"None\"] = 0] = \"None\";\r\n    JoinWith[JoinWith[\"Left\"] = 1] = \"Left\";\r\n    JoinWith[JoinWith[\"Right\"] = 2] = \"Right\";\r\n})(JoinWith || (JoinWith = {}));\r\nvar HorzPosition;\r\n(function (HorzPosition) {\r\n    HorzPosition[HorzPosition[\"Bottom\"] = 0] = \"Bottom\";\r\n    HorzPosition[HorzPosition[\"Middle\"] = 1] = \"Middle\";\r\n    HorzPosition[HorzPosition[\"Top\"] = 2] = \"Top\";\r\n})(HorzPosition || (HorzPosition = {}));\r\nclass OutRec {\r\n    constructor(idx) {\r\n        this.idx = idx;\r\n        this.isOpen = false;\r\n    }\r\n}\r\nclass HorzSegment {\r\n    constructor(op) {\r\n        this.leftOp = op;\r\n        this.rightOp = undefined;\r\n        this.leftToRight = true;\r\n    }\r\n}\r\nclass HorzJoin {\r\n    constructor(ltor, rtol) {\r\n        this.op1 = ltor;\r\n        this.op2 = rtol;\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////\r\n// Important: UP and DOWN here are premised on Y-axis positive down\r\n// displays, which is the orientation used in Clipper's development.\r\n///////////////////////////////////////////////////////////////////\r\nclass Active {\r\n    constructor() {\r\n        this.dx = this.windCount = this.windCount2 = 0;\r\n        this.isLeftBound = false;\r\n        this.joinWith = JoinWith.None;\r\n    }\r\n}\r\nclass ClipperEngine {\r\n    static addLocMin(vert, polytype, isOpen, minimaList) {\r\n        // make sure the vertex is added only once ...\r\n        if ((vert.flags & VertexFlags.LocalMin) !== VertexFlags.None)\r\n            return;\r\n        vert.flags |= VertexFlags.LocalMin;\r\n        const lm = new LocalMinima(vert, polytype, isOpen);\r\n        minimaList.push(lm);\r\n    }\r\n    static addPathsToVertexList(paths, polytype, isOpen, minimaList, vertexList) {\r\n        let totalVertCnt = 0;\r\n        for (const path of paths)\r\n            totalVertCnt += path.length;\r\n        for (const path of paths) {\r\n            let v0 = undefined;\r\n            let prev_v = undefined;\r\n            let curr_v = undefined;\r\n            for (const pt of path) {\r\n                if (!v0) {\r\n                    v0 = new Vertex(pt, VertexFlags.None, undefined);\r\n                    vertexList.push(v0);\r\n                    prev_v = v0;\r\n                }\r\n                else if (prev_v.pt !== pt) { // i.e., skips duplicates\r\n                    curr_v = new Vertex(pt, VertexFlags.None, prev_v);\r\n                    vertexList.push(curr_v);\r\n                    prev_v.next = curr_v;\r\n                    prev_v = curr_v;\r\n                }\r\n            }\r\n            if (!prev_v || !prev_v.prev)\r\n                continue;\r\n            if (!isOpen && prev_v.pt === v0.pt)\r\n                prev_v = prev_v.prev;\r\n            prev_v.next = v0;\r\n            v0.prev = prev_v;\r\n            if (!isOpen && prev_v.next === prev_v)\r\n                continue;\r\n            // OK, we have a valid path\r\n            let going_up = false;\r\n            if (isOpen) {\r\n                curr_v = v0.next;\r\n                let count = 0;\r\n                while (curr_v !== v0 && curr_v.pt.y === v0.pt.y) {\r\n                    curr_v = curr_v.next;\r\n                    if (count++ > totalVertCnt) {\r\n                        console.warn('infinite loop detected');\r\n                        break;\r\n                    }\r\n                }\r\n                going_up = curr_v.pt.y <= v0.pt.y;\r\n                if (going_up) {\r\n                    v0.flags = VertexFlags.OpenStart;\r\n                    this.addLocMin(v0, polytype, true, minimaList);\r\n                }\r\n                else {\r\n                    v0.flags = VertexFlags.OpenStart | VertexFlags.LocalMax;\r\n                }\r\n            }\r\n            else { // closed path\r\n                prev_v = v0.prev;\r\n                let count = 0;\r\n                while (prev_v !== v0 && prev_v.pt.y === v0.pt.y) {\r\n                    prev_v = prev_v.prev;\r\n                    if (count++ > totalVertCnt) {\r\n                        console.warn('infinite loop detected');\r\n                        break;\r\n                    }\r\n                }\r\n                if (prev_v === v0) {\r\n                    continue; // only open paths can be completely flat\r\n                }\r\n                going_up = prev_v.pt.y > v0.pt.y;\r\n            }\r\n            const going_up0 = going_up;\r\n            prev_v = v0;\r\n            curr_v = v0.next;\r\n            let count = 0;\r\n            while (curr_v !== v0) {\r\n                if (curr_v.pt.y > prev_v.pt.y && going_up) {\r\n                    prev_v.flags |= VertexFlags.LocalMax;\r\n                    going_up = false;\r\n                }\r\n                else if (curr_v.pt.y < prev_v.pt.y && !going_up) {\r\n                    going_up = true;\r\n                    this.addLocMin(prev_v, polytype, isOpen, minimaList);\r\n                }\r\n                prev_v = curr_v;\r\n                curr_v = curr_v.next;\r\n                if (count++ > totalVertCnt) {\r\n                    console.warn('infinite loop detected');\r\n                    break;\r\n                }\r\n            }\r\n            if (isOpen) {\r\n                prev_v.flags |= VertexFlags.OpenEnd;\r\n                if (going_up) {\r\n                    prev_v.flags |= VertexFlags.LocalMax;\r\n                }\r\n                else {\r\n                    this.addLocMin(prev_v, polytype, isOpen, minimaList);\r\n                }\r\n            }\r\n            else if (going_up !== going_up0) {\r\n                if (going_up0) {\r\n                    this.addLocMin(prev_v, polytype, false, minimaList);\r\n                }\r\n                else {\r\n                    prev_v.flags |= VertexFlags.LocalMax;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nclass ReuseableDataContainer64 {\r\n    constructor() {\r\n        this._minimaList = [];\r\n        this._vertexList = [];\r\n    }\r\n    clear() {\r\n        this._minimaList.length = 0;\r\n        this._vertexList.length = 0;\r\n    }\r\n    addPaths(paths, pt, isOpen) {\r\n        ClipperEngine.addPathsToVertexList(paths, pt, isOpen, this._minimaList, this._vertexList);\r\n    }\r\n}\r\nclass SimpleNavigableSet {\r\n    constructor() {\r\n        this.items = [];\r\n        this.items = [];\r\n    }\r\n    clear() { this.items.length = 0; }\r\n    isEmpty() { return this.items.length == 0; }\r\n    pollLast() {\r\n        return this.items.pop();\r\n    }\r\n    add(item) {\r\n        if (!this.items.includes(item)) {\r\n            this.items.push(item);\r\n            this.items.sort((a, b) => a - b);\r\n        }\r\n    }\r\n}\r\nclass ClipperBase {\r\n    constructor() {\r\n        this._cliptype = ClipType.None;\r\n        this._fillrule = FillRule.EvenOdd;\r\n        this._currentLocMin = 0;\r\n        this._currentBotY = 0;\r\n        this._isSortedMinimaList = false;\r\n        this._hasOpenPaths = false;\r\n        this._using_polytree = false;\r\n        this._succeeded = false;\r\n        this.reverseSolution = false;\r\n        this._minimaList = [];\r\n        this._intersectList = [];\r\n        this._vertexList = [];\r\n        this._outrecList = [];\r\n        this._scanlineList = new SimpleNavigableSet();\r\n        this._horzSegList = [];\r\n        this._horzJoinList = [];\r\n        this.preserveCollinear = true;\r\n    }\r\n    static isOdd(val) {\r\n        return ((val & 1) !== 0);\r\n    }\r\n    static isHotEdgeActive(ae) {\r\n        return ae.outrec !== undefined;\r\n    }\r\n    static isOpen(ae) {\r\n        return ae.localMin.isOpen;\r\n    }\r\n    static isOpenEndActive(ae) {\r\n        return ae.localMin.isOpen && ClipperBase.isOpenEnd(ae.vertexTop);\r\n    }\r\n    static isOpenEnd(v) {\r\n        return (v.flags & (VertexFlags.OpenStart | VertexFlags.OpenEnd)) !== VertexFlags.None;\r\n    }\r\n    static getPrevHotEdge(ae) {\r\n        let prev = ae.prevInAEL;\r\n        while (prev && (ClipperBase.isOpen(prev) || !ClipperBase.isHotEdgeActive(prev)))\r\n            prev = prev.prevInAEL;\r\n        return prev;\r\n    }\r\n    static isFront(ae) {\r\n        return ae === ae.outrec.frontEdge;\r\n    }\r\n    /*******************************************************************************\r\n    *  Dx:                             0(90deg)                                    *\r\n    *                                  |                                           *\r\n    *               +inf (180deg) <--- o --. -inf (0deg)                          *\r\n    *******************************************************************************/\r\n    static getDx(pt1, pt2) {\r\n        const dy = pt2.y - pt1.y;\r\n        if (dy !== 0)\r\n            return (pt2.x - pt1.x) / dy;\r\n        if (pt2.x > pt1.x)\r\n            return Number.NEGATIVE_INFINITY;\r\n        return Number.POSITIVE_INFINITY;\r\n    }\r\n    static topX(ae, currentY) {\r\n        if ((currentY === ae.top.y) || (ae.top.x === ae.bot.x))\r\n            return ae.top.x;\r\n        if (currentY === ae.bot.y)\r\n            return ae.bot.x;\r\n        return ae.bot.x + Math.round(ae.dx * (currentY - ae.bot.y));\r\n    }\r\n    static isHorizontal(ae) {\r\n        return (ae.top.y === ae.bot.y);\r\n    }\r\n    static isHeadingRightHorz(ae) {\r\n        return (Number.NEGATIVE_INFINITY === ae.dx);\r\n    }\r\n    static isHeadingLeftHorz(ae) {\r\n        return (Number.POSITIVE_INFINITY === ae.dx);\r\n    }\r\n    static swapActives(ae1, ae2) {\r\n        [ae2, ae1] = [ae1, ae2];\r\n    }\r\n    static getPolyType(ae) {\r\n        return ae.localMin.polytype;\r\n    }\r\n    static isSamePolyType(ae1, ae2) {\r\n        return ae1.localMin.polytype === ae2.localMin.polytype;\r\n    }\r\n    static setDx(ae) {\r\n        ae.dx = ClipperBase.getDx(ae.bot, ae.top);\r\n    }\r\n    static nextVertex(ae) {\r\n        if (ae.windDx > 0)\r\n            return ae.vertexTop.next;\r\n        return ae.vertexTop.prev;\r\n    }\r\n    static prevPrevVertex(ae) {\r\n        if (ae.windDx > 0)\r\n            return ae.vertexTop.prev.prev;\r\n        return ae.vertexTop.next.next;\r\n    }\r\n    static isMaxima(vertex) {\r\n        return (vertex.flags & VertexFlags.LocalMax) !== VertexFlags.None;\r\n    }\r\n    static isMaximaActive(ae) {\r\n        return ClipperBase.isMaxima(ae.vertexTop);\r\n    }\r\n    static getMaximaPair(ae) {\r\n        let ae2 = ae.nextInAEL;\r\n        while (ae2) {\r\n            if (ae2.vertexTop === ae.vertexTop)\r\n                return ae2; // Found!\r\n            ae2 = ae2.nextInAEL;\r\n        }\r\n        return undefined;\r\n    }\r\n    static getCurrYMaximaVertex_Open(ae) {\r\n        let result = ae.vertexTop;\r\n        if (ae.windDx > 0) {\r\n            while (result.next.pt.y === result.pt.y &&\r\n                ((result.flags & (VertexFlags.OpenEnd |\r\n                    VertexFlags.LocalMax)) === VertexFlags.None))\r\n                result = result.next;\r\n        }\r\n        else {\r\n            while (result.prev.pt.y === result.pt.y &&\r\n                ((result.flags & (VertexFlags.OpenEnd |\r\n                    VertexFlags.LocalMax)) === VertexFlags.None))\r\n                result = result.prev;\r\n        }\r\n        if (!ClipperBase.isMaxima(result))\r\n            result = undefined; // not a maxima\r\n        return result;\r\n    }\r\n    static getCurrYMaximaVertex(ae) {\r\n        let result = ae.vertexTop;\r\n        if (ae.windDx > 0) {\r\n            while (result.next.pt.y === result.pt.y)\r\n                result = result.next;\r\n        }\r\n        else {\r\n            while (result.prev.pt.y === result.pt.y)\r\n                result = result.prev;\r\n        }\r\n        if (!ClipperBase.isMaxima(result))\r\n            result = undefined; // not a maxima\r\n        return result;\r\n    }\r\n    static setSides(outrec, startEdge, endEdge) {\r\n        outrec.frontEdge = startEdge;\r\n        outrec.backEdge = endEdge;\r\n    }\r\n    static swapOutrecs(ae1, ae2) {\r\n        const or1 = ae1.outrec;\r\n        const or2 = ae2.outrec;\r\n        if (or1 === or2) {\r\n            const ae = or1.frontEdge;\r\n            or1.frontEdge = or1.backEdge;\r\n            or1.backEdge = ae;\r\n            return;\r\n        }\r\n        if (or1) {\r\n            if (ae1 === or1.frontEdge)\r\n                or1.frontEdge = ae2;\r\n            else\r\n                or1.backEdge = ae2;\r\n        }\r\n        if (or2) {\r\n            if (ae2 === or2.frontEdge)\r\n                or2.frontEdge = ae1;\r\n            else\r\n                or2.backEdge = ae1;\r\n        }\r\n        ae1.outrec = or2;\r\n        ae2.outrec = or1;\r\n    }\r\n    static setOwner(outrec, newOwner) {\r\n        while (newOwner.owner && !newOwner.owner.pts) {\r\n            newOwner.owner = newOwner.owner.owner;\r\n        }\r\n        //make sure that outrec isn't an owner of newOwner\r\n        let tmp = newOwner;\r\n        while (tmp && tmp !== outrec)\r\n            tmp = tmp.owner;\r\n        if (tmp)\r\n            newOwner.owner = outrec.owner;\r\n        outrec.owner = newOwner;\r\n    }\r\n    static area(op) {\r\n        // https://en.wikipedia.org/wiki/Shoelace_formula\r\n        let area = 0.0;\r\n        let op2 = op;\r\n        do {\r\n            area += (op2.prev.pt.y + op2.pt.y) *\r\n                (op2.prev.pt.x - op2.pt.x);\r\n            op2 = op2.next;\r\n        } while (op2 !== op);\r\n        return area * 0.5;\r\n    }\r\n    static areaTriangle(pt1, pt2, pt3) {\r\n        return (pt3.y + pt1.y) * (pt3.x - pt1.x) +\r\n            (pt1.y + pt2.y) * (pt1.x - pt2.x) +\r\n            (pt2.y + pt3.y) * (pt2.x - pt3.x);\r\n    }\r\n    static getRealOutRec(outRec) {\r\n        while (outRec !== undefined && outRec.pts === undefined) {\r\n            outRec = outRec.owner;\r\n        }\r\n        return outRec;\r\n    }\r\n    static isValidOwner(outRec, testOwner) {\r\n        while (testOwner !== undefined && testOwner !== outRec)\r\n            testOwner = testOwner.owner;\r\n        return testOwner === undefined;\r\n    }\r\n    static uncoupleOutRec(ae) {\r\n        const outrec = ae.outrec;\r\n        if (outrec === undefined)\r\n            return;\r\n        outrec.frontEdge.outrec = undefined;\r\n        outrec.backEdge.outrec = undefined;\r\n        outrec.frontEdge = undefined;\r\n        outrec.backEdge = undefined;\r\n    }\r\n    static outrecIsAscending(hotEdge) {\r\n        return (hotEdge === hotEdge.outrec.frontEdge);\r\n    }\r\n    static swapFrontBackSides(outrec) {\r\n        // while this proc. is needed for open paths\r\n        // it's almost never needed for closed paths\r\n        const ae2 = outrec.frontEdge;\r\n        outrec.frontEdge = outrec.backEdge;\r\n        outrec.backEdge = ae2;\r\n        outrec.pts = outrec.pts.next;\r\n    }\r\n    static edgesAdjacentInAEL(inode) {\r\n        return (inode.edge1.nextInAEL === inode.edge2) || (inode.edge1.prevInAEL === inode.edge2);\r\n    }\r\n    clearSolutionOnly() {\r\n        while (this._actives)\r\n            this.deleteFromAEL(this._actives);\r\n        this._scanlineList.clear();\r\n        this.disposeIntersectNodes();\r\n        this._outrecList.length = 0;\r\n        this._horzSegList.length = 0;\r\n        this._horzJoinList.length = 0;\r\n    }\r\n    clear() {\r\n        this.clearSolutionOnly();\r\n        this._minimaList.length = 0;\r\n        this._vertexList.length = 0;\r\n        this._currentLocMin = 0;\r\n        this._isSortedMinimaList = false;\r\n        this._hasOpenPaths = false;\r\n    }\r\n    reset() {\r\n        if (!this._isSortedMinimaList) {\r\n            this._minimaList.sort((locMin1, locMin2) => locMin2.vertex.pt.y - locMin1.vertex.pt.y);\r\n            this._isSortedMinimaList = true;\r\n        }\r\n        for (let i = this._minimaList.length - 1; i >= 0; i--) {\r\n            this._scanlineList.add(this._minimaList[i].vertex.pt.y);\r\n        }\r\n        this._currentBotY = 0;\r\n        this._currentLocMin = 0;\r\n        this._actives = undefined;\r\n        this._sel = undefined;\r\n        this._succeeded = true;\r\n    }\r\n    insertScanline(y) {\r\n        this._scanlineList.add(y);\r\n    }\r\n    popScanline() {\r\n        return this._scanlineList.pollLast();\r\n    }\r\n    hasLocMinAtY(y) {\r\n        return (this._currentLocMin < this._minimaList.length && this._minimaList[this._currentLocMin].vertex.pt.y == y);\r\n    }\r\n    popLocalMinima() {\r\n        return this._minimaList[this._currentLocMin++];\r\n    }\r\n    addLocMin(vert, polytype, isOpen) {\r\n        // make sure the vertex is added only once ...\r\n        if ((vert.flags & VertexFlags.LocalMin) != VertexFlags.None)\r\n            return;\r\n        vert.flags |= VertexFlags.LocalMin;\r\n        const lm = new LocalMinima(vert, polytype, isOpen);\r\n        this._minimaList.push(lm);\r\n    }\r\n    addSubject(path) {\r\n        this.addPath(path, PathType.Subject);\r\n    }\r\n    addOpenSubject(path) {\r\n        this.addPath(path, PathType.Subject, true);\r\n    }\r\n    addClip(path) {\r\n        this.addPath(path, PathType.Clip);\r\n    }\r\n    addPath(path, polytype, isOpen = false) {\r\n        const tmp = [path];\r\n        this.addPaths(tmp, polytype, isOpen);\r\n    }\r\n    addPaths(paths, polytype, isOpen = false) {\r\n        if (isOpen)\r\n            this._hasOpenPaths = true;\r\n        this._isSortedMinimaList = false;\r\n        ClipperEngine.addPathsToVertexList(paths, polytype, isOpen, this._minimaList, this._vertexList);\r\n    }\r\n    addReuseableData(reuseableData) {\r\n        if (reuseableData._minimaList.length === 0)\r\n            return;\r\n        this._isSortedMinimaList = false;\r\n        for (const lm of reuseableData._minimaList) {\r\n            this._minimaList.push(new LocalMinima(lm.vertex, lm.polytype, lm.isOpen));\r\n            if (lm.isOpen)\r\n                this._hasOpenPaths = true;\r\n        }\r\n    }\r\n    isContributingClosed(ae) {\r\n        switch (this._fillrule) {\r\n            case FillRule.Positive:\r\n                if (ae.windCount !== 1)\r\n                    return false;\r\n                break;\r\n            case FillRule.Negative:\r\n                if (ae.windCount !== -1)\r\n                    return false;\r\n                break;\r\n            case FillRule.NonZero:\r\n                if (Math.abs(ae.windCount) !== 1)\r\n                    return false;\r\n                break;\r\n        }\r\n        switch (this._cliptype) {\r\n            case ClipType.Intersection:\r\n                switch (this._fillrule) {\r\n                    case FillRule.Positive: return ae.windCount2 > 0;\r\n                    case FillRule.Negative: return ae.windCount2 < 0;\r\n                    default: return ae.windCount2 !== 0;\r\n                }\r\n            case ClipType.Union:\r\n                switch (this._fillrule) {\r\n                    case FillRule.Positive: return ae.windCount2 <= 0;\r\n                    case FillRule.Negative: return ae.windCount2 >= 0;\r\n                    default: return ae.windCount2 === 0;\r\n                }\r\n            case ClipType.Difference:\r\n                const result = this._fillrule === FillRule.Positive ? (ae.windCount2 <= 0) :\r\n                    this._fillrule === FillRule.Negative ? (ae.windCount2 >= 0) :\r\n                        (ae.windCount2 === 0);\r\n                return ClipperBase.getPolyType(ae) === PathType.Subject ? result : !result;\r\n            case ClipType.Xor:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    isContributingOpen(ae) {\r\n        let isInClip, isInSubj;\r\n        switch (this._fillrule) {\r\n            case FillRule.Positive:\r\n                isInSubj = ae.windCount > 0;\r\n                isInClip = ae.windCount2 > 0;\r\n                break;\r\n            case FillRule.Negative:\r\n                isInSubj = ae.windCount < 0;\r\n                isInClip = ae.windCount2 < 0;\r\n                break;\r\n            default:\r\n                isInSubj = ae.windCount !== 0;\r\n                isInClip = ae.windCount2 !== 0;\r\n                break;\r\n        }\r\n        switch (this._cliptype) {\r\n            case ClipType.Intersection:\r\n                return isInClip;\r\n            case ClipType.Union:\r\n                return !isInSubj && !isInClip;\r\n            default:\r\n                return !isInClip;\r\n        }\r\n    }\r\n    setWindCountForClosedPathEdge(ae) {\r\n        let ae2 = ae.prevInAEL;\r\n        const pt = ClipperBase.getPolyType(ae);\r\n        while (ae2 !== undefined && (ClipperBase.getPolyType(ae2) !== pt || ClipperBase.isOpen(ae2))) {\r\n            ae2 = ae2.prevInAEL;\r\n        }\r\n        if (ae2 === undefined) {\r\n            ae.windCount = ae.windDx;\r\n            ae2 = this._actives;\r\n        }\r\n        else if (this._fillrule === FillRule.EvenOdd) {\r\n            ae.windCount = ae.windDx;\r\n            ae.windCount2 = ae2.windCount2;\r\n            ae2 = ae2.nextInAEL;\r\n        }\r\n        else {\r\n            // NonZero, positive, or negative filling here ...\r\n            // when e2's WindCnt is in the SAME direction as its WindDx,\r\n            // then polygon will fill on the right of 'e2' (and 'e' will be inside)\r\n            // nb: neither e2.WindCnt nor e2.WindDx should ever be 0.\r\n            if (ae2.windCount * ae2.windDx < 0) {\r\n                // opposite directions so 'ae' is outside 'ae2' ...\r\n                if (Math.abs(ae2.windCount) > 1) {\r\n                    // outside prev poly but still inside another.\r\n                    if (ae2.windDx * ae.windDx < 0)\r\n                        // reversing direction so use the same WC\r\n                        ae.windCount = ae2.windCount;\r\n                    else\r\n                        // otherwise keep 'reducing' the WC by 1 (i.e. towards 0) ...\r\n                        ae.windCount = ae2.windCount + ae.windDx;\r\n                }\r\n                else {\r\n                    // now outside all polys of same polytype so set own WC ...\r\n                    ae.windCount = (ClipperBase.isOpen(ae) ? 1 : ae.windDx);\r\n                }\r\n            }\r\n            else {\r\n                // 'ae' must be inside 'ae2'\r\n                if (ae2.windDx * ae.windDx < 0)\r\n                    // reversing direction so use the same WC\r\n                    ae.windCount = ae2.windCount;\r\n                else\r\n                    // otherwise keep 'increasing' the WC by 1 (i.e. away from 0) ...\r\n                    ae.windCount = ae2.windCount + ae.windDx;\r\n            }\r\n            ae.windCount2 = ae2.windCount2;\r\n            ae2 = ae2.nextInAEL; // i.e. get ready to calc WindCnt2\r\n        }\r\n        if (this._fillrule === FillRule.EvenOdd) {\r\n            while (ae2 !== ae) {\r\n                if (ClipperBase.getPolyType(ae2) !== pt && !ClipperBase.isOpen(ae2)) {\r\n                    ae.windCount2 = (ae.windCount2 === 0 ? 1 : 0);\r\n                }\r\n                ae2 = ae2.nextInAEL;\r\n            }\r\n        }\r\n        else {\r\n            while (ae2 !== ae) {\r\n                if (ClipperBase.getPolyType(ae2) !== pt && !ClipperBase.isOpen(ae2)) {\r\n                    ae.windCount2 += ae2.windDx;\r\n                }\r\n                ae2 = ae2.nextInAEL;\r\n            }\r\n        }\r\n    }\r\n    setWindCountForOpenPathEdge(ae) {\r\n        let ae2 = this._actives;\r\n        if (this._fillrule === FillRule.EvenOdd) {\r\n            let cnt1 = 0, cnt2 = 0;\r\n            while (ae2 !== ae) {\r\n                if (ClipperBase.getPolyType(ae2) === PathType.Clip)\r\n                    cnt2++;\r\n                else if (!ClipperBase.isOpen(ae2))\r\n                    cnt1++;\r\n                ae2 = ae2.nextInAEL;\r\n            }\r\n            ae.windCount = (ClipperBase.isOdd(cnt1) ? 1 : 0);\r\n            ae.windCount2 = (ClipperBase.isOdd(cnt2) ? 1 : 0);\r\n        }\r\n        else {\r\n            while (ae2 !== ae) {\r\n                if (ClipperBase.getPolyType(ae2) === PathType.Clip)\r\n                    ae.windCount2 += ae2.windDx;\r\n                else if (!ClipperBase.isOpen(ae2))\r\n                    ae.windCount += ae2.windDx;\r\n                ae2 = ae2.nextInAEL;\r\n            }\r\n        }\r\n    }\r\n    static isValidAelOrder(resident, newcomer) {\r\n        if (newcomer.curX !== resident.curX)\r\n            return newcomer.curX > resident.curX;\r\n        // get the turning direction  a1.top, a2.bot, a2.top\r\n        const d = InternalClipper.crossProduct(resident.top, newcomer.bot, newcomer.top);\r\n        if (d !== 0.0)\r\n            return (d < 0);\r\n        // edges must be collinear to get here\r\n        // for starting open paths, place them according to\r\n        // the direction they're about to turn\r\n        if (!this.isMaximaActive(resident) && (resident.top.y > newcomer.top.y)) {\r\n            return InternalClipper.crossProduct(newcomer.bot, resident.top, this.nextVertex(resident).pt) <= 0;\r\n        }\r\n        if (!this.isMaximaActive(newcomer) && (newcomer.top.y > resident.top.y)) {\r\n            return InternalClipper.crossProduct(newcomer.bot, newcomer.top, this.nextVertex(newcomer).pt) >= 0;\r\n        }\r\n        const y = newcomer.bot.y;\r\n        const newcomerIsLeft = newcomer.isLeftBound;\r\n        if (resident.bot.y !== y || resident.localMin.vertex.pt.y !== y)\r\n            return newcomer.isLeftBound;\r\n        // resident must also have just been inserted\r\n        if (resident.isLeftBound !== newcomerIsLeft)\r\n            return newcomerIsLeft;\r\n        if (InternalClipper.crossProduct(this.prevPrevVertex(resident).pt, resident.bot, resident.top) === 0)\r\n            return true;\r\n        // compare turning direction of the alternate bound\r\n        return (InternalClipper.crossProduct(this.prevPrevVertex(resident).pt, newcomer.bot, this.prevPrevVertex(newcomer).pt) > 0) === newcomerIsLeft;\r\n    }\r\n    insertLeftEdge(ae) {\r\n        let ae2;\r\n        if (!this._actives) {\r\n            ae.prevInAEL = undefined;\r\n            ae.nextInAEL = undefined;\r\n            this._actives = ae;\r\n        }\r\n        else if (!ClipperBase.isValidAelOrder(this._actives, ae)) {\r\n            ae.prevInAEL = undefined;\r\n            ae.nextInAEL = this._actives;\r\n            this._actives.prevInAEL = ae;\r\n            this._actives = ae;\r\n        }\r\n        else {\r\n            ae2 = this._actives;\r\n            while (ae2.nextInAEL && ClipperBase.isValidAelOrder(ae2.nextInAEL, ae))\r\n                ae2 = ae2.nextInAEL;\r\n            //don't separate joined edges\r\n            if (ae2.joinWith === JoinWith.Right)\r\n                ae2 = ae2.nextInAEL;\r\n            ae.nextInAEL = ae2.nextInAEL;\r\n            if (ae2.nextInAEL)\r\n                ae2.nextInAEL.prevInAEL = ae;\r\n            ae.prevInAEL = ae2;\r\n            ae2.nextInAEL = ae;\r\n        }\r\n    }\r\n    static insertRightEdge(ae, ae2) {\r\n        ae2.nextInAEL = ae.nextInAEL;\r\n        if (ae.nextInAEL)\r\n            ae.nextInAEL.prevInAEL = ae2;\r\n        ae2.prevInAEL = ae;\r\n        ae.nextInAEL = ae2;\r\n    }\r\n    insertLocalMinimaIntoAEL(botY) {\r\n        let localMinima;\r\n        let leftBound;\r\n        let rightBound;\r\n        // Add any local minima (if any) at BotY ...\r\n        // NB horizontal local minima edges should contain locMin.vertex.prev\r\n        while (this.hasLocMinAtY(botY)) {\r\n            localMinima = this.popLocalMinima();\r\n            if ((localMinima.vertex.flags & VertexFlags.OpenStart) !== VertexFlags.None) {\r\n                leftBound = undefined;\r\n            }\r\n            else {\r\n                leftBound = new Active();\r\n                leftBound.bot = localMinima.vertex.pt;\r\n                leftBound.curX = localMinima.vertex.pt.x;\r\n                leftBound.windDx = -1;\r\n                leftBound.vertexTop = localMinima.vertex.prev;\r\n                leftBound.top = localMinima.vertex.prev.pt;\r\n                leftBound.outrec = undefined;\r\n                leftBound.localMin = localMinima;\r\n                ClipperBase.setDx(leftBound);\r\n            }\r\n            if ((localMinima.vertex.flags & VertexFlags.OpenEnd) !== VertexFlags.None) {\r\n                rightBound = undefined;\r\n            }\r\n            else {\r\n                rightBound = new Active();\r\n                rightBound.bot = localMinima.vertex.pt;\r\n                rightBound.curX = localMinima.vertex.pt.x;\r\n                rightBound.windDx = 1;\r\n                rightBound.vertexTop = localMinima.vertex.next;\r\n                rightBound.top = localMinima.vertex.next.pt;\r\n                rightBound.outrec = undefined;\r\n                rightBound.localMin = localMinima;\r\n                ClipperBase.setDx(rightBound);\r\n            }\r\n            if (leftBound && rightBound) {\r\n                if (ClipperBase.isHorizontal(leftBound)) {\r\n                    if (ClipperBase.isHeadingRightHorz(leftBound)) {\r\n                        [rightBound, leftBound] = [leftBound, rightBound];\r\n                    }\r\n                }\r\n                else if (ClipperBase.isHorizontal(rightBound)) {\r\n                    if (ClipperBase.isHeadingLeftHorz(rightBound)) {\r\n                        [rightBound, leftBound] = [leftBound, rightBound];\r\n                    }\r\n                }\r\n                else if (leftBound.dx < rightBound.dx) {\r\n                    [rightBound, leftBound] = [leftBound, rightBound];\r\n                }\r\n                //so when leftBound has windDx == 1, the polygon will be oriented\r\n                //counter-clockwise in Cartesian coords (clockwise with inverted Y).\r\n            }\r\n            else if (leftBound === undefined) {\r\n                leftBound = rightBound;\r\n                rightBound = undefined;\r\n            }\r\n            let contributing = false;\r\n            leftBound.isLeftBound = true;\r\n            this.insertLeftEdge(leftBound);\r\n            if (ClipperBase.isOpen(leftBound)) {\r\n                this.setWindCountForOpenPathEdge(leftBound);\r\n                contributing = this.isContributingOpen(leftBound);\r\n            }\r\n            else {\r\n                this.setWindCountForClosedPathEdge(leftBound);\r\n                contributing = this.isContributingClosed(leftBound);\r\n            }\r\n            if (rightBound) {\r\n                rightBound.windCount = leftBound.windCount;\r\n                rightBound.windCount2 = leftBound.windCount2;\r\n                ClipperBase.insertRightEdge(leftBound, rightBound);\r\n                if (contributing) {\r\n                    this.addLocalMinPoly(leftBound, rightBound, leftBound.bot, true);\r\n                    if (!ClipperBase.isHorizontal(leftBound)) {\r\n                        this.checkJoinLeft(leftBound, leftBound.bot);\r\n                    }\r\n                }\r\n                while (rightBound.nextInAEL &&\r\n                    ClipperBase.isValidAelOrder(rightBound.nextInAEL, rightBound)) {\r\n                    this.intersectEdges(rightBound, rightBound.nextInAEL, rightBound.bot);\r\n                    this.swapPositionsInAEL(rightBound, rightBound.nextInAEL);\r\n                }\r\n                if (ClipperBase.isHorizontal(rightBound)) {\r\n                    this.pushHorz(rightBound);\r\n                }\r\n                else {\r\n                    this.checkJoinRight(rightBound, rightBound.bot);\r\n                    this.insertScanline(rightBound.top.y);\r\n                }\r\n            }\r\n            else if (contributing) {\r\n                this.startOpenPath(leftBound, leftBound.bot);\r\n            }\r\n            if (ClipperBase.isHorizontal(leftBound)) {\r\n                this.pushHorz(leftBound);\r\n            }\r\n            else {\r\n                this.insertScanline(leftBound.top.y);\r\n            }\r\n        }\r\n    }\r\n    pushHorz(ae) {\r\n        ae.nextInSEL = this._sel;\r\n        this._sel = ae;\r\n    }\r\n    popHorz() {\r\n        const ae = this._sel;\r\n        if (this._sel === undefined)\r\n            return undefined;\r\n        this._sel = this._sel.nextInSEL;\r\n        return ae;\r\n    }\r\n    addLocalMinPoly(ae1, ae2, pt, isNew = false) {\r\n        const outrec = this.newOutRec();\r\n        ae1.outrec = outrec;\r\n        ae2.outrec = outrec;\r\n        if (ClipperBase.isOpen(ae1)) {\r\n            outrec.owner = undefined;\r\n            outrec.isOpen = true;\r\n            if (ae1.windDx > 0)\r\n                ClipperBase.setSides(outrec, ae1, ae2);\r\n            else\r\n                ClipperBase.setSides(outrec, ae2, ae1);\r\n        }\r\n        else {\r\n            outrec.isOpen = false;\r\n            const prevHotEdge = ClipperBase.getPrevHotEdge(ae1);\r\n            // e.windDx is the winding direction of the **input** paths\r\n            // and unrelated to the winding direction of output polygons.\r\n            // Output orientation is determined by e.outrec.frontE which is\r\n            // the ascending edge (see AddLocalMinPoly).\r\n            if (prevHotEdge) {\r\n                if (this._using_polytree)\r\n                    ClipperBase.setOwner(outrec, prevHotEdge.outrec);\r\n                outrec.owner = prevHotEdge.outrec;\r\n                if (ClipperBase.outrecIsAscending(prevHotEdge) === isNew)\r\n                    ClipperBase.setSides(outrec, ae2, ae1);\r\n                else\r\n                    ClipperBase.setSides(outrec, ae1, ae2);\r\n            }\r\n            else {\r\n                outrec.owner = undefined;\r\n                if (isNew)\r\n                    ClipperBase.setSides(outrec, ae1, ae2);\r\n                else\r\n                    ClipperBase.setSides(outrec, ae2, ae1);\r\n            }\r\n        }\r\n        const op = new OutPt(pt, outrec);\r\n        outrec.pts = op;\r\n        return op;\r\n    }\r\n    addLocalMaxPoly(ae1, ae2, pt) {\r\n        if (ClipperBase.isJoined(ae1))\r\n            this.split(ae1, pt);\r\n        if (ClipperBase.isJoined(ae2))\r\n            this.split(ae2, pt);\r\n        if (ClipperBase.isFront(ae1) === ClipperBase.isFront(ae2)) {\r\n            if (ClipperBase.isOpenEndActive(ae1))\r\n                ClipperBase.swapFrontBackSides(ae1.outrec);\r\n            else if (ClipperBase.isOpenEndActive(ae2))\r\n                ClipperBase.swapFrontBackSides(ae2.outrec);\r\n            else {\r\n                this._succeeded = false;\r\n                return undefined;\r\n            }\r\n        }\r\n        const result = ClipperBase.addOutPt(ae1, pt);\r\n        if (ae1.outrec === ae2.outrec) {\r\n            const outrec = ae1.outrec;\r\n            outrec.pts = result;\r\n            if (this._using_polytree) {\r\n                const e = ClipperBase.getPrevHotEdge(ae1);\r\n                if (e === undefined)\r\n                    outrec.owner = undefined;\r\n                else\r\n                    ClipperBase.setOwner(outrec, e.outrec);\r\n            }\r\n            ClipperBase.uncoupleOutRec(ae1);\r\n        }\r\n        else if (ClipperBase.isOpen(ae1)) {\r\n            if (ae1.windDx < 0)\r\n                ClipperBase.joinOutrecPaths(ae1, ae2);\r\n            else\r\n                ClipperBase.joinOutrecPaths(ae2, ae1);\r\n        }\r\n        else if (ae1.outrec.idx < ae2.outrec.idx)\r\n            ClipperBase.joinOutrecPaths(ae1, ae2);\r\n        else\r\n            ClipperBase.joinOutrecPaths(ae2, ae1);\r\n        return result;\r\n    }\r\n    static joinOutrecPaths(ae1, ae2) {\r\n        // join ae2 outrec path onto ae1 outrec path and then delete ae2 outrec path\r\n        // pointers. (NB Only very rarely do the joining ends share the same coords.)\r\n        const p1Start = ae1.outrec.pts;\r\n        const p2Start = ae2.outrec.pts;\r\n        const p1End = p1Start.next;\r\n        const p2End = p2Start.next;\r\n        if (ClipperBase.isFront(ae1)) {\r\n            p2End.prev = p1Start;\r\n            p1Start.next = p2End;\r\n            p2Start.next = p1End;\r\n            p1End.prev = p2Start;\r\n            ae1.outrec.pts = p2Start;\r\n            // nb: if IsOpen(e1) then e1 & e2 must be a 'maximaPair'\r\n            ae1.outrec.frontEdge = ae2.outrec.frontEdge;\r\n            if (ae1.outrec.frontEdge)\r\n                ae1.outrec.frontEdge.outrec = ae1.outrec;\r\n        }\r\n        else {\r\n            p1End.prev = p2Start;\r\n            p2Start.next = p1End;\r\n            p1Start.next = p2End;\r\n            p2End.prev = p1Start;\r\n            ae1.outrec.backEdge = ae2.outrec.backEdge;\r\n            if (ae1.outrec.backEdge)\r\n                ae1.outrec.backEdge.outrec = ae1.outrec;\r\n        }\r\n        // after joining, the ae2.OutRec must contains no vertices ...\r\n        ae2.outrec.frontEdge = undefined;\r\n        ae2.outrec.backEdge = undefined;\r\n        ae2.outrec.pts = undefined;\r\n        ClipperBase.setOwner(ae2.outrec, ae1.outrec);\r\n        if (ClipperBase.isOpenEndActive(ae1)) {\r\n            ae2.outrec.pts = ae1.outrec.pts;\r\n            ae1.outrec.pts = undefined;\r\n        }\r\n        // and ae1 and ae2 are maxima and are about to be dropped from the Actives list.\r\n        ae1.outrec = undefined;\r\n        ae2.outrec = undefined;\r\n    }\r\n    static addOutPt(ae, pt) {\r\n        const outrec = ae.outrec;\r\n        const toFront = ClipperBase.isFront(ae);\r\n        const opFront = outrec.pts;\r\n        const opBack = opFront.next;\r\n        if (toFront && (pt == opFront.pt))\r\n            return opFront;\r\n        else if (!toFront && (pt == opBack.pt))\r\n            return opBack;\r\n        const newOp = new OutPt(pt, outrec);\r\n        opBack.prev = newOp;\r\n        newOp.prev = opFront;\r\n        newOp.next = opBack;\r\n        opFront.next = newOp;\r\n        if (toFront)\r\n            outrec.pts = newOp;\r\n        return newOp;\r\n    }\r\n    newOutRec() {\r\n        const result = new OutRec(this._outrecList.length);\r\n        this._outrecList.push(result);\r\n        return result;\r\n    }\r\n    startOpenPath(ae, pt) {\r\n        const outrec = this.newOutRec();\r\n        outrec.isOpen = true;\r\n        if (ae.windDx > 0) {\r\n            outrec.frontEdge = ae;\r\n            outrec.backEdge = undefined;\r\n        }\r\n        else {\r\n            outrec.frontEdge = undefined;\r\n            outrec.backEdge = ae;\r\n        }\r\n        ae.outrec = outrec;\r\n        const op = new OutPt(pt, outrec);\r\n        outrec.pts = op;\r\n        return op;\r\n    }\r\n    updateEdgeIntoAEL(ae) {\r\n        ae.bot = ae.top;\r\n        ae.vertexTop = ClipperBase.nextVertex(ae);\r\n        ae.top = ae.vertexTop.pt;\r\n        ae.curX = ae.bot.x;\r\n        ClipperBase.setDx(ae);\r\n        if (ClipperBase.isJoined(ae))\r\n            this.split(ae, ae.bot);\r\n        if (ClipperBase.isHorizontal(ae))\r\n            return;\r\n        this.insertScanline(ae.top.y);\r\n        this.checkJoinLeft(ae, ae.bot);\r\n        this.checkJoinRight(ae, ae.bot, true);\r\n    }\r\n    static findEdgeWithMatchingLocMin(e) {\r\n        let result = e.nextInAEL;\r\n        while (result) {\r\n            if (result.localMin === e.localMin)\r\n                return result;\r\n            if (!ClipperBase.isHorizontal(result) && e.bot !== result.bot)\r\n                result = undefined;\r\n            else\r\n                result = result.nextInAEL;\r\n        }\r\n        result = e.prevInAEL;\r\n        while (result) {\r\n            if (result.localMin === e.localMin)\r\n                return result;\r\n            if (!ClipperBase.isHorizontal(result) && e.bot !== result.bot)\r\n                return undefined;\r\n            result = result.prevInAEL;\r\n        }\r\n        return result;\r\n    }\r\n    intersectEdges(ae1, ae2, pt) {\r\n        let resultOp = undefined;\r\n        // MANAGE OPEN PATH INTERSECTIONS SEPARATELY ...\r\n        if (this._hasOpenPaths && (ClipperBase.isOpen(ae1) || ClipperBase.isOpen(ae2))) {\r\n            if (ClipperBase.isOpen(ae1) && ClipperBase.isOpen(ae2))\r\n                return undefined;\r\n            // the following line avoids duplicating quite a bit of code\r\n            if (ClipperBase.isOpen(ae2))\r\n                ClipperBase.swapActives(ae1, ae2);\r\n            if (ClipperBase.isJoined(ae2))\r\n                this.split(ae2, pt);\r\n            if (this._cliptype === ClipType.Union) {\r\n                if (!ClipperBase.isHotEdgeActive(ae2))\r\n                    return undefined;\r\n            }\r\n            else if (ae2.localMin.polytype === PathType.Subject)\r\n                return undefined;\r\n            switch (this._fillrule) {\r\n                case FillRule.Positive:\r\n                    if (ae2.windCount !== 1)\r\n                        return undefined;\r\n                    break;\r\n                case FillRule.Negative:\r\n                    if (ae2.windCount !== -1)\r\n                        return undefined;\r\n                    break;\r\n                default:\r\n                    if (Math.abs(ae2.windCount) !== 1)\r\n                        return undefined;\r\n                    break;\r\n            }\r\n            // toggle contribution ...\r\n            if (ClipperBase.isHotEdgeActive(ae1)) {\r\n                resultOp = ClipperBase.addOutPt(ae1, pt);\r\n                if (ClipperBase.isFront(ae1)) {\r\n                    ae1.outrec.frontEdge = undefined;\r\n                }\r\n                else {\r\n                    ae1.outrec.backEdge = undefined;\r\n                }\r\n                ae1.outrec = undefined;\r\n                // horizontal edges can pass under open paths at a LocMins\r\n            }\r\n            else if (pt === ae1.localMin.vertex.pt && !ClipperBase.isOpenEnd(ae1.localMin.vertex)) {\r\n                // find the other side of the LocMin and\r\n                // if it's 'hot' join up with it ...\r\n                const ae3 = ClipperBase.findEdgeWithMatchingLocMin(ae1);\r\n                if (ae3 && ClipperBase.isHotEdgeActive(ae3)) {\r\n                    ae1.outrec = ae3.outrec;\r\n                    if (ae1.windDx > 0) {\r\n                        ClipperBase.setSides(ae3.outrec, ae1, ae3);\r\n                    }\r\n                    else {\r\n                        ClipperBase.setSides(ae3.outrec, ae3, ae1);\r\n                    }\r\n                    return ae3.outrec.pts;\r\n                }\r\n                resultOp = this.startOpenPath(ae1, pt);\r\n            }\r\n            else {\r\n                resultOp = this.startOpenPath(ae1, pt);\r\n            }\r\n            return resultOp;\r\n        }\r\n        // MANAGING CLOSED PATHS FROM HERE ON\r\n        if (ClipperBase.isJoined(ae1))\r\n            this.split(ae1, pt);\r\n        if (ClipperBase.isJoined(ae2))\r\n            this.split(ae2, pt);\r\n        // UPDATE WINDING COUNTS...\r\n        let oldE1WindCount;\r\n        let oldE2WindCount;\r\n        if (ae1.localMin.polytype === ae2.localMin.polytype) {\r\n            if (this._fillrule === FillRule.EvenOdd) {\r\n                oldE1WindCount = ae1.windCount;\r\n                ae1.windCount = ae2.windCount;\r\n                ae2.windCount = oldE1WindCount;\r\n            }\r\n            else {\r\n                if (ae1.windCount + ae2.windDx === 0)\r\n                    ae1.windCount = -ae1.windCount;\r\n                else\r\n                    ae1.windCount += ae2.windDx;\r\n                if (ae2.windCount - ae1.windDx === 0)\r\n                    ae2.windCount = -ae2.windCount;\r\n                else\r\n                    ae2.windCount -= ae1.windDx;\r\n            }\r\n        }\r\n        else {\r\n            if (this._fillrule !== FillRule.EvenOdd)\r\n                ae1.windCount2 += ae2.windDx;\r\n            else\r\n                ae1.windCount2 = (ae1.windCount2 === 0 ? 1 : 0);\r\n            if (this._fillrule !== FillRule.EvenOdd)\r\n                ae2.windCount2 -= ae1.windDx;\r\n            else\r\n                ae2.windCount2 = (ae2.windCount2 === 0 ? 1 : 0);\r\n        }\r\n        switch (this._fillrule) {\r\n            case FillRule.Positive:\r\n                oldE1WindCount = ae1.windCount;\r\n                oldE2WindCount = ae2.windCount;\r\n                break;\r\n            case FillRule.Negative:\r\n                oldE1WindCount = -ae1.windCount;\r\n                oldE2WindCount = -ae2.windCount;\r\n                break;\r\n            default:\r\n                oldE1WindCount = Math.abs(ae1.windCount);\r\n                oldE2WindCount = Math.abs(ae2.windCount);\r\n                break;\r\n        }\r\n        const e1WindCountIs0or1 = oldE1WindCount === 0 || oldE1WindCount === 1;\r\n        const e2WindCountIs0or1 = oldE2WindCount === 0 || oldE2WindCount === 1;\r\n        if ((!ClipperBase.isHotEdgeActive(ae1) && !e1WindCountIs0or1) || (!ClipperBase.isHotEdgeActive(ae2) && !e2WindCountIs0or1))\r\n            return undefined;\r\n        // NOW PROCESS THE INTERSECTION ...\r\n        // if both edges are 'hot' ...\r\n        if (ClipperBase.isHotEdgeActive(ae1) && ClipperBase.isHotEdgeActive(ae2)) {\r\n            if ((oldE1WindCount !== 0 && oldE1WindCount !== 1) ||\r\n                (oldE2WindCount !== 0 && oldE2WindCount !== 1) ||\r\n                (ae1.localMin.polytype !== ae2.localMin.polytype &&\r\n                    this._cliptype !== ClipType.Xor)) {\r\n                resultOp = this.addLocalMaxPoly(ae1, ae2, pt);\r\n            }\r\n            else if (ClipperBase.isFront(ae1) || (ae1.outrec === ae2.outrec)) {\r\n                // this 'else if' condition isn't strictly needed but\r\n                // it's sensible to split polygons that only touch at\r\n                // a common vertex (not at common edges).\r\n                resultOp = this.addLocalMaxPoly(ae1, ae2, pt);\r\n                this.addLocalMinPoly(ae1, ae2, pt);\r\n            }\r\n            else {\r\n                // can't treat as maxima & minima\r\n                resultOp = ClipperBase.addOutPt(ae1, pt);\r\n                ClipperBase.addOutPt(ae2, pt);\r\n                ClipperBase.swapOutrecs(ae1, ae2);\r\n            }\r\n        }\r\n        // if one or the other edge is 'hot' ...\r\n        else if (ClipperBase.isHotEdgeActive(ae1)) {\r\n            resultOp = ClipperBase.addOutPt(ae1, pt);\r\n            ClipperBase.swapOutrecs(ae1, ae2);\r\n        }\r\n        else if (ClipperBase.isHotEdgeActive(ae2)) {\r\n            resultOp = ClipperBase.addOutPt(ae2, pt);\r\n            ClipperBase.swapOutrecs(ae1, ae2);\r\n        }\r\n        // neither edge is 'hot'\r\n        else {\r\n            let e1Wc2;\r\n            let e2Wc2;\r\n            switch (this._fillrule) {\r\n                case FillRule.Positive:\r\n                    e1Wc2 = ae1.windCount2;\r\n                    e2Wc2 = ae2.windCount2;\r\n                    break;\r\n                case FillRule.Negative:\r\n                    e1Wc2 = -ae1.windCount2;\r\n                    e2Wc2 = -ae2.windCount2;\r\n                    break;\r\n                default:\r\n                    e1Wc2 = Math.abs(ae1.windCount2);\r\n                    e2Wc2 = Math.abs(ae2.windCount2);\r\n                    break;\r\n            }\r\n            if (!ClipperBase.isSamePolyType(ae1, ae2)) {\r\n                resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n            }\r\n            else if (oldE1WindCount === 1 && oldE2WindCount === 1) {\r\n                resultOp = undefined;\r\n                switch (this._cliptype) {\r\n                    case ClipType.Union:\r\n                        if (e1Wc2 > 0 && e2Wc2 > 0)\r\n                            return undefined;\r\n                        resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n                        break;\r\n                    case ClipType.Difference:\r\n                        if (((ClipperBase.getPolyType(ae1) === PathType.Clip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\r\n                            ((ClipperBase.getPolyType(ae1) === PathType.Subject) && (e1Wc2 <= 0) && (e2Wc2 <= 0))) {\r\n                            resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n                        }\r\n                        break;\r\n                    case ClipType.Xor:\r\n                        resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n                        break;\r\n                    default: // ClipType.Intersection:\r\n                        if (e1Wc2 <= 0 || e2Wc2 <= 0)\r\n                            return undefined;\r\n                        resultOp = this.addLocalMinPoly(ae1, ae2, pt);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        return resultOp;\r\n    }\r\n    deleteFromAEL(ae) {\r\n        const prev = ae.prevInAEL;\r\n        const next = ae.nextInAEL;\r\n        if (!prev && !next && ae !== this._actives)\r\n            return; // already deleted\r\n        if (prev)\r\n            prev.nextInAEL = next;\r\n        else\r\n            this._actives = next;\r\n        if (next)\r\n            next.prevInAEL = prev;\r\n    }\r\n    adjustCurrXAndCopyToSEL(topY) {\r\n        let ae = this._actives;\r\n        this._sel = ae;\r\n        while (ae) {\r\n            ae.prevInSEL = ae.prevInAEL;\r\n            ae.nextInSEL = ae.nextInAEL;\r\n            ae.jump = ae.nextInSEL;\r\n            if (ae.joinWith === JoinWith.Left)\r\n                ae.curX = ae.prevInAEL.curX; // This also avoids complications\r\n            else\r\n                ae.curX = ClipperBase.topX(ae, topY);\r\n            // NB don't update ae.curr.Y yet (see AddNewIntersectNode)\r\n            ae = ae.nextInAEL;\r\n        }\r\n    }\r\n    executeInternal(ct, fillRule) {\r\n        if (ct === ClipType.None)\r\n            return;\r\n        this._fillrule = fillRule;\r\n        this._cliptype = ct;\r\n        this.reset();\r\n        let y = this.popScanline();\r\n        if (y === undefined)\r\n            return;\r\n        while (this._succeeded) {\r\n            this.insertLocalMinimaIntoAEL(y);\r\n            let ae = this.popHorz();\r\n            while (ae) {\r\n                this.doHorizontal(ae);\r\n                ae = this.popHorz();\r\n            }\r\n            if (this._horzSegList.length > 0) {\r\n                this.convertHorzSegsToJoins();\r\n                this._horzSegList.length = 0;\r\n            }\r\n            this._currentBotY = y; // bottom of scanbeam\r\n            y = this.popScanline();\r\n            if (y === undefined)\r\n                break; // y new top of scanbeam\r\n            this.doIntersections(y);\r\n            this.doTopOfScanbeam(y);\r\n            ae = this.popHorz();\r\n            while (ae) {\r\n                this.doHorizontal(ae);\r\n                ae = this.popHorz();\r\n            }\r\n        }\r\n        if (this._succeeded)\r\n            this.processHorzJoins();\r\n    }\r\n    doIntersections(topY) {\r\n        if (this.buildIntersectList(topY)) {\r\n            this.processIntersectList();\r\n            this.disposeIntersectNodes();\r\n        }\r\n    }\r\n    disposeIntersectNodes() {\r\n        this._intersectList.length = 0;\r\n    }\r\n    addNewIntersectNode(ae1, ae2, topY) {\r\n        const result = InternalClipper.getIntersectPt(ae1.bot, ae1.top, ae2.bot, ae2.top);\r\n        let ip = result.ip;\r\n        if (!result.success) {\r\n            ip = new Point64(ae1.curX, topY);\r\n        }\r\n        if (ip.y > this._currentBotY || ip.y < topY) {\r\n            const absDx1 = Math.abs(ae1.dx);\r\n            const absDx2 = Math.abs(ae2.dx);\r\n            if (absDx1 > 100 && absDx2 > 100) {\r\n                if (absDx1 > absDx2) {\r\n                    ip = InternalClipper.getClosestPtOnSegment(ip, ae1.bot, ae1.top);\r\n                }\r\n                else {\r\n                    ip = InternalClipper.getClosestPtOnSegment(ip, ae2.bot, ae2.top);\r\n                }\r\n            }\r\n            else if (absDx1 > 100) {\r\n                ip = InternalClipper.getClosestPtOnSegment(ip, ae1.bot, ae1.top);\r\n            }\r\n            else if (absDx2 > 100) {\r\n                ip = InternalClipper.getClosestPtOnSegment(ip, ae2.bot, ae2.top);\r\n            }\r\n            else {\r\n                if (ip.y < topY) {\r\n                    ip.y = topY;\r\n                }\r\n                else {\r\n                    ip.y = this._currentBotY;\r\n                }\r\n                if (absDx1 < absDx2) {\r\n                    ip.x = ClipperBase.topX(ae1, ip.y);\r\n                }\r\n                else {\r\n                    ip.x = ClipperBase.topX(ae2, ip.y);\r\n                }\r\n            }\r\n        }\r\n        const node = new IntersectNode(ip, ae1, ae2);\r\n        this._intersectList.push(node);\r\n    }\r\n    static extractFromSEL(ae) {\r\n        const res = ae.nextInSEL;\r\n        if (res) {\r\n            res.prevInSEL = ae.prevInSEL;\r\n        }\r\n        ae.prevInSEL.nextInSEL = res;\r\n        return res;\r\n    }\r\n    static insert1Before2InSEL(ae1, ae2) {\r\n        ae1.prevInSEL = ae2.prevInSEL;\r\n        if (ae1.prevInSEL) {\r\n            ae1.prevInSEL.nextInSEL = ae1;\r\n        }\r\n        ae1.nextInSEL = ae2;\r\n        ae2.prevInSEL = ae1;\r\n    }\r\n    buildIntersectList(topY) {\r\n        if (!this._actives || !this._actives.nextInAEL)\r\n            return false;\r\n        // Calculate edge positions at the top of the current scanbeam, and from this\r\n        // we will determine the intersections required to reach these new positions.\r\n        this.adjustCurrXAndCopyToSEL(topY);\r\n        // Find all edge intersections in the current scanbeam using a stable merge\r\n        // sort that ensures only adjacent edges are intersecting. Intersect info is\r\n        // stored in FIntersectList ready to be processed in ProcessIntersectList.\r\n        // Re merge sorts see https://stackoverflow.com/a/46319131/359538\r\n        let left = this._sel, right, lEnd, rEnd, currBase, prevBase, tmp;\r\n        while (left.jump) {\r\n            prevBase = undefined;\r\n            while (left && left.jump) {\r\n                currBase = left;\r\n                right = left.jump;\r\n                lEnd = right;\r\n                rEnd = right.jump;\r\n                left.jump = rEnd;\r\n                while (left !== lEnd && right !== rEnd) {\r\n                    if (right.curX < left.curX) {\r\n                        tmp = right.prevInSEL;\r\n                        for (;;) {\r\n                            this.addNewIntersectNode(tmp, right, topY);\r\n                            if (tmp === left)\r\n                                break;\r\n                            tmp = tmp.prevInSEL;\r\n                        }\r\n                        tmp = right;\r\n                        right = ClipperBase.extractFromSEL(tmp);\r\n                        lEnd = right;\r\n                        ClipperBase.insert1Before2InSEL(tmp, left);\r\n                        if (left === currBase) {\r\n                            currBase = tmp;\r\n                            currBase.jump = rEnd;\r\n                            if (prevBase === undefined)\r\n                                this._sel = currBase;\r\n                            else\r\n                                prevBase.jump = currBase;\r\n                        }\r\n                    }\r\n                    else {\r\n                        left = left.nextInSEL;\r\n                    }\r\n                }\r\n                prevBase = currBase;\r\n                left = rEnd;\r\n            }\r\n            left = this._sel;\r\n        }\r\n        return this._intersectList.length > 0;\r\n    }\r\n    processIntersectList() {\r\n        // We now have a list of intersections required so that edges will be\r\n        // correctly positioned at the top of the scanbeam. However, it's important\r\n        // that edge intersections are processed from the bottom up, but it's also\r\n        // crucial that intersections only occur between adjacent edges.\r\n        // First we do a quicksort so intersections proceed in a bottom up order ...\r\n        this._intersectList.sort((a, b) => {\r\n            if (a.pt.y === b.pt.y) {\r\n                if (a.pt.x === b.pt.x)\r\n                    return 0;\r\n                return (a.pt.x < b.pt.x) ? -1 : 1;\r\n            }\r\n            return (a.pt.y > b.pt.y) ? -1 : 1;\r\n        });\r\n        // Now as we process these intersections, we must sometimes adjust the order\r\n        // to ensure that intersecting edges are always adjacent ...\r\n        for (let i = 0; i < this._intersectList.length; ++i) {\r\n            if (!ClipperBase.edgesAdjacentInAEL(this._intersectList[i])) {\r\n                let j = i + 1;\r\n                while (!ClipperBase.edgesAdjacentInAEL(this._intersectList[j]))\r\n                    j++;\r\n                // swap\r\n                [this._intersectList[j], this._intersectList[i]] =\r\n                    [this._intersectList[i], this._intersectList[j]];\r\n            }\r\n            const node = this._intersectList[i];\r\n            this.intersectEdges(node.edge1, node.edge2, node.pt);\r\n            this.swapPositionsInAEL(node.edge1, node.edge2);\r\n            node.edge1.curX = node.pt.x;\r\n            node.edge2.curX = node.pt.x;\r\n            this.checkJoinLeft(node.edge2, node.pt, true);\r\n            this.checkJoinRight(node.edge1, node.pt, true);\r\n        }\r\n    }\r\n    swapPositionsInAEL(ae1, ae2) {\r\n        // preconditon: ae1 must be immediately to the left of ae2\r\n        const next = ae2.nextInAEL;\r\n        if (next)\r\n            next.prevInAEL = ae1;\r\n        const prev = ae1.prevInAEL;\r\n        if (prev)\r\n            prev.nextInAEL = ae2;\r\n        ae2.prevInAEL = prev;\r\n        ae2.nextInAEL = ae1;\r\n        ae1.prevInAEL = ae2;\r\n        ae1.nextInAEL = next;\r\n        if (!ae2.prevInAEL)\r\n            this._actives = ae2;\r\n    }\r\n    static resetHorzDirection(horz, vertexMax) {\r\n        let leftX, rightX;\r\n        if (horz.bot.x === horz.top.x) {\r\n            // the horizontal edge is going nowhere ...\r\n            leftX = horz.curX;\r\n            rightX = horz.curX;\r\n            let ae = horz.nextInAEL;\r\n            while (ae && ae.vertexTop !== vertexMax)\r\n                ae = ae.nextInAEL;\r\n            return { isLeftToRight: ae !== undefined, leftX, rightX };\r\n        }\r\n        if (horz.curX < horz.top.x) {\r\n            leftX = horz.curX;\r\n            rightX = horz.top.x;\r\n            return { isLeftToRight: true, leftX, rightX };\r\n        }\r\n        leftX = horz.top.x;\r\n        rightX = horz.curX;\r\n        return { isLeftToRight: false, leftX, rightX }; // right to left\r\n    }\r\n    static horzIsSpike(horz) {\r\n        const nextPt = ClipperBase.nextVertex(horz).pt;\r\n        return (horz.bot.x < horz.top.x) !== (horz.top.x < nextPt.x);\r\n    }\r\n    static trimHorz(horzEdge, preserveCollinear) {\r\n        let wasTrimmed = false;\r\n        let pt = ClipperBase.nextVertex(horzEdge).pt;\r\n        while (pt.y === horzEdge.top.y) {\r\n            // always trim 180 deg. spikes (in closed paths)\r\n            // but otherwise break if preserveCollinear = true\r\n            if (preserveCollinear &&\r\n                (pt.x < horzEdge.top.x) !== (horzEdge.bot.x < horzEdge.top.x)) {\r\n                break;\r\n            }\r\n            horzEdge.vertexTop = ClipperBase.nextVertex(horzEdge);\r\n            horzEdge.top = pt;\r\n            wasTrimmed = true;\r\n            if (ClipperBase.isMaximaActive(horzEdge))\r\n                break;\r\n            pt = ClipperBase.nextVertex(horzEdge).pt;\r\n        }\r\n        if (wasTrimmed)\r\n            ClipperBase.setDx(horzEdge); // +/-infinity\r\n    }\r\n    addToHorzSegList(op) {\r\n        if (op.outrec.isOpen)\r\n            return;\r\n        this._horzSegList.push(new HorzSegment(op));\r\n    }\r\n    getLastOp(hotEdge) {\r\n        const outrec = hotEdge.outrec;\r\n        return (hotEdge === outrec.frontEdge) ?\r\n            outrec.pts : outrec.pts.next;\r\n    }\r\n    /*******************************************************************************\r\n    * Notes: Horizontal edges (HEs) at scanline intersections (i.e. at the top or    *\r\n    * bottom of a scanbeam) are processed as if layered.The order in which HEs     *\r\n    * are processed doesn't matter. HEs intersect with the bottom vertices of      *\r\n    * other HEs[#] and with non-horizontal edges [*]. Once these intersections     *\r\n    * are completed, intermediate HEs are 'promoted' to the next edge in their     *\r\n    * bounds, and they in turn may be intersected[%] by other HEs.                 *\r\n    *                                                                              *\r\n    * eg: 3 horizontals at a scanline:    /   |                     /           /  *\r\n    *              |                     /    |     (HE3)o ========%========== o   *\r\n    *              o ======= o(HE2)     /     |         /         /                *\r\n    *          o ============#=========*======*========#=========o (HE1)           *\r\n    *         /              |        /       |       /                            *\r\n    *******************************************************************************/\r\n    doHorizontal(horz) {\r\n        let pt;\r\n        const horzIsOpen = ClipperBase.isOpen(horz);\r\n        const Y = horz.bot.y;\r\n        const vertex_max = horzIsOpen ?\r\n            ClipperBase.getCurrYMaximaVertex_Open(horz) :\r\n            ClipperBase.getCurrYMaximaVertex(horz);\r\n        // remove 180 deg.spikes and also simplify\r\n        // consecutive horizontals when PreserveCollinear = true\r\n        if (vertex_max && !horzIsOpen && vertex_max !== horz.vertexTop)\r\n            ClipperBase.trimHorz(horz, this.preserveCollinear);\r\n        let { isLeftToRight, leftX, rightX } = ClipperBase.resetHorzDirection(horz, vertex_max);\r\n        if (ClipperBase.isHotEdgeActive(horz)) {\r\n            const op = ClipperBase.addOutPt(horz, new Point64(horz.curX, Y));\r\n            this.addToHorzSegList(op);\r\n        }\r\n        for (;;) {\r\n            // loops through consec. horizontal edges (if open)\r\n            let ae = isLeftToRight ? horz.nextInAEL : horz.prevInAEL;\r\n            while (ae) {\r\n                if (ae.vertexTop === vertex_max) {\r\n                    // do this first!!\r\n                    if (ClipperBase.isHotEdgeActive(horz) && ClipperBase.isJoined(ae))\r\n                        this.split(ae, ae.top);\r\n                    if (ClipperBase.isHotEdgeActive(horz)) {\r\n                        while (horz.vertexTop !== vertex_max) {\r\n                            ClipperBase.addOutPt(horz, horz.top);\r\n                            this.updateEdgeIntoAEL(horz);\r\n                        }\r\n                        if (isLeftToRight)\r\n                            this.addLocalMaxPoly(horz, ae, horz.top);\r\n                        else\r\n                            this.addLocalMaxPoly(ae, horz, horz.top);\r\n                    }\r\n                    this.deleteFromAEL(ae);\r\n                    this.deleteFromAEL(horz);\r\n                    return;\r\n                }\r\n                // if horzEdge is a maxima, keep going until we reach\r\n                // its maxima pair, otherwise check for break conditions\r\n                if (vertex_max !== horz.vertexTop || ClipperBase.isOpenEndActive(horz)) {\r\n                    // otherwise stop when 'ae' is beyond the end of the horizontal line\r\n                    if ((isLeftToRight && ae.curX > rightX) || (!isLeftToRight && ae.curX < leftX))\r\n                        break;\r\n                    if (ae.curX === horz.top.x && !ClipperBase.isHorizontal(ae)) {\r\n                        pt = ClipperBase.nextVertex(horz).pt;\r\n                        // to maximize the possibility of putting open edges into\r\n                        // solutions, we'll only break if it's past HorzEdge's end\r\n                        if (ClipperBase.isOpen(ae) && !ClipperBase.isSamePolyType(ae, horz) && !ClipperBase.isHotEdgeActive(ae)) {\r\n                            if ((isLeftToRight && (ClipperBase.topX(ae, pt.y) > pt.x)) || (!isLeftToRight && (ClipperBase.topX(ae, pt.y) < pt.x)))\r\n                                break;\r\n                        }\r\n                        // otherwise for edges at horzEdge's end, only stop when horzEdge's\r\n                        // outslope is greater than e's slope when heading right or when\r\n                        // horzEdge's outslope is less than e's slope when heading left.\r\n                        else if ((isLeftToRight && (ClipperBase.topX(ae, pt.y) >= pt.x)) || (!isLeftToRight && (ClipperBase.topX(ae, pt.y) <= pt.x)))\r\n                            break;\r\n                    }\r\n                }\r\n                pt = new Point64(ae.curX, Y);\r\n                if (isLeftToRight) {\r\n                    this.intersectEdges(horz, ae, pt);\r\n                    this.swapPositionsInAEL(horz, ae);\r\n                    horz.curX = ae.curX;\r\n                    ae = horz.nextInAEL;\r\n                }\r\n                else {\r\n                    this.intersectEdges(ae, horz, pt);\r\n                    this.swapPositionsInAEL(ae, horz);\r\n                    horz.curX = ae.curX;\r\n                    ae = horz.prevInAEL;\r\n                }\r\n                if (ClipperBase.isHotEdgeActive(horz))\r\n                    this.addToHorzSegList(this.getLastOp(horz));\r\n            } // we've reached the end of this horizontal\r\n            // check if we've finished looping\r\n            // through consecutive horizontals\r\n            if (horzIsOpen && ClipperBase.isOpenEndActive(horz)) { // ie open at top\r\n                if (ClipperBase.isHotEdgeActive(horz)) {\r\n                    ClipperBase.addOutPt(horz, horz.top);\r\n                    if (ClipperBase.isFront(horz))\r\n                        horz.outrec.frontEdge = undefined;\r\n                    else\r\n                        horz.outrec.backEdge = undefined;\r\n                    horz.outrec = undefined;\r\n                }\r\n                this.deleteFromAEL(horz);\r\n                return;\r\n            }\r\n            else if (ClipperBase.nextVertex(horz).pt.y !== horz.top.y)\r\n                break;\r\n            // still more horizontals in bound to process ...\r\n            if (ClipperBase.isHotEdgeActive(horz)) {\r\n                ClipperBase.addOutPt(horz, horz.top);\r\n            }\r\n            this.updateEdgeIntoAEL(horz);\r\n            if (this.preserveCollinear && !horzIsOpen && ClipperBase.horzIsSpike(horz)) {\r\n                ClipperBase.trimHorz(horz, true);\r\n            }\r\n            const result = ClipperBase.resetHorzDirection(horz, vertex_max);\r\n            isLeftToRight = result.isLeftToRight;\r\n            leftX = result.leftX;\r\n            rightX = result.rightX;\r\n        }\r\n        if (ClipperBase.isHotEdgeActive(horz)) {\r\n            const op = ClipperBase.addOutPt(horz, horz.top);\r\n            this.addToHorzSegList(op);\r\n        }\r\n        this.updateEdgeIntoAEL(horz);\r\n    }\r\n    doTopOfScanbeam(y) {\r\n        this._sel = undefined; // _sel is reused to flag horizontals (see pushHorz below)\r\n        let ae = this._actives;\r\n        while (ae) {\r\n            // NB 'ae' will never be horizontal here\r\n            if (ae.top.y === y) {\r\n                ae.curX = ae.top.x;\r\n                if (ClipperBase.isMaximaActive(ae)) {\r\n                    ae = this.doMaxima(ae); // TOP OF BOUND (MAXIMA)\r\n                    continue;\r\n                }\r\n                // INTERMEDIATE VERTEX ...\r\n                if (ClipperBase.isHotEdgeActive(ae))\r\n                    ClipperBase.addOutPt(ae, ae.top);\r\n                this.updateEdgeIntoAEL(ae);\r\n                if (ClipperBase.isHorizontal(ae))\r\n                    this.pushHorz(ae); // horizontals are processed later\r\n            }\r\n            else { // i.e. not the top of the edge\r\n                ae.curX = ClipperBase.topX(ae, y);\r\n            }\r\n            ae = ae.nextInAEL;\r\n        }\r\n    }\r\n    doMaxima(ae) {\r\n        const prevE = ae.prevInAEL;\r\n        let nextE = ae.nextInAEL;\r\n        if (ClipperBase.isOpenEndActive(ae)) {\r\n            if (ClipperBase.isHotEdgeActive(ae))\r\n                ClipperBase.addOutPt(ae, ae.top);\r\n            if (!ClipperBase.isHorizontal(ae)) {\r\n                if (ClipperBase.isHotEdgeActive(ae)) {\r\n                    if (ClipperBase.isFront(ae))\r\n                        ae.outrec.frontEdge = undefined;\r\n                    else\r\n                        ae.outrec.backEdge = undefined;\r\n                    ae.outrec = undefined;\r\n                }\r\n                this.deleteFromAEL(ae);\r\n            }\r\n            return nextE;\r\n        }\r\n        const maxPair = ClipperBase.getMaximaPair(ae);\r\n        if (!maxPair)\r\n            return nextE; // eMaxPair is horizontal\r\n        if (ClipperBase.isJoined(ae))\r\n            this.split(ae, ae.top);\r\n        if (ClipperBase.isJoined(maxPair))\r\n            this.split(maxPair, maxPair.top);\r\n        // only non-horizontal maxima here.\r\n        // process any edges between maxima pair ...\r\n        while (nextE !== maxPair) {\r\n            this.intersectEdges(ae, nextE, ae.top);\r\n            this.swapPositionsInAEL(ae, nextE);\r\n            nextE = ae.nextInAEL;\r\n        }\r\n        if (ClipperBase.isOpen(ae)) {\r\n            if (ClipperBase.isHotEdgeActive(ae))\r\n                this.addLocalMaxPoly(ae, maxPair, ae.top);\r\n            this.deleteFromAEL(maxPair);\r\n            this.deleteFromAEL(ae);\r\n            return (prevE ? prevE.nextInAEL : this._actives);\r\n        }\r\n        // here ae.nextInAel == ENext == EMaxPair ...\r\n        if (ClipperBase.isHotEdgeActive(ae))\r\n            this.addLocalMaxPoly(ae, maxPair, ae.top);\r\n        this.deleteFromAEL(ae);\r\n        this.deleteFromAEL(maxPair);\r\n        return (prevE ? prevE.nextInAEL : this._actives);\r\n    }\r\n    static isJoined(e) {\r\n        return e.joinWith !== JoinWith.None;\r\n    }\r\n    split(e, currPt) {\r\n        if (e.joinWith === JoinWith.Right) {\r\n            e.joinWith = JoinWith.None;\r\n            e.nextInAEL.joinWith = JoinWith.None;\r\n            this.addLocalMinPoly(e, e.nextInAEL, currPt, true);\r\n        }\r\n        else {\r\n            e.joinWith = JoinWith.None;\r\n            e.prevInAEL.joinWith = JoinWith.None;\r\n            this.addLocalMinPoly(e.prevInAEL, e, currPt, true);\r\n        }\r\n    }\r\n    checkJoinLeft(e, pt, checkCurrX = false) {\r\n        const prev = e.prevInAEL;\r\n        if (!prev || ClipperBase.isOpen(e) || ClipperBase.isOpen(prev) ||\r\n            !ClipperBase.isHotEdgeActive(e) || !ClipperBase.isHotEdgeActive(prev))\r\n            return;\r\n        if ((pt.y < e.top.y + 2 || pt.y < prev.top.y + 2) && // avoid trivial joins\r\n            ((e.bot.y > pt.y) || (prev.bot.y > pt.y)))\r\n            return; // (#490)\r\n        if (checkCurrX) {\r\n            if (Clipper.perpendicDistFromLineSqrd(pt, prev.bot, prev.top) > 0.25)\r\n                return;\r\n        }\r\n        else if (e.curX !== prev.curX)\r\n            return;\r\n        if (InternalClipper.crossProduct(e.top, pt, prev.top) !== 0)\r\n            return;\r\n        if (e.outrec.idx === prev.outrec.idx)\r\n            this.addLocalMaxPoly(prev, e, pt);\r\n        else if (e.outrec.idx < prev.outrec.idx)\r\n            ClipperBase.joinOutrecPaths(e, prev);\r\n        else\r\n            ClipperBase.joinOutrecPaths(prev, e);\r\n        prev.joinWith = JoinWith.Right;\r\n        e.joinWith = JoinWith.Left;\r\n    }\r\n    checkJoinRight(e, pt, checkCurrX = false) {\r\n        const next = e.nextInAEL;\r\n        if (ClipperBase.isOpen(e) || !ClipperBase.isHotEdgeActive(e) || ClipperBase.isJoined(e) ||\r\n            !next || ClipperBase.isOpen(next) || !ClipperBase.isHotEdgeActive(next))\r\n            return;\r\n        if ((pt.y < e.top.y + 2 || pt.y < next.top.y + 2) && // avoid trivial joins\r\n            ((e.bot.y > pt.y) || (next.bot.y > pt.y)))\r\n            return; // (#490)\r\n        if (checkCurrX) {\r\n            if (Clipper.perpendicDistFromLineSqrd(pt, next.bot, next.top) > 0.25)\r\n                return;\r\n        }\r\n        else if (e.curX !== next.curX)\r\n            return;\r\n        if (InternalClipper.crossProduct(e.top, pt, next.top) !== 0)\r\n            return;\r\n        if (e.outrec.idx === next.outrec.idx)\r\n            this.addLocalMaxPoly(e, next, pt);\r\n        else if (e.outrec.idx < next.outrec.idx)\r\n            ClipperBase.joinOutrecPaths(e, next);\r\n        else\r\n            ClipperBase.joinOutrecPaths(next, e);\r\n        e.joinWith = JoinWith.Right;\r\n        next.joinWith = JoinWith.Left;\r\n    }\r\n    static fixOutRecPts(outrec) {\r\n        let op = outrec.pts;\r\n        do {\r\n            op.outrec = outrec;\r\n            op = op.next;\r\n        } while (op !== outrec.pts);\r\n    }\r\n    static setHorzSegHeadingForward(hs, opP, opN) {\r\n        if (opP.pt.x === opN.pt.x)\r\n            return false;\r\n        if (opP.pt.x < opN.pt.x) {\r\n            hs.leftOp = opP;\r\n            hs.rightOp = opN;\r\n            hs.leftToRight = true;\r\n        }\r\n        else {\r\n            hs.leftOp = opN;\r\n            hs.rightOp = opP;\r\n            hs.leftToRight = false;\r\n        }\r\n        return true;\r\n    }\r\n    static updateHorzSegment(hs) {\r\n        const op = hs.leftOp;\r\n        const outrec = this.getRealOutRec(op.outrec);\r\n        const outrecHasEdges = outrec.frontEdge !== undefined;\r\n        const curr_y = op.pt.y;\r\n        let opP = op, opN = op;\r\n        if (outrecHasEdges) {\r\n            const opA = outrec.pts, opZ = opA.next;\r\n            while (opP !== opZ && opP.prev.pt.y === curr_y)\r\n                opP = opP.prev;\r\n            while (opN !== opA && opN.next.pt.y === curr_y)\r\n                opN = opN.next;\r\n        }\r\n        else {\r\n            while (opP.prev !== opN && opP.prev.pt.y === curr_y)\r\n                opP = opP.prev;\r\n            while (opN.next !== opP && opN.next.pt.y === curr_y)\r\n                opN = opN.next;\r\n        }\r\n        const result = this.setHorzSegHeadingForward(hs, opP, opN) && hs.leftOp.horz === undefined;\r\n        if (result)\r\n            hs.leftOp.horz = hs;\r\n        else\r\n            hs.rightOp = undefined; // (for sorting)\r\n        return result;\r\n    }\r\n    static duplicateOp(op, insert_after) {\r\n        const result = new OutPt(op.pt, op.outrec);\r\n        if (insert_after) {\r\n            result.next = op.next;\r\n            result.next.prev = result;\r\n            result.prev = op;\r\n            op.next = result;\r\n        }\r\n        else {\r\n            result.prev = op.prev;\r\n            result.prev.next = result;\r\n            result.next = op;\r\n            op.prev = result;\r\n        }\r\n        return result;\r\n    }\r\n    convertHorzSegsToJoins() {\r\n        let k = 0;\r\n        for (const hs of this._horzSegList) {\r\n            if (ClipperBase.updateHorzSegment(hs))\r\n                k++;\r\n        }\r\n        if (k < 2)\r\n            return;\r\n        this._horzSegList.sort((hs1, hs2) => {\r\n            if (!hs1 || !hs2)\r\n                return 0;\r\n            if (!hs1.rightOp) {\r\n                return !hs2.rightOp ? 0 : 1;\r\n            }\r\n            else if (!hs2.rightOp)\r\n                return -1;\r\n            else\r\n                return hs1.leftOp.pt.x - hs2.leftOp.pt.x;\r\n        });\r\n        for (let i = 0; i < k - 1; i++) {\r\n            const hs1 = this._horzSegList[i];\r\n            // for each HorzSegment, find others that overlap\r\n            for (let j = i + 1; j < k; j++) {\r\n                const hs2 = this._horzSegList[j];\r\n                if (hs2.leftOp.pt.x >= hs1.rightOp.pt.x ||\r\n                    hs2.leftToRight === hs1.leftToRight ||\r\n                    hs2.rightOp.pt.x <= hs1.leftOp.pt.x)\r\n                    continue;\r\n                const curr_y = hs1.leftOp.pt.y;\r\n                if (hs1.leftToRight) {\r\n                    while (hs1.leftOp.next.pt.y === curr_y &&\r\n                        hs1.leftOp.next.pt.x <= hs2.leftOp.pt.x) {\r\n                        hs1.leftOp = hs1.leftOp.next;\r\n                    }\r\n                    while (hs2.leftOp.prev.pt.y === curr_y &&\r\n                        hs2.leftOp.prev.pt.x <= hs1.leftOp.pt.x) {\r\n                        hs2.leftOp = hs2.leftOp.prev;\r\n                    }\r\n                    const join = new HorzJoin(ClipperBase.duplicateOp(hs1.leftOp, true), ClipperBase.duplicateOp(hs2.leftOp, false));\r\n                    this._horzJoinList.push(join);\r\n                }\r\n                else {\r\n                    while (hs1.leftOp.prev.pt.y === curr_y &&\r\n                        hs1.leftOp.prev.pt.x <= hs2.leftOp.pt.x) {\r\n                        hs1.leftOp = hs1.leftOp.prev;\r\n                    }\r\n                    while (hs2.leftOp.next.pt.y === curr_y &&\r\n                        hs2.leftOp.next.pt.x <= hs1.leftOp.pt.x) {\r\n                        hs2.leftOp = hs2.leftOp.next;\r\n                    }\r\n                    const join = new HorzJoin(ClipperBase.duplicateOp(hs2.leftOp, true), ClipperBase.duplicateOp(hs1.leftOp, false));\r\n                    this._horzJoinList.push(join);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static getCleanPath(op) {\r\n        const result = new Path64();\r\n        let op2 = op;\r\n        while (op2.next !== op &&\r\n            ((op2.pt.x === op2.next.pt.x && op2.pt.x === op2.prev.pt.x) ||\r\n                (op2.pt.y === op2.next.pt.y && op2.pt.y === op2.prev.pt.y))) {\r\n            op2 = op2.next;\r\n        }\r\n        result.push(op2.pt);\r\n        let prevOp = op2;\r\n        op2 = op2.next;\r\n        while (op2 !== op) {\r\n            if ((op2.pt.x !== op2.next.pt.x || op2.pt.x !== prevOp.pt.x) &&\r\n                (op2.pt.y !== op2.next.pt.y || op2.pt.y !== prevOp.pt.y)) {\r\n                result.push(op2.pt);\r\n                prevOp = op2;\r\n            }\r\n            op2 = op2.next;\r\n        }\r\n        return result;\r\n    }\r\n    static pointInOpPolygon(pt, op) {\r\n        if (op === op.next || op.prev === op.next)\r\n            return PointInPolygonResult.IsOutside;\r\n        let op2 = op;\r\n        do {\r\n            if (op.pt.y !== pt.y)\r\n                break;\r\n            op = op.next;\r\n        } while (op !== op2);\r\n        if (op.pt.y === pt.y) // not a proper polygon\r\n            return PointInPolygonResult.IsOutside;\r\n        let isAbove = op.pt.y < pt.y;\r\n        const startingAbove = isAbove;\r\n        let val = 0;\r\n        op2 = op.next;\r\n        while (op2 !== op) {\r\n            if (isAbove)\r\n                while (op2 !== op && op2.pt.y < pt.y)\r\n                    op2 = op2.next;\r\n            else\r\n                while (op2 !== op && op2.pt.y > pt.y)\r\n                    op2 = op2.next;\r\n            if (op2 === op)\r\n                break;\r\n            if (op2.pt.y === pt.y) {\r\n                if (op2.pt.x === pt.x || (op2.pt.y === op2.prev.pt.y &&\r\n                    (pt.x < op2.prev.pt.x) !== (pt.x < op2.pt.x)))\r\n                    return PointInPolygonResult.IsOn;\r\n                op2 = op2.next;\r\n                if (op2 === op)\r\n                    break;\r\n                continue;\r\n            }\r\n            if (op2.pt.x <= pt.x || op2.prev.pt.x <= pt.x) {\r\n                if (op2.prev.pt.x < pt.x && op2.pt.x < pt.x)\r\n                    val = 1 - val;\r\n                else {\r\n                    const d = InternalClipper.crossProduct(op2.prev.pt, op2.pt, pt);\r\n                    if (d === 0)\r\n                        return PointInPolygonResult.IsOn;\r\n                    if ((d < 0) === isAbove)\r\n                        val = 1 - val;\r\n                }\r\n            }\r\n            isAbove = !isAbove;\r\n            op2 = op2.next;\r\n        }\r\n        if (isAbove !== startingAbove) {\r\n            const d = InternalClipper.crossProduct(op2.prev.pt, op2.pt, pt);\r\n            if (d === 0)\r\n                return PointInPolygonResult.IsOn;\r\n            if ((d < 0) === isAbove)\r\n                val = 1 - val;\r\n        }\r\n        if (val === 0)\r\n            return PointInPolygonResult.IsOutside;\r\n        else\r\n            return PointInPolygonResult.IsInside;\r\n    }\r\n    static path1InsidePath2(op1, op2) {\r\n        let result;\r\n        let outside_cnt = 0;\r\n        let op = op1;\r\n        do {\r\n            result = this.pointInOpPolygon(op.pt, op2);\r\n            if (result === PointInPolygonResult.IsOutside)\r\n                ++outside_cnt;\r\n            else if (result === PointInPolygonResult.IsInside)\r\n                --outside_cnt;\r\n            op = op.next;\r\n        } while (op !== op1 && Math.abs(outside_cnt) < 2);\r\n        if (Math.abs(outside_cnt) > 1)\r\n            return (outside_cnt < 0);\r\n        const mp = ClipperBase.getBoundsPath(this.getCleanPath(op1)).midPoint();\r\n        const path2 = this.getCleanPath(op2);\r\n        return InternalClipper.pointInPolygon(mp, path2) !== PointInPolygonResult.IsOutside;\r\n    }\r\n    moveSplits(fromOr, toOr) {\r\n        if (!fromOr.splits)\r\n            return;\r\n        toOr.splits = toOr.splits || [];\r\n        for (const i of fromOr.splits) {\r\n            toOr.splits.push(i);\r\n        }\r\n        fromOr.splits = undefined;\r\n    }\r\n    processHorzJoins() {\r\n        for (const j of this._horzJoinList) {\r\n            const or1 = ClipperBase.getRealOutRec(j.op1.outrec);\r\n            let or2 = ClipperBase.getRealOutRec(j.op2.outrec);\r\n            const op1b = j.op1.next;\r\n            const op2b = j.op2.prev;\r\n            j.op1.next = j.op2;\r\n            j.op2.prev = j.op1;\r\n            op1b.prev = op2b;\r\n            op2b.next = op1b;\r\n            if (or1 === or2) {\r\n                or2 = this.newOutRec();\r\n                or2.pts = op1b;\r\n                ClipperBase.fixOutRecPts(or2);\r\n                if (or1.pts.outrec === or2) {\r\n                    or1.pts = j.op1;\r\n                    or1.pts.outrec = or1;\r\n                }\r\n                if (this._using_polytree) {\r\n                    if (ClipperBase.path1InsidePath2(or1.pts, or2.pts)) {\r\n                        const tmp = or1.pts;\r\n                        or1.pts = or2.pts;\r\n                        or2.pts = tmp;\r\n                        ClipperBase.fixOutRecPts(or1);\r\n                        ClipperBase.fixOutRecPts(or2);\r\n                        or2.owner = or1.owner;\r\n                    }\r\n                    else if (ClipperBase.path1InsidePath2(or2.pts, or1.pts)) {\r\n                        or2.owner = or1;\r\n                    }\r\n                    else {\r\n                        or2.owner = or1.owner;\r\n                    }\r\n                    or1.splits = or1.splits || [];\r\n                    or1.splits.push(or2.idx);\r\n                }\r\n                else {\r\n                    or2.owner = or1;\r\n                }\r\n            }\r\n            else {\r\n                or2.pts = undefined;\r\n                if (this._using_polytree) {\r\n                    ClipperBase.setOwner(or2, or1);\r\n                    this.moveSplits(or2, or1);\r\n                }\r\n                else {\r\n                    or2.owner = or1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static ptsReallyClose(pt1, pt2) {\r\n        return (Math.abs(pt1.x - pt2.x) < 2) && (Math.abs(pt1.y - pt2.y) < 2);\r\n    }\r\n    static isVerySmallTriangle(op) {\r\n        return op.next.next === op.prev &&\r\n            (this.ptsReallyClose(op.prev.pt, op.next.pt) ||\r\n                this.ptsReallyClose(op.pt, op.next.pt) ||\r\n                this.ptsReallyClose(op.pt, op.prev.pt));\r\n    }\r\n    static isValidClosedPath(op) {\r\n        return op !== undefined && op.next !== op &&\r\n            (op.next !== op.prev || !this.isVerySmallTriangle(op));\r\n    }\r\n    static disposeOutPt(op) {\r\n        const result = op.next === op ? undefined : op.next;\r\n        op.prev.next = op.next;\r\n        op.next.prev = op.prev;\r\n        return result;\r\n    }\r\n    cleanCollinear(outrec) {\r\n        outrec = ClipperBase.getRealOutRec(outrec);\r\n        if (outrec === undefined || outrec.isOpen)\r\n            return;\r\n        if (!ClipperBase.isValidClosedPath(outrec.pts)) {\r\n            outrec.pts = undefined;\r\n            return;\r\n        }\r\n        let startOp = outrec.pts;\r\n        let op2 = startOp;\r\n        for (;;) {\r\n            // NB if preserveCollinear == true, then only remove 180 deg. spikes\r\n            if (InternalClipper.crossProduct(op2.prev.pt, op2.pt, op2.next.pt) === 0 &&\r\n                (op2.pt === op2.prev.pt || op2.pt === op2.next.pt || !this.preserveCollinear ||\r\n                    InternalClipper.dotProduct(op2.prev.pt, op2.pt, op2.next.pt) < 0)) {\r\n                if (op2 === outrec.pts) {\r\n                    outrec.pts = op2.prev;\r\n                }\r\n                op2 = ClipperBase.disposeOutPt(op2);\r\n                if (!ClipperBase.isValidClosedPath(op2)) {\r\n                    outrec.pts = undefined;\r\n                    return;\r\n                }\r\n                startOp = op2;\r\n                continue;\r\n            }\r\n            op2 = op2.next;\r\n            if (op2 === startOp)\r\n                break;\r\n        }\r\n        this.fixSelfIntersects(outrec);\r\n    }\r\n    doSplitOp(outrec, splitOp) {\r\n        // splitOp.prev <=> splitOp &&\r\n        // splitOp.next <=> splitOp.next.next are intersecting\r\n        const prevOp = splitOp.prev;\r\n        const nextNextOp = splitOp.next.next;\r\n        outrec.pts = prevOp;\r\n        const ip = InternalClipper.getIntersectPoint(prevOp.pt, splitOp.pt, splitOp.next.pt, nextNextOp.pt).ip;\r\n        const area1 = ClipperBase.area(prevOp);\r\n        const absArea1 = Math.abs(area1);\r\n        if (absArea1 < 2) {\r\n            outrec.pts = undefined;\r\n            return;\r\n        }\r\n        const area2 = ClipperBase.areaTriangle(ip, splitOp.pt, splitOp.next.pt);\r\n        const absArea2 = Math.abs(area2);\r\n        // de-link splitOp and splitOp.next from the path\r\n        // while inserting the intersection point\r\n        if (ip === prevOp.pt || ip === nextNextOp.pt) {\r\n            nextNextOp.prev = prevOp;\r\n            prevOp.next = nextNextOp;\r\n        }\r\n        else {\r\n            const newOp2 = new OutPt(ip, outrec);\r\n            newOp2.prev = prevOp;\r\n            newOp2.next = nextNextOp;\r\n            nextNextOp.prev = newOp2;\r\n            prevOp.next = newOp2;\r\n        }\r\n        // nb: area1 is the path's area *before* splitting, whereas area2 is\r\n        // the area of the triangle containing splitOp & splitOp.next.\r\n        // So the only way for these areas to have the same sign is if\r\n        // the split triangle is larger than the path containing prevOp or\r\n        // if there's more than one self=intersection.\r\n        if (absArea2 > 1 &&\r\n            (absArea2 > absArea1 || (area2 > 0) === (area1 > 0))) {\r\n            const newOutRec = this.newOutRec();\r\n            newOutRec.owner = outrec.owner;\r\n            splitOp.outrec = newOutRec;\r\n            splitOp.next.outrec = newOutRec;\r\n            const newOp = new OutPt(ip, newOutRec);\r\n            newOp.prev = splitOp.next;\r\n            newOp.next = splitOp;\r\n            newOutRec.pts = newOp;\r\n            splitOp.prev = newOp;\r\n            splitOp.next.next = newOp;\r\n            if (this._using_polytree) {\r\n                if (ClipperBase.path1InsidePath2(prevOp, newOp)) {\r\n                    newOutRec.splits = newOutRec.splits || [];\r\n                    newOutRec.splits.push(outrec.idx);\r\n                }\r\n                else {\r\n                    outrec.splits = outrec.splits || [];\r\n                    outrec.splits.push(newOutRec.idx);\r\n                }\r\n            }\r\n        }\r\n        // else { splitOp = undefined; splitOp.next = undefined; }\r\n    }\r\n    fixSelfIntersects(outrec) {\r\n        let op2 = outrec.pts;\r\n        for (;;) {\r\n            if (op2.prev === op2.next.next)\r\n                break;\r\n            if (InternalClipper.segsIntersect(op2.prev.pt, op2.pt, op2.next.pt, op2.next.next.pt)) {\r\n                this.doSplitOp(outrec, op2);\r\n                if (!outrec.pts)\r\n                    return;\r\n                op2 = outrec.pts;\r\n                continue;\r\n            }\r\n            else {\r\n                op2 = op2.next;\r\n            }\r\n            if (op2 === outrec.pts)\r\n                break;\r\n        }\r\n    }\r\n    static buildPath(op, reverse, isOpen, path) {\r\n        if (op === undefined || op.next === op || (!isOpen && op.next === op.prev))\r\n            return false;\r\n        path.length = 0;\r\n        let lastPt;\r\n        let op2;\r\n        if (reverse) {\r\n            lastPt = op.pt;\r\n            op2 = op.prev;\r\n        }\r\n        else {\r\n            op = op.next;\r\n            lastPt = op.pt;\r\n            op2 = op.next;\r\n        }\r\n        path.push(lastPt);\r\n        while (op2 !== op) {\r\n            if (op2.pt !== lastPt) {\r\n                lastPt = op2.pt;\r\n                path.push(lastPt);\r\n            }\r\n            if (reverse) {\r\n                op2 = op2.prev;\r\n            }\r\n            else {\r\n                op2 = op2.next;\r\n            }\r\n        }\r\n        if (path.length === 3 && this.isVerySmallTriangle(op2))\r\n            return false;\r\n        else\r\n            return true;\r\n    }\r\n    buildPaths(solutionClosed, solutionOpen) {\r\n        solutionClosed.length = 0;\r\n        solutionOpen.length = 0;\r\n        let i = 0;\r\n        while (i < this._outrecList.length) {\r\n            const outrec = this._outrecList[i++];\r\n            if (!outrec.pts)\r\n                continue;\r\n            const path = new Path64();\r\n            if (outrec.isOpen) {\r\n                if (ClipperBase.buildPath(outrec.pts, this.reverseSolution, true, path)) {\r\n                    solutionOpen.push(path);\r\n                }\r\n            }\r\n            else {\r\n                this.cleanCollinear(outrec);\r\n                // closed paths should always return a Positive orientation\r\n                // except when reverseSolution == true\r\n                if (ClipperBase.buildPath(outrec.pts, this.reverseSolution, false, path)) {\r\n                    solutionClosed.push(path);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static getBoundsPath(path) {\r\n        if (path.length === 0)\r\n            return new Rect64();\r\n        const result = Clipper.InvalidRect64;\r\n        for (const pt of path) {\r\n            if (pt.x < result.left)\r\n                result.left = pt.x;\r\n            if (pt.x > result.right)\r\n                result.right = pt.x;\r\n            if (pt.y < result.top)\r\n                result.top = pt.y;\r\n            if (pt.y > result.bottom)\r\n                result.bottom = pt.y;\r\n        }\r\n        return result;\r\n    }\r\n    checkBounds(outrec) {\r\n        if (outrec.pts === undefined)\r\n            return false;\r\n        if (!outrec.bounds.isEmpty())\r\n            return true;\r\n        this.cleanCollinear(outrec);\r\n        if (outrec.pts === undefined || !ClipperBase.buildPath(outrec.pts, this.reverseSolution, false, outrec.path))\r\n            return false;\r\n        outrec.bounds = ClipperBase.getBoundsPath(outrec.path);\r\n        return true;\r\n    }\r\n    checkSplitOwner(outrec, splits) {\r\n        for (const i of splits) {\r\n            const split = ClipperBase.getRealOutRec(this._outrecList[i]);\r\n            if (split === undefined || split === outrec || split.recursiveSplit === outrec)\r\n                continue;\r\n            split.recursiveSplit = outrec; //#599\r\n            if (split.splits !== undefined && this.checkSplitOwner(outrec, split.splits))\r\n                return true;\r\n            if (ClipperBase.isValidOwner(outrec, split) &&\r\n                this.checkBounds(split) &&\r\n                split.bounds.containsRect(outrec.bounds) &&\r\n                ClipperBase.path1InsidePath2(outrec.pts, split.pts)) {\r\n                outrec.owner = split; //found in split\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    recursiveCheckOwners(outrec, polypath) {\r\n        // pre-condition: outrec will have valid bounds\r\n        // post-condition: if a valid path, outrec will have a polypath\r\n        if (outrec.polypath !== undefined || outrec.bounds.isEmpty())\r\n            return;\r\n        while (outrec.owner !== undefined) {\r\n            if (outrec.owner.splits !== undefined &&\r\n                this.checkSplitOwner(outrec, outrec.owner.splits))\r\n                break;\r\n            else if (outrec.owner.pts !== undefined && this.checkBounds(outrec.owner) &&\r\n                ClipperBase.path1InsidePath2(outrec.pts, outrec.owner.pts))\r\n                break;\r\n            outrec.owner = outrec.owner.owner;\r\n        }\r\n        if (outrec.owner !== undefined) {\r\n            if (outrec.owner.polypath === undefined)\r\n                this.recursiveCheckOwners(outrec.owner, polypath);\r\n            outrec.polypath = outrec.owner.polypath.addChild(outrec.path);\r\n        }\r\n        else {\r\n            outrec.polypath = polypath.addChild(outrec.path);\r\n        }\r\n    }\r\n    buildTree(polytree, solutionOpen) {\r\n        polytree.clear();\r\n        solutionOpen.length = 0;\r\n        let i = 0;\r\n        while (i < this._outrecList.length) {\r\n            const outrec = this._outrecList[i++];\r\n            if (outrec.pts === undefined)\r\n                continue;\r\n            if (outrec.isOpen) {\r\n                const open_path = new Path64();\r\n                if (ClipperBase.buildPath(outrec.pts, this.reverseSolution, true, open_path))\r\n                    solutionOpen.push(open_path);\r\n                continue;\r\n            }\r\n            if (this.checkBounds(outrec))\r\n                this.recursiveCheckOwners(outrec, polytree);\r\n        }\r\n    }\r\n    getBounds() {\r\n        const bounds = Clipper.InvalidRect64;\r\n        for (const t of this._vertexList) {\r\n            let v = t;\r\n            do {\r\n                if (v.pt.x < bounds.left)\r\n                    bounds.left = v.pt.x;\r\n                if (v.pt.x > bounds.right)\r\n                    bounds.right = v.pt.x;\r\n                if (v.pt.y < bounds.top)\r\n                    bounds.top = v.pt.y;\r\n                if (v.pt.y > bounds.bottom)\r\n                    bounds.bottom = v.pt.y;\r\n                v = v.next;\r\n            } while (v !== t);\r\n        }\r\n        return bounds.isEmpty() ? new Rect64(0, 0, 0, 0) : bounds;\r\n    }\r\n}\r\nclass Clipper64 extends ClipperBase {\r\n    addPath(path, polytype, isOpen = false) {\r\n        super.addPath(path, polytype, isOpen);\r\n    }\r\n    addReusableData(reusableData) {\r\n        super.addReuseableData(reusableData);\r\n    }\r\n    addPaths(paths, polytype, isOpen = false) {\r\n        super.addPaths(paths, polytype, isOpen);\r\n    }\r\n    addSubjectPaths(paths) {\r\n        this.addPaths(paths, PathType.Subject);\r\n    }\r\n    addOpenSubjectPaths(paths) {\r\n        this.addPaths(paths, PathType.Subject, true);\r\n    }\r\n    addClipPaths(paths) {\r\n        this.addPaths(paths, PathType.Clip);\r\n    }\r\n    execute(clipType, fillRule, solutionClosed, solutionOpen = new Paths64()) {\r\n        solutionClosed.length = 0;\r\n        solutionOpen.length = 0;\r\n        try {\r\n            this.executeInternal(clipType, fillRule);\r\n            this.buildPaths(solutionClosed, solutionOpen);\r\n        }\r\n        catch (error) {\r\n            this._succeeded = false;\r\n        }\r\n        this.clearSolutionOnly();\r\n        return this._succeeded;\r\n    }\r\n    executePolyTree(clipType, fillRule, polytree, openPaths = new Paths64()) {\r\n        polytree.clear();\r\n        openPaths.length = 0;\r\n        this._using_polytree = true;\r\n        try {\r\n            this.executeInternal(clipType, fillRule);\r\n            this.buildTree(polytree, openPaths);\r\n        }\r\n        catch (error) {\r\n            this._succeeded = false;\r\n        }\r\n        this.clearSolutionOnly();\r\n        return this._succeeded;\r\n    }\r\n}\r\nclass PolyPathBase {\r\n    get isHole() {\r\n        return this.getIsHole();\r\n    }\r\n    constructor(parent) {\r\n        this.children = [];\r\n        this.forEach = this.children.forEach;\r\n        this._parent = parent;\r\n    }\r\n    getLevel() {\r\n        let result = 0;\r\n        let pp = this._parent;\r\n        while (pp !== undefined) {\r\n            ++result;\r\n            pp = pp._parent;\r\n        }\r\n        return result;\r\n    }\r\n    get level() {\r\n        return this.getLevel();\r\n    }\r\n    getIsHole() {\r\n        const lvl = this.getLevel();\r\n        return lvl !== 0 && (lvl & 1) === 0;\r\n    }\r\n    get count() {\r\n        return this.children.length;\r\n    }\r\n    clear() {\r\n        this.children.length = 0;\r\n    }\r\n} // end of PolyPathBase class\r\nclass PolyPath64 extends PolyPathBase {\r\n    constructor(parent) {\r\n        super(parent);\r\n    }\r\n    addChild(p) {\r\n        const newChild = new PolyPath64(this);\r\n        newChild.polygon = p;\r\n        this.children.push(newChild);\r\n        return newChild;\r\n    }\r\n    get(index) {\r\n        if (index < 0 || index >= this.children.length) {\r\n            throw new Error(\"InvalidOperationException\");\r\n        }\r\n        return this.children[index];\r\n    }\r\n    child(index) {\r\n        if (index < 0 || index >= this.children.length) {\r\n            throw new Error(\"InvalidOperationException\");\r\n        }\r\n        return this.children[index];\r\n    }\r\n    area() {\r\n        let result = this.polygon ? Clipper.area(this.polygon) : 0;\r\n        for (const polyPathBase of this.children) {\r\n            const child = polyPathBase;\r\n            result += child.area();\r\n        }\r\n        return result;\r\n    }\r\n}\r\nclass PolyTree64 extends PolyPath64 {\r\n}\r\nclass ClipperLibException extends Error {\r\n    constructor(description) {\r\n        super(description);\r\n    }\r\n}\n\n/*******************************************************************************\r\n* Author    :  Angus Johnson                                                   *\r\n* Date      :  26 July 2023                                                    *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2023                                         *\r\n* Purpose   :  Core structures and functions for the Clipper Library           *\r\n* License   :  http://www.boost.org/LICENSE_1_0.txt                            *\r\n*******************************************************************************/\r\n//\r\n// Converted from C# implemention https://github.com/AngusJohnson/Clipper2/blob/main/CSharp/Clipper2Lib/Clipper.Core.cs\r\n// Removed support for USINGZ\r\n//\r\n// Converted by ChatGPT 4 August 3 version https://help.openai.com/en/articles/6825453-chatgpt-release-notes\r\n//\r\n// Note: all clipping operations except for Difference are commutative.\r\nvar ClipType;\r\n(function (ClipType) {\r\n    ClipType[ClipType[\"None\"] = 0] = \"None\";\r\n    ClipType[ClipType[\"Intersection\"] = 1] = \"Intersection\";\r\n    ClipType[ClipType[\"Union\"] = 2] = \"Union\";\r\n    ClipType[ClipType[\"Difference\"] = 3] = \"Difference\";\r\n    ClipType[ClipType[\"Xor\"] = 4] = \"Xor\";\r\n})(ClipType || (ClipType = {}));\r\nvar PathType;\r\n(function (PathType) {\r\n    PathType[PathType[\"Subject\"] = 0] = \"Subject\";\r\n    PathType[PathType[\"Clip\"] = 1] = \"Clip\";\r\n})(PathType || (PathType = {}));\r\n// By far the most widely used filling rules for polygons are EvenOdd\r\n// and NonZero, sometimes called Alternate and Winding respectively.\r\n// https://en.wikipedia.org/wiki/Nonzero-rule\r\nvar FillRule;\r\n(function (FillRule) {\r\n    FillRule[FillRule[\"EvenOdd\"] = 0] = \"EvenOdd\";\r\n    FillRule[FillRule[\"NonZero\"] = 1] = \"NonZero\";\r\n    FillRule[FillRule[\"Positive\"] = 2] = \"Positive\";\r\n    FillRule[FillRule[\"Negative\"] = 3] = \"Negative\";\r\n})(FillRule || (FillRule = {}));\r\n// PointInPolygon\r\nvar PipResult;\r\n(function (PipResult) {\r\n    PipResult[PipResult[\"Inside\"] = 0] = \"Inside\";\r\n    PipResult[PipResult[\"Outside\"] = 1] = \"Outside\";\r\n    PipResult[PipResult[\"OnEdge\"] = 2] = \"OnEdge\";\r\n})(PipResult || (PipResult = {}));\r\nclass Path64 extends Array {\r\n}\r\nclass Paths64 extends Array {\r\n}\r\nclass Rect64 {\r\n    constructor(lOrIsValidOrRec, t, r, b) {\r\n        if (typeof lOrIsValidOrRec === 'boolean') {\r\n            if (lOrIsValidOrRec) {\r\n                this.left = 0;\r\n                this.top = 0;\r\n                this.right = 0;\r\n                this.bottom = 0;\r\n            }\r\n            else {\r\n                this.left = Number.MAX_SAFE_INTEGER;\r\n                this.top = Number.MAX_SAFE_INTEGER;\r\n                this.right = Number.MIN_SAFE_INTEGER;\r\n                this.bottom = Number.MIN_SAFE_INTEGER;\r\n            }\r\n        }\r\n        else if (typeof lOrIsValidOrRec === 'number') {\r\n            this.left = lOrIsValidOrRec;\r\n            this.top = t;\r\n            this.right = r;\r\n            this.bottom = b;\r\n        }\r\n        else {\r\n            this.left = lOrIsValidOrRec.left;\r\n            this.top = lOrIsValidOrRec.top;\r\n            this.right = lOrIsValidOrRec.right;\r\n            this.bottom = lOrIsValidOrRec.bottom;\r\n        }\r\n    }\r\n    get width() {\r\n        return this.right - this.left;\r\n    }\r\n    set width(value) {\r\n        this.right = this.left + value;\r\n    }\r\n    get height() {\r\n        return this.bottom - this.top;\r\n    }\r\n    set height(value) {\r\n        this.bottom = this.top + value;\r\n    }\r\n    isEmpty() {\r\n        return this.bottom <= this.top || this.right <= this.left;\r\n    }\r\n    midPoint() {\r\n        return new Point64((this.left + this.right) / 2, (this.top + this.bottom) / 2);\r\n    }\r\n    contains(pt) {\r\n        return pt.x > this.left && pt.x < this.right && pt.y > this.top && pt.y < this.bottom;\r\n    }\r\n    containsRect(rec) {\r\n        return rec.left >= this.left && rec.right <= this.right && rec.top >= this.top && rec.bottom <= this.bottom;\r\n    }\r\n    intersects(rec) {\r\n        return (Math.max(this.left, rec.left) <= Math.min(this.right, rec.right)) &&\r\n            (Math.max(this.top, rec.top) <= Math.min(this.bottom, rec.bottom));\r\n    }\r\n    asPath() {\r\n        const result = new Path64();\r\n        result.push(new Point64(this.left, this.top));\r\n        result.push(new Point64(this.right, this.top));\r\n        result.push(new Point64(this.right, this.bottom));\r\n        result.push(new Point64(this.left, this.bottom));\r\n        return result;\r\n    }\r\n}\r\nclass Point64 {\r\n    constructor(xOrPt, yOrScale) {\r\n        if (typeof xOrPt === 'number' && typeof yOrScale === 'number') {\r\n            this.x = Math.round(xOrPt);\r\n            this.y = Math.round(yOrScale);\r\n        }\r\n        else {\r\n            const pt = xOrPt;\r\n            if (yOrScale !== undefined) {\r\n                this.x = Math.round(pt.x * yOrScale);\r\n                this.y = Math.round(pt.y * yOrScale);\r\n            }\r\n            else {\r\n                this.x = pt.x;\r\n                this.y = pt.y;\r\n            }\r\n            //} else {\r\n            //  const pt = xOrPt as Point64\r\n            //  this.x = Math.round((<IPoint64>xOrPt).x * (yOrScale || 1));\r\n            //  this.y = Math.round((<IPoint64>xOrPt).y * (yOrScale || 1));\r\n        }\r\n    }\r\n    static equals(lhs, rhs) {\r\n        return lhs.x === rhs.x && lhs.y === rhs.y;\r\n    }\r\n    static notEquals(lhs, rhs) {\r\n        return lhs.x !== rhs.x || lhs.y !== rhs.y;\r\n    }\r\n    static add(lhs, rhs) {\r\n        return new Point64(lhs.x + rhs.x, lhs.y + rhs.y);\r\n    }\r\n    static subtract(lhs, rhs) {\r\n        return new Point64(lhs.x - rhs.x, lhs.y - rhs.y);\r\n    }\r\n    toString() {\r\n        return `${this.x},${this.y} `;\r\n    }\r\n    equals(obj) {\r\n        if (obj instanceof Point64) {\r\n            return Point64.equals(this, obj);\r\n        }\r\n        return false;\r\n    }\r\n}\r\nclass InternalClipper {\r\n    static checkPrecision(precision) {\r\n        if (precision < -8 || precision > 8)\r\n            throw new Error(this.precision_range_error);\r\n    }\r\n    static isAlmostZero(value) {\r\n        return (Math.abs(value) <= this.floatingPointTolerance);\r\n    }\r\n    static crossProduct(pt1, pt2, pt3) {\r\n        return ((pt2.x - pt1.x) * (pt3.y - pt2.y) - (pt2.y - pt1.y) * (pt3.x - pt2.x));\r\n    }\r\n    static dotProduct(pt1, pt2, pt3) {\r\n        return ((pt2.x - pt1.x) * (pt3.x - pt2.x) + (pt2.y - pt1.y) * (pt3.y - pt2.y));\r\n    }\r\n    static checkCastInt64(val) {\r\n        if ((val >= this.max_coord) || (val <= this.min_coord))\r\n            return this.Invalid64;\r\n        return Math.round(val);\r\n    }\r\n    static getIntersectPt(ln1a, ln1b, ln2a, ln2b) {\r\n        const dy1 = ln1b.y - ln1a.y;\r\n        const dx1 = ln1b.x - ln1a.x;\r\n        const dy2 = ln2b.y - ln2a.y;\r\n        const dx2 = ln2b.x - ln2a.x;\r\n        const det = dy1 * dx2 - dy2 * dx1;\r\n        let ip;\r\n        if (det === 0.0) {\r\n            ip = new Point64(0, 0);\r\n            return { ip, success: false };\r\n        }\r\n        const t = ((ln1a.x - ln2a.x) * dy2 - (ln1a.y - ln2a.y) * dx2) / det;\r\n        if (t <= 0.0)\r\n            ip = ln1a;\r\n        else if (t >= 1.0)\r\n            ip = ln1b;\r\n        else\r\n            ip = new Point64(ln1a.x + t * dx1, ln1a.y + t * dy1);\r\n        return { ip, success: true };\r\n    }\r\n    static getIntersectPoint(ln1a, ln1b, ln2a, ln2b) {\r\n        const dy1 = ln1b.y - ln1a.y;\r\n        const dx1 = ln1b.x - ln1a.x;\r\n        const dy2 = ln2b.y - ln2a.y;\r\n        const dx2 = ln2b.x - ln2a.x;\r\n        const det = dy1 * dx2 - dy2 * dx1;\r\n        let ip;\r\n        if (det === 0.0) {\r\n            ip = new Point64(0, 0);\r\n            return { ip, success: false };\r\n        }\r\n        const t = ((ln1a.x - ln2a.x) * dy2 - (ln1a.y - ln2a.y) * dx2) / det;\r\n        if (t <= 0.0)\r\n            ip = ln1a;\r\n        else if (t >= 1.0)\r\n            ip = ln2a;\r\n        else\r\n            ip = new Point64(ln1a.x + t * dx1, ln1a.y + t * dy1);\r\n        return { ip, success: true };\r\n    }\r\n    static segsIntersect(seg1a, seg1b, seg2a, seg2b, inclusive = false) {\r\n        if (inclusive) {\r\n            const res1 = InternalClipper.crossProduct(seg1a, seg2a, seg2b);\r\n            const res2 = InternalClipper.crossProduct(seg1b, seg2a, seg2b);\r\n            if (res1 * res2 > 0)\r\n                return false;\r\n            const res3 = InternalClipper.crossProduct(seg2a, seg1a, seg1b);\r\n            const res4 = InternalClipper.crossProduct(seg2b, seg1a, seg1b);\r\n            if (res3 * res4 > 0)\r\n                return false;\r\n            return (res1 !== 0 || res2 !== 0 || res3 !== 0 || res4 !== 0);\r\n        }\r\n        else {\r\n            return (InternalClipper.crossProduct(seg1a, seg2a, seg2b) * InternalClipper.crossProduct(seg1b, seg2a, seg2b) < 0) &&\r\n                (InternalClipper.crossProduct(seg2a, seg1a, seg1b) * InternalClipper.crossProduct(seg2b, seg1a, seg1b) < 0);\r\n        }\r\n    }\r\n    static getClosestPtOnSegment(offPt, seg1, seg2) {\r\n        if (seg1.x === seg2.x && seg1.y === seg2.y)\r\n            return seg1;\r\n        const dx = seg2.x - seg1.x;\r\n        const dy = seg2.y - seg1.y;\r\n        let q = ((offPt.x - seg1.x) * dx + (offPt.y - seg1.y) * dy) / ((dx * dx) + (dy * dy));\r\n        if (q < 0)\r\n            q = 0;\r\n        else if (q > 1)\r\n            q = 1;\r\n        return new Point64(seg1.x + Math.round(q * dx), seg1.y + Math.round(q * dy));\r\n    }\r\n    static pointInPolygon(pt, polygon) {\r\n        const len = polygon.length;\r\n        let start = 0;\r\n        if (len < 3)\r\n            return PointInPolygonResult.IsOutside;\r\n        while (start < len && polygon[start].y === pt.y)\r\n            start++;\r\n        if (start === len)\r\n            return PointInPolygonResult.IsOutside;\r\n        let d = 0;\r\n        let isAbove = polygon[start].y < pt.y;\r\n        const startingAbove = isAbove;\r\n        let val = 0;\r\n        let i = start + 1;\r\n        let end = len;\r\n        for (;;) {\r\n            if (i === end) {\r\n                if (end === 0 || start === 0)\r\n                    break;\r\n                end = start;\r\n                i = 0;\r\n            }\r\n            if (isAbove) {\r\n                while (i < end && polygon[i].y < pt.y)\r\n                    i++;\r\n                if (i === end)\r\n                    continue;\r\n            }\r\n            else {\r\n                while (i < end && polygon[i].y > pt.y)\r\n                    i++;\r\n                if (i === end)\r\n                    continue;\r\n            }\r\n            const curr = polygon[i];\r\n            const prev = i > 0 ? polygon[i - 1] : polygon[len - 1];\r\n            if (curr.y === pt.y) {\r\n                if (curr.x === pt.x || (curr.y === prev.y && (pt.x < prev.x !== pt.x < curr.x)))\r\n                    return PointInPolygonResult.IsOn;\r\n                i++;\r\n                if (i === start)\r\n                    break;\r\n                continue;\r\n            }\r\n            if (pt.x < curr.x && pt.x < prev.x) {\r\n                // we're only interested in edges crossing on the left\r\n            }\r\n            else if (pt.x > prev.x && pt.x > curr.x) {\r\n                val = 1 - val; // toggle val\r\n            }\r\n            else {\r\n                d = InternalClipper.crossProduct(prev, curr, pt);\r\n                if (d === 0)\r\n                    return PointInPolygonResult.IsOn;\r\n                if ((d < 0) === isAbove)\r\n                    val = 1 - val;\r\n            }\r\n            isAbove = !isAbove;\r\n            i++;\r\n        }\r\n        if (isAbove !== startingAbove) {\r\n            if (i === len)\r\n                i = 0;\r\n            else\r\n                d = InternalClipper.crossProduct(polygon[i - 1], polygon[i], pt);\r\n            if (d === 0)\r\n                return PointInPolygonResult.IsOn;\r\n            if ((d < 0) === isAbove)\r\n                val = 1 - val;\r\n        }\r\n        if (val === 0)\r\n            return PointInPolygonResult.IsOutside;\r\n        return PointInPolygonResult.IsInside;\r\n    }\r\n}\r\nInternalClipper.MaxInt64 = 9223372036854775807;\r\nInternalClipper.MaxCoord = InternalClipper.MaxInt64 / 4;\r\nInternalClipper.max_coord = InternalClipper.MaxCoord;\r\nInternalClipper.min_coord = -InternalClipper.MaxCoord;\r\nInternalClipper.Invalid64 = InternalClipper.MaxInt64;\r\nInternalClipper.defaultArcTolerance = 0.25;\r\nInternalClipper.floatingPointTolerance = 1E-12;\r\nInternalClipper.defaultMinimumEdgeLength = 0.1;\r\nInternalClipper.precision_range_error = \"Error: Precision is out of range.\";\n\n/*\r\n * Public API Surface of clipper2-js\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { Active, ClipType, Clipper, Clipper64, ClipperBase, ClipperEngine, ClipperLibException, ClipperOffset, EndType, FillRule, HorzPosition, InternalClipper, JoinType, JoinWith, Minkowski, OutPt2, OutRec, Path64, PathType, Paths64, PipResult, Point64, PointD, PointInPolygonResult, PolyPath64, PolyPathBase, PolyTree64, Rect64, RectClip64, RectClipLines64, ReuseableDataContainer64, VertexFlags };\n//# sourceMappingURL=clipper2-js.mjs.map\n","const DIRECTION_EPSILON = 1e-3;\nconst DIST_EPSILON = 1e2;\n\nfunction sameDirection( p0, p1, p2 ) {\n\n\tconst dx1 = p1.x - p0.x;\n\tconst dy1 = p1.y - p0.y;\n\n\tconst dx2 = p2.x - p1.x;\n\tconst dy2 = p2.y - p1.y;\n\n\tconst s1 = dx1 / dy1;\n\tconst s2 = dx2 / dy2;\n\n\treturn Math.abs( s1 - s2 ) < DIRECTION_EPSILON;\n\n}\n\nfunction areClose( p0, p1 ) {\n\n\tconst dx = p1.x - p0.x;\n\tconst dy = p1.y - p0.y;\n\treturn Math.sqrt( dx * dx + dy * dy ) < DIST_EPSILON;\n\n}\n\nfunction areEqual( p0, p1 ) {\n\n\treturn p0.x === p1.x && p0.y === p1.y;\n\n}\n\nexport function compressPoints( points ) {\n\n\tfor ( let k = 0; k < points.length; k ++ ) {\n\n\t\t// remove points that are equal or very close to each other\n\t\tconst v = points[ k ];\n\t\twhile ( true ) {\n\n\t\t\tconst k1 = k + 1;\n\t\t\tif (\n\t\t\t\tpoints.length > k1 &&\n\t\t\t\t(\n\t\t\t\t\tareEqual( v, points[ k1 ] ) ||\n\t\t\t\t\tareClose( v, points[ k1 ] )\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tpoints.splice( k1, 1 );\n\n\t\t\t} else {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\n\t\t}\n\n\t\t// join lines that are almost the same direction\n\t\twhile ( true ) {\n\n\t\t\tconst k1 = k + 1;\n\t\t\tconst k2 = k + 2;\n\t\t\tif (\n\t\t\t\tpoints.length > k2 &&\n\t\t\t\tsameDirection( v, points[ k1 ], points[ k2 ] )\n\t\t\t) {\n\n\t\t\t\tpoints.splice( k + 1, 1 );\n\n\t\t\t} else {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { Line3, Ray } from 'three';\n\nfunction xzToXzCopy( v, target ) {\n\n\ttarget.x = v.x;\n\ttarget.y = v.z;\n\n}\n\nfunction epsEquals( a, b ) {\n\n\treturn Math.abs( a - b ) <= 500;\n\n}\n\nfunction vectorEpsEquals( v0, v1 ) {\n\n\treturn epsEquals( v0.x, v1.x ) &&\n\t\tepsEquals( v0.y, v1.y ) &&\n\t\tepsEquals( v0.z, v1.z );\n\n}\n\nexport function triangleIsInsidePaths( tri, paths ) {\n\n\tconst indices = [ 'a', 'b', 'c' ];\n\tconst edges = [ new Line3(), new Line3(), new Line3() ];\n\tconst line = new Line3();\n\tconst ray = new Line3();\n\tray.start\n\t\t.set( 0, 0, 0 )\n\t\t.addScaledVector( tri.a, 1 / 3 )\n\t\t.addScaledVector( tri.b, 1 / 3 )\n\t\t.addScaledVector( tri.c, 1 / 3 );\n\n\txzToXzCopy( ray.start, ray.start );\n\tray.end.copy( ray.start );\n\tray.end.y += 1e10;\n\n\t// get all triangle edges\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst i1 = ( i + 1 ) % 3;\n\t\tconst p0 = tri[ indices[ i ] ];\n\t\tconst p1 = tri[ indices[ i1 ] ];\n\n\t\tconst edge = edges[ i ];\n\t\txzToXzCopy( p0, edge.start );\n\t\txzToXzCopy( p1, edge.end );\n\n\t}\n\n\tlet crossCount = 0;\n\tfor ( let p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\tconst points = paths[ p ];\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst i1 = ( i + 1 ) % l;\n\t\t\tline.start.copy( points[ i ] );\n\t\t\tline.start.z = 0;\n\n\t\t\tline.end.copy( points[ i1 ] );\n\t\t\tline.end.z = 0;\n\n\t\t\tif ( lineCrossesLine( ray, line ) ) {\n\n\t\t\t\tcrossCount ++;\n\n\t\t\t}\n\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tconst edge = edges[ e ];\n\t\t\t\tif (\n\t\t\t\t\tlineCrossesLine( edge, line ) ||\n\t\t\t\t\tvectorEpsEquals( edge.start, line.start ) ||\n\t\t\t\t\tvectorEpsEquals( edge.end, line.end ) ||\n\t\t\t\t\tvectorEpsEquals( edge.end, line.start ) ||\n\t\t\t\t\tvectorEpsEquals( edge.start, line.end )\n\t\t\t\t) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn crossCount % 2 === 1;\n\n}\n\n// https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\nfunction lineCrossesLine( l1, l2 ) {\n\n\tfunction ccw( A, B, C ) {\n\n\t\treturn ( C.y - A.y ) * ( B.x - A.x ) > ( B.y - A.y ) * ( C.x - A.x );\n\n\t}\n\n\tconst A = l1.start;\n\tconst B = l1.end;\n\n\tconst C = l2.start;\n\tconst D = l2.end;\n\n\treturn ccw( A, C, D ) !== ccw( B, C, D ) && ccw( A, B, C ) !== ccw( A, B, D );\n\n}\n","import { Path64, Clipper, FillRule } from 'clipper2-js';\nimport { ShapeGeometry, Vector3, Shape, Vector2, Triangle, ShapeUtils, BufferGeometry } from 'three';\nimport { compressPoints } from './utils/compressPoints.js';\nimport { triangleIsInsidePaths } from './utils/triangleIsInsidePaths.js';\nimport { getSizeSortedTriList } from './utils/getSizeSortedTriList.js';\nimport { getTriCount } from './utils/geometryUtils.js';\n\nconst AREA_EPSILON = 1e-8;\nconst UP_VECTOR = /* @__PURE__ */ new Vector3( 0, 1, 0 );\nconst _tri = /* @__PURE__ */ new Triangle();\nconst _normal = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _vec = /* @__PURE__ */ new Vector3();\n\nfunction convertPathToGeometry( path, scale ) {\n\n\tconst vector2s = path.map( points => {\n\n\t\treturn points.flatMap( v => new Vector2( v.x / scale, v.y / scale ) );\n\n\t} );\n\n\tconst holesShapes = vector2s\n\t\t.filter( p => ShapeUtils.isClockWise( p ) )\n\t\t.map( p => new Shape( p ) );\n\n\tconst solidShapes = vector2s\n\t\t.filter( p => ! ShapeUtils.isClockWise( p ) )\n\t\t.map( p => {\n\n\t\t\tconst shape = new Shape( p );\n\t\t\tshape.holes = holesShapes;\n\t\t\treturn shape;\n\n\t\t} );\n\n\t// flip the triangles so they're facing in the right direction\n\tconst result = new ShapeGeometry( solidShapes ).rotateX( Math.PI / 2 );\n\tresult.index.array.reverse();\n\treturn result;\n\n}\n\nfunction convertPathToLineSegments( path, scale ) {\n\n\tconst arr = [];\n\tpath.forEach( points => {\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst i1 = ( i + 1 ) % points.length;\n\t\t\tconst p0 = points[ i ];\n\t\t\tconst p1 = points[ i1 ];\n\t\t\tarr.push(\n\t\t\t\tnew Vector3( p0.x / scale, 0, p0.y / scale ),\n\t\t\t\tnew Vector3( p1.x / scale, 0, p1.y / scale )\n\t\t\t);\n\n\t\t}\n\n\t} );\n\n\tconst result = new BufferGeometry();\n\tresult.setFromPoints( arr );\n\treturn result;\n\n}\n\nexport const OUTPUT_MESH = 0;\nexport const OUTPUT_LINE_SEGMENTS = 1;\nexport const OUTPUT_BOTH = 2;\nexport class SilhouetteGenerator {\n\n\tconstructor() {\n\n\t\tthis.iterationTime = 30;\n\t\tthis.intScalar = 1e9;\n\t\tthis.doubleSided = false;\n\t\tthis.sortTriangles = false;\n\t\tthis.output = OUTPUT_MESH;\n\n\t}\n\n\tgenerateAsync( geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tconst { signal } = options;\n\t\t\tconst task = this.generate( geometry, options );\n\t\t\trun();\n\n\t\t\tfunction run() {\n\n\t\t\t\tif ( signal && signal.aborted ) {\n\n\t\t\t\t\treject( new Error( 'SilhouetteGenerator: Process aborted via AbortSignal.' ) );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst result = task.next();\n\t\t\t\tif ( result.done ) {\n\n\t\t\t\t\tresolve( result.value );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trequestAnimationFrame( run );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} );\n\n\t}\n\n\t*generate( geometry, options = {} ) {\n\n\t\tconst { iterationTime, intScalar, doubleSided, output, sortTriangles } = this;\n\t\tconst { onProgress } = options;\n\t\tconst power = Math.log10( intScalar );\n\t\tconst extendMultiplier = Math.pow( 10, - ( power - 2 ) );\n\n\t\tconst index = geometry.index;\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst triCount = getTriCount( geometry );\n\t\tlet overallPath = null;\n\n\t\tconst triList = sortTriangles ?\n\t\t\tgetSizeSortedTriList( geometry ) :\n\t\t\tnew Array( triCount ).fill().map( ( v, i ) => i );\n\n\t\tconst handle = {\n\n\t\t\tgetGeometry() {\n\n\t\t\t\tif ( output === OUTPUT_MESH ) {\n\n\t\t\t\t\treturn convertPathToGeometry( overallPath, intScalar );\n\n\t\t\t\t} else if ( output === OUTPUT_LINE_SEGMENTS ) {\n\n\t\t\t\t\treturn convertPathToLineSegments( overallPath, intScalar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tconvertPathToGeometry( overallPath, intScalar ),\n\t\t\t\t\t\tconvertPathToLineSegments( overallPath, intScalar ),\n\t\t\t\t\t];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tlet time = performance.now();\n\t\tfor ( let ti = 0; ti < triCount; ti ++ ) {\n\n\t\t\tconst i = triList[ ti ] * 3;\n\t\t\tlet i0 = i + 0;\n\t\t\tlet i1 = i + 1;\n\t\t\tlet i2 = i + 2;\n\t\t\tif ( index ) {\n\n\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t}\n\n\t\t\t// get the triangle\n\t\t\tconst { a, b, c } = _tri;\n\t\t\ta.fromBufferAttribute( posAttr, i0 );\n\t\t\tb.fromBufferAttribute( posAttr, i1 );\n\t\t\tc.fromBufferAttribute( posAttr, i2 );\n\t\t\tif ( ! doubleSided ) {\n\n\t\t\t\t_tri.getNormal( _normal );\n\t\t\t\tif ( _normal.dot( UP_VECTOR ) < 0 ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// flatten the triangle\n\t\t\ta.y = 0;\n\t\t\tb.y = 0;\n\t\t\tc.y = 0;\n\n\t\t\tif ( _tri.getArea() < AREA_EPSILON ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// expand the triangle by a small degree to ensure overlap\n\t\t\t_center\n\t\t\t\t.copy( a )\n\t\t\t\t.add( b )\n\t\t\t\t.add( c )\n\t\t\t\t.multiplyScalar( 1 / 3 );\n\n\t\t\t_vec.subVectors( a, _center ).normalize();\n\t\t\ta.addScaledVector( _vec, extendMultiplier );\n\n\t\t\t_vec.subVectors( b, _center ).normalize();\n\t\t\tb.addScaledVector( _vec, extendMultiplier );\n\n\t\t\t_vec.subVectors( c, _center ).normalize();\n\t\t\tc.addScaledVector( _vec, extendMultiplier );\n\n\t\t\t// create the path\n\t\t\tconst path = new Path64();\n\t\t\tpath.push( Clipper.makePath( [\n\t\t\t\ta.x * intScalar, a.z * intScalar,\n\t\t\t\tb.x * intScalar, b.z * intScalar,\n\t\t\t\tc.x * intScalar, c.z * intScalar,\n\t\t\t] ) );\n\n\t\t\ta.multiplyScalar( intScalar );\n\t\t\tb.multiplyScalar( intScalar );\n\t\t\tc.multiplyScalar( intScalar );\n\t\t\tif ( overallPath && triangleIsInsidePaths( _tri, overallPath ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// perform union\n\t\t\tif ( overallPath === null ) {\n\n\t\t\t\toverallPath = path;\n\n\t\t\t} else {\n\n\t\t\t\toverallPath = Clipper.Union( overallPath, path, FillRule.NonZero );\n\t\t\t\toverallPath.forEach( path => compressPoints( path ) );\n\n\t\t\t}\n\n\t\t\tconst delta = performance.now() - time;\n\t\t\tif ( delta > iterationTime ) {\n\n\t\t\t\tif ( onProgress ) {\n\n\t\t\t\t\tconst progress = ti / triCount;\n\t\t\t\t\tonProgress( progress, handle );\n\n\t\t\t\t}\n\n\t\t\t\tyield;\n\t\t\t\ttime = performance.now();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn handle.getGeometry();\n\n\t}\n\n}\n"],"names":["JoinType","EndType","Location","result","PointInPolygonResult","VertexFlags","JoinWith","HorzPosition","count","ClipType","PathType","FillRule","PipResult","A","B","C","path"],"mappings":"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","x_google_ignoreList":[0]}