{"version":3,"file":"ProjectionGenerator-DFBBZv3o.js","sources":["../../../node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js","../../../src/utils/overlapUtils.js","../../../src/utils/generateEdges.js","../../../src/utils/generateIntersectionEdges.js","../../../src/utils/getAllMeshes.js","../../../src/EdgeGenerator.js","../../../src/utils/LineObjectsBVH.js","../../../src/ProjectionGenerator.js"],"sourcesContent":["import { Mesh, Points, Line, LineLoop, LineSegments, Sphere, BatchedMesh, REVISION } from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst IS_REVISION_166 = parseInt( REVISION ) >= 166;\n\n// TODO: how can we expand these raycast functions?\nconst _raycastFunctions = {\n\t'Mesh': Mesh.prototype.raycast,\n\t'Line': Line.prototype.raycast,\n\t'LineSegments': LineSegments.prototype.raycast,\n\t'LineLoop': LineLoop.prototype.raycast,\n\t'Points': Points.prototype.raycast,\n\t'BatchedMesh': BatchedMesh.prototype.raycast,\n};\n\nconst _mesh = /* @__PURE__ */ new Mesh();\nconst _batchIntersects = [];\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.isBatchedMesh ) {\n\n\t\tacceleratedBatchedMeshRaycast.call( this, raycaster, intersects );\n\n\t} else {\n\n\t\tconst { geometry } = this;\n\t\tif ( geometry.boundsTree ) {\n\n\t\t\tgeometry.boundsTree.raycastObject3D( this, raycaster, intersects );\n\n\t\t} else {\n\n\t\t\tlet raycastFunction;\n\t\t\tif ( this instanceof Mesh ) {\n\n\t\t\t\traycastFunction = _raycastFunctions.Mesh;\n\n\t\t\t} else if ( this instanceof LineSegments ) {\n\n\t\t\t\traycastFunction = _raycastFunctions.LineSegments;\n\n\t\t\t} else if ( this instanceof LineLoop ) {\n\n\t\t\t\traycastFunction = _raycastFunctions.LineLoop;\n\n\t\t\t} else if ( this instanceof Line ) {\n\n\t\t\t\traycastFunction = _raycastFunctions.Line;\n\n\t\t\t} else if ( this instanceof Points ) {\n\n\t\t\t\traycastFunction = _raycastFunctions.Points;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'BVH: Fallback raycast function not found.' );\n\n\t\t\t}\n\n\t\t\traycastFunction.call( this, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nfunction acceleratedBatchedMeshRaycast( raycaster, intersects ) {\n\n\tif ( this.boundsTrees ) {\n\n\t\t// TODO: remove use of geometry info, instance info when r170 is minimum version\n\t\tconst boundsTrees = this.boundsTrees;\n\t\tconst drawInfo = this._drawInfo || this._instanceInfo;\n\t\tconst drawRanges = this._drawRanges || this._geometryInfo;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\t_mesh.material = this.material;\n\t\t_mesh.geometry = this.geometry;\n\n\t\tconst oldBoundsTree = _mesh.geometry.boundsTree;\n\t\tconst oldDrawRange = _mesh.geometry.drawRange;\n\n\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t_mesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\t// TODO: provide new method to get instances count instead of 'drawInfo.length'\n\t\tfor ( let i = 0, l = drawInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( ! this.getVisibleAt( i ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// TODO: use getGeometryIndex\n\t\t\tconst geometryId = drawInfo[ i ].geometryIndex;\n\n\t\t\t_mesh.geometry.boundsTree = boundsTrees[ geometryId ];\n\n\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\n\t\t\tif ( ! _mesh.geometry.boundsTree ) {\n\n\t\t\t\tthis.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );\n\t\t\t\tthis.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );\n\n\t\t\t\tconst drawRange = drawRanges[ geometryId ];\n\t\t\t\t_mesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\n\t\t\t}\n\n\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersect.batchId = i;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_batchIntersects.length = 0;\n\n\t\t}\n\n\t\t_mesh.geometry.boundsTree = oldBoundsTree;\n\t\t_mesh.geometry.drawRange = oldDrawRange;\n\t\t_mesh.material = null;\n\t\t_mesh.geometry = null;\n\n\t} else {\n\n\t\t_raycastFunctions.BatchedMesh.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options = {} ) {\n\n\tconst { type = MeshBVH } = options;\n\tthis.boundsTree = new type( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n\nexport function computeBatchedBoundsTree( index = - 1, options = {} ) {\n\n\tif ( ! IS_REVISION_166 ) {\n\n\t\tthrow new Error( 'BatchedMesh: Three r166+ is required to compute bounds trees.' );\n\n\t}\n\n\toptions = {\n\t\t...options,\n\t\trange: null\n\t};\n\n\tconst drawRanges = this._drawRanges || this._geometryInfo;\n\tconst geometryCount = this._geometryCount;\n\tif ( ! this.boundsTrees ) {\n\n\t\tthis.boundsTrees = new Array( geometryCount ).fill( null );\n\n\t}\n\n\tconst boundsTrees = this.boundsTrees;\n\twhile ( boundsTrees.length < geometryCount ) {\n\n\t\tboundsTrees.push( null );\n\n\t}\n\n\tif ( index < 0 ) {\n\n\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\toptions.range = drawRanges[ i ];\n\t\t\tboundsTrees[ i ] = new MeshBVH( this.geometry, options );\n\n\t\t}\n\n\t\treturn boundsTrees;\n\n\t} else {\n\n\t\tif ( index < drawRanges.length ) {\n\n\t\t\toptions.range = drawRanges[ index ];\n\t\t\tboundsTrees[ index ] = new MeshBVH( this.geometry, options );\n\n\t\t}\n\n\t\treturn boundsTrees[ index ] || null;\n\n\t}\n\n}\n\nexport function disposeBatchedBoundsTree( index = - 1 ) {\n\n\tif ( index < 0 ) {\n\n\t\tthis.boundsTrees.fill( null );\n\n\t} else {\n\n\t\tif ( index < this.boundsTrees.length ) {\n\n\t\t\tthis.boundsTrees[ index ] = null;\n\n\t\t}\n\n\t}\n\n}\n","import { Line3 } from 'three';\n\nconst _line = /* @__PURE__ */ new Line3();\n\n// Converts the given array of overlaps into line segments\nexport function overlapsToLines( line, overlaps, invert = false, target = [] ) {\n\n\t// Function assumes the line overlaps are already compressed\n\tlet invOverlaps = [[ 0, 1 ]];\n\tfor ( let i = 0, l = overlaps.length; i < l; i ++ ) {\n\n\t\tconst invOverlap = invOverlaps[ i ];\n\t\tconst overlap = overlaps[ i ];\n\t\tinvOverlap[ 1 ] = overlap[ 0 ];\n\t\tinvOverlaps.push( [ overlap[ 1 ], 1 ] );\n\n\t}\n\n\tif ( invert ) {\n\n\t\t[ overlaps, invOverlaps ] = [ invOverlaps, overlaps ];\n\n\t}\n\n\tfor ( let i = 0, l = invOverlaps.length; i < l; i ++ ) {\n\n\t\tconst { start, end } = line;\n\t\t_line.start.lerpVectors( start, end, invOverlaps[ i ][ 0 ] );\n\t\t_line.end.lerpVectors( start, end, invOverlaps[ i ][ 1 ] );\n\n\t\ttarget.push( new Float32Array( [\n\t\t\t_line.start.x,\n\t\t\t_line.start.y,\n\t\t\t_line.start.z,\n\n\t\t\t_line.end.x,\n\t\t\t_line.end.y,\n\t\t\t_line.end.z,\n\t\t] ) );\n\n\t}\n\n\treturn target;\n\n}\n","import { Vector3, Triangle, Line3, MathUtils } from 'three';\n\n// Modified version of js EdgesGeometry logic to handle silhouette edges\nconst EPSILON = 1e-10;\nconst UP_VECTOR = /* @__PURE__ */ new Vector3( 0, 1, 0 );\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\nconst _normal = /* @__PURE__ */ new Vector3();\nconst _triangle = /* @__PURE__ */ new Triangle();\n\nexport function* generateEdges( geometry, target = [], options = {} ) {\n\n\tconst {\n\t\tprojectionDirection = UP_VECTOR,\n\t\tthresholdAngle = 1,\n\t\titerationTime = 30,\n\t} = options;\n\n\tconst precisionPoints = 4;\n\tconst precision = Math.pow( 10, precisionPoints );\n\tconst thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );\n\n\tconst indexAttr = geometry.getIndex();\n\tconst positionAttr = geometry.getAttribute( 'position' );\n\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\tconst indexArr = [ 0, 0, 0 ];\n\tconst vertKeys = [ 'a', 'b', 'c' ];\n\tconst hashes = new Array( 3 );\n\n\tconst edgeData = {};\n\tlet time = performance.now();\n\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\tif ( performance.now() - time > iterationTime ) {\n\n\t\t\tyield;\n\t\t\ttime = performance.now();\n\n\t\t}\n\n\t\tif ( indexAttr ) {\n\n\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t} else {\n\n\t\t\tindexArr[ 0 ] = i;\n\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t}\n\n\t\tconst { a, b, c } = _triangle;\n\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t_triangle.getNormal( _normal );\n\n\t\t// create hashes for the edge from the vertices\n\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t// skip degenerate triangles\n\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// iterate over every edge\n\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t// get the first and next vertex making up the edge\n\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\tconst otherNormal = edgeData[ reverseHash ].normal;\n\t\t\t\tconst meetsThreshold = _normal.dot( otherNormal ) <= thresholdDot;\n\n\t\t\t\t// get the dot product relative to the projection angle and\n\t\t\t\t// add an epsilon for nearly vertical triangles\n\t\t\t\tlet projectionThreshold = false;\n\t\t\t\tif ( projectionDirection !== null ) {\n\n\t\t\t\t\tlet normDot = projectionDirection.dot( _normal );\n\t\t\t\t\tnormDot = Math.abs( normDot ) < EPSILON ? 0 : normDot;\n\n\t\t\t\t\tlet otherDot = projectionDirection.dot( otherNormal );\n\t\t\t\t\totherDot = Math.abs( otherDot ) < EPSILON ? 0 : otherDot;\n\n\t\t\t\t\tprojectionThreshold = Math.sign( normDot ) !== Math.sign( otherDot );\n\n\t\t\t\t}\n\n\t\t\t\tif ( meetsThreshold || projectionThreshold ) {\n\n\t\t\t\t\tconst line = new Line3();\n\t\t\t\t\tline.start.copy( v0 );\n\t\t\t\t\tline.end.copy( v1 );\n\t\t\t\t\ttarget.push( line );\n\n\t\t\t\t}\n\n\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\tfor ( const key in edgeData ) {\n\n\t\tif ( edgeData[ key ] ) {\n\n\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t_v1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\tconst line = new Line3();\n\t\t\tline.start.copy( _v0 );\n\t\t\tline.end.copy( _v1 );\n\t\t\ttarget.push( line );\n\n\t\t}\n\n\t}\n\n\treturn target;\n\n}\n","import { Line3 } from 'three';\nimport { isLineTriangleEdge } from './triangleLineUtils.js';\n\n// TODO: How can we add support for \"iterationTime\"?\n\nconst _line = /* @__PURE__ */ new Line3();\nexport function generateIntersectionEdges( bvhA, bvhB, matrixBToA, target = [] ) {\n\n\tbvhA.bvhcast( bvhB, matrixBToA, {\n\t\tintersectsTriangles: ( tri1, tri2 ) => {\n\n\t\t\tif ( areTrianglesOnEdge( tri1, tri2 ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( tri1.needsUpdate ) {\n\n\t\t\t\ttri1.update();\n\n\t\t\t}\n\n\t\t\tif ( tri2.needsUpdate ) {\n\n\t\t\t\ttri2.update();\n\n\t\t\t}\n\n\t\t\tif ( Math.abs( tri1.plane.normal.dot( tri2.plane.normal ) ) > 1 - 1e-6 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttri1.intersectsTriangle( tri2, _line, true ) &&\n\t\t\t\t! isLineTriangleEdge( tri1, _line ) &&\n\t\t\t\t! isLineTriangleEdge( tri2, _line )\n\t\t\t) {\n\n\t\t\t\ttarget.push( _line.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn target;\n\n}\n\nfunction areVectorsEqual( a, b ) {\n\n\treturn a.distanceTo( b ) < 1e-10;\n\n}\n\nfunction areTrianglesOnEdge( t1, t2 ) {\n\n\tconst indices = [ 'a', 'b', 'c' ];\n\tlet tot = 0;\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\tconst v0 = t1[ indices[ i ] ];\n\t\t\tconst v1 = t2[ indices[ j ] ];\n\t\t\tif ( areVectorsEqual( v0, v1 ) ) {\n\n\t\t\t\ttot ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn tot >= 2;\n\n}\n","export function getAllMeshes( scene ) {\n\n\tlet meshes = [];\n\tscene.traverse( c => {\n\n\t\tif ( c.geometry && c.visible ) {\n\n\t\t\tmeshes.push( c );\n\n\t\t}\n\n\t} );\n\n\treturn meshes;\n\n}\n","import { Vector3, Matrix4 } from 'three';\nimport { MeshBVH } from 'three-mesh-bvh';\nimport { generateEdges } from './utils/generateEdges.js';\nimport { generateIntersectionEdges } from './utils/generateIntersectionEdges.js';\nimport { getAllMeshes } from './utils/getAllMeshes.js';\n\nconst _BtoA = /* @__PURE__ */ new Matrix4();\nconst _toLocalMatrix = /* @__PURE__ */ new Matrix4();\n\n// Class for generating edges for use with the projection generator. Functions take geometries or\n// Object3D instances. If an Object3D is passed then lines for all child meshes will be generated\n// in world space\n// TODO:\n// - add support for progress functions\nexport class EdgeGenerator {\n\n\tconstructor() {\n\n\t\tthis.projectionDirection = new Vector3( 0, 1, 0 );\n\t\tthis.thresholdAngle = 50;\n\t\tthis.iterationTime = 30;\n\n\t}\n\n\t// Functions for generating the \"hard\" and silhouette edges of the geometry along the projection direction\n\tgetEdges( ...args ) {\n\n\t\tconst currIterationTime = this.iterationTime;\n\t\tthis.iterationTime = Infinity;\n\n\t\tconst result = this.getEdgesGenerator( ...args ).next().value;\n\t\tthis.iterationTime = currIterationTime;\n\n\t\treturn result;\n\n\t}\n\n\t*getEdgesGenerator( geometry, resultEdges = [] ) {\n\n\t\tconst { projectionDirection, thresholdAngle, iterationTime } = this;\n\t\tif ( geometry.isObject3D ) {\n\n\t\t\tconst meshes = getAllMeshes( geometry );\n\t\t\tlet localProjection = null;\n\t\t\tif ( projectionDirection ) {\n\n\t\t\t\tlocalProjection = new Vector3();\n\n\t\t\t}\n\n\t\t\tlet time = performance.now();\n\t\t\tfor ( let i = 0; i < meshes.length; i ++ ) {\n\n\t\t\t\tif ( time - performance.now() > iterationTime ) {\n\n\t\t\t\t\tyield;\n\n\t\t\t\t}\n\n\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\tif ( localProjection ) {\n\n\t\t\t\t\t_toLocalMatrix.copy( mesh.matrixWorld ).invert();\n\t\t\t\t\tlocalProjection\n\t\t\t\t\t\t.copy( projectionDirection )\n\t\t\t\t\t\t.transformDirection( _toLocalMatrix )\n\t\t\t\t\t\t.normalize();\n\n\t\t\t\t}\n\n\t\t\t\tconst results = yield* generateEdges( mesh.geometry, [], {\n\t\t\t\t\tprojectionDirection: localProjection,\n\t\t\t\t\tthresholdAngle: thresholdAngle,\n\t\t\t\t\titerationTime: iterationTime,\n\t\t\t\t} );\n\n\t\t\t\ttransformEdges( results, mesh.matrixWorld );\n\n\t\t\t\t// push the edges individually to avoid stack overflow\n\t\t\t\tfor ( let i = 0; i < results.length; i ++ ) {\n\n\t\t\t\t\tresultEdges.push( results[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn resultEdges;\n\n\t\t} else {\n\n\t\t\treturn yield* generateEdges( geometry, resultEdges, {\n\t\t\t\tprojectionDirection: projectionDirection,\n\t\t\t\tthresholdAngle: thresholdAngle,\n\t\t\t\titerationTime: iterationTime,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// Functions for generating a set of \"intersection\" edges within an existing geometry\n\t// TODO: these needs to support generating \"intersection edges\" within a set of other geometries, as well\n\tgetIntersectionEdges( ...args ) {\n\n\t\tconst currIterationTime = this.iterationTime;\n\t\tthis.iterationTime = Infinity;\n\n\t\tconst result = this.getIntersectionEdgesGenerator( ...args ).next().value;\n\t\tthis.iterationTime = currIterationTime;\n\n\t\treturn result;\n\n\t}\n\n\t*getIntersectionEdgesGenerator( geometry, resultEdges = [] ) {\n\n\t\tconst { iterationTime } = this;\n\t\tif ( geometry.isObject3D ) {\n\n\t\t\t// get the bounds trees from all geometry\n\t\t\tconst meshes = getAllMeshes( geometry );\n\t\t\tconst bvhs = new Map();\n\t\t\tlet time = performance.now();\n\t\t\tfor ( let i = 0; i < meshes.length; i ++ ) {\n\n\t\t\t\tif ( performance.now() - time > iterationTime ) {\n\n\t\t\t\t\tyield;\n\t\t\t\t\ttime = performance.now();\n\n\t\t\t\t}\n\n\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\tconst geometry = mesh.geometry;\n\t\t\t\tif ( ! bvhs.has( geometry ) ) {\n\n\t\t\t\t\tconst bvh = geometry.boundsTree || new MeshBVH( geometry, { maxLeafSize: 1 } );\n\t\t\t\t\tbvhs.set( geometry, bvh );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check each mesh against all others\n\t\t\ttime = performance.now();\n\t\t\tfor ( let i = 0; i < meshes.length; i ++ ) {\n\n\t\t\t\tfor ( let j = i; j < meshes.length; j ++ ) {\n\n\t\t\t\t\tif ( performance.now() - time > iterationTime ) {\n\n\t\t\t\t\t\tyield;\n\t\t\t\t\t\ttime = performance.now();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst meshA = meshes[ i ];\n\t\t\t\t\tconst meshB = meshes[ j ];\n\t\t\t\t\tconst bvhA = bvhs.get( meshA.geometry );\n\t\t\t\t\tconst bvhB = bvhs.get( meshB.geometry );\n\n\t\t\t\t\t// A-1 * B * v\n\t\t\t\t\t_BtoA\n\t\t\t\t\t\t.copy( meshA.matrixWorld )\n\t\t\t\t\t\t.invert()\n\t\t\t\t\t\t.multiply( meshB.matrixWorld );\n\n\t\t\t\t\tconst results = generateIntersectionEdges( bvhA, bvhB, _BtoA, [], { iterationTime } );\n\t\t\t\t\ttransformEdges( results, meshA.matrixWorld );\n\n\t\t\t\t\t// push the edges individually to avoid stack overflow\n\t\t\t\t\tfor ( let i = 0; i < results.length; i ++ ) {\n\n\t\t\t\t\t\tresultEdges.push( results[ i ] );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn resultEdges;\n\n\t\t} else {\n\n\t\t\tlet bvh;\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tbvh = geometry.boundsTree || new MeshBVH( geometry, { maxLeafSize: 1 } );\n\n\t\t\t} else {\n\n\t\t\t\tbvh = geometry;\n\t\t\t\tgeometry = bvh.geometry;\n\n\t\t\t}\n\n\t\t\t_BtoA.identity();\n\t\t\treturn generateIntersectionEdges( bvh, bvh, _BtoA, resultEdges, { iterationTime } );\n\n\t\t}\n\n\t}\n\n}\n\n// add an offset to avoid precision errors when detecting intersections and clipping\nfunction transformEdges( list, matrix, offset = 1e-6 ) {\n\n\tfor ( let i = 0; i < list.length; i ++ ) {\n\n\t\tconst line = list[ i ];\n\t\tline.applyMatrix4( matrix );\n\t\tline.start.y += offset;\n\t\tline.end.y += offset;\n\n\t}\n\n}\n","import { BVH } from 'three-mesh-bvh';\nexport class LineObjectsBVH extends BVH {\n\n\tget lines() {\n\n\t\treturn this.primitiveBuffer;\n\n\t}\n\n\tconstructor( lines, options ) {\n\n\t\tsuper( options );\n\n\t\tthis.primitiveBuffer = lines;\n\t\tthis.primitiveBufferStride = 1;\n\n\t\tthis.heightOffset = options.heightOffset ?? 1e3;\n\t\tthis.init( options );\n\n\t}\n\n\twritePrimitiveBounds( i, targetBuffer, writeOffset ) {\n\n\t\tconst { primitiveBuffer, heightOffset } = this;\n\t\tconst { start, end } = primitiveBuffer[ i ];\n\n\t\ttargetBuffer[ writeOffset + 0 ] = Math.min( start.x, end.x );\n\t\ttargetBuffer[ writeOffset + 1 ] = Math.min( start.y, end.y );\n\t\ttargetBuffer[ writeOffset + 2 ] = Math.min( start.z, end.z );\n\n\t\ttargetBuffer[ writeOffset + 3 ] = Math.max( start.x, end.x );\n\t\ttargetBuffer[ writeOffset + 4 ] = Math.max( start.y, end.y ) + heightOffset;\n\t\ttargetBuffer[ writeOffset + 5 ] = Math.max( start.z, end.z );\n\n\t}\n\n\tgetRootRanges() {\n\n\t\treturn [ { offset: 0, count: this.primitiveBuffer.length } ];\n\n\t}\n\n}\n","import {\n\tBufferGeometry,\n\tVector3,\n\tBufferAttribute,\n\tMesh,\n\tLine3,\n\tBox3,\n\tRaycaster,\n} from 'three';\nimport { MeshBVH, SAH, acceleratedRaycast } from 'three-mesh-bvh';\nimport { isYProjectedLineDegenerate } from './utils/triangleLineUtils.js';\nimport { overlapsToLines } from './utils/overlapUtils.js';\nimport { EdgeGenerator } from './EdgeGenerator.js';\nimport { LineObjectsBVH } from './utils/LineObjectsBVH.js';\nimport { bvhcastEdges } from './utils/bvhcastEdges.js';\nimport { getAllMeshes } from './utils/getAllMeshes.js';\n\n// these shared variables are not used across \"yield\" boundaries in the\n// generator so there's no risk of overwriting another tasks data\nconst UP_VECTOR = /* @__PURE__ */ new Vector3( 0, 1, 0 );\n\nconst _raycaster = /* @__PURE__ */ new Raycaster();\nconst _line = /* @__PURE__ */ new Line3();\nconst _line0 = /* @__PURE__ */ new Line3();\nconst _line1 = /* @__PURE__ */ new Line3();\nconst _box = /* @__PURE__ */ new Box3();\nconst _point0 = /* @__PURE__ */ new Vector3();\nconst _point1 = /* @__PURE__ */ new Vector3();\nconst _dir0 = /* @__PURE__ */ new Vector3();\nconst _dir1 = /* @__PURE__ */ new Vector3();\n\nfunction toLineGeometry( edges ) {\n\n\tconst edgeArray = new Float32Array( edges.length * 6 );\n\tlet c = 0;\n\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\n\n\t\tconst line = edges[ i ];\n\t\tedgeArray[ c ++ ] = line[ 0 ];\n\t\tedgeArray[ c ++ ] = 0;\n\t\tedgeArray[ c ++ ] = line[ 2 ];\n\t\tedgeArray[ c ++ ] = line[ 3 ];\n\t\tedgeArray[ c ++ ] = 0;\n\t\tedgeArray[ c ++ ] = line[ 5 ];\n\n\t}\n\n\tconst edgeGeom = new BufferGeometry();\n\tconst edgeBuffer = new BufferAttribute( edgeArray, 3, true );\n\tedgeGeom.setAttribute( 'position', edgeBuffer );\n\treturn edgeGeom;\n\n}\n\nclass ProjectedEdgeCollector {\n\n\tconstructor( scene ) {\n\n\t\tthis.meshes = getAllMeshes( scene );\n\t\tthis.bvhs = new Map();\n\t\tthis.visibleEdges = [];\n\t\tthis.hiddenEdges = [];\n\t\tthis.iterationTime = 30;\n\t\tthis.lineIntersectionStrategy = false;\n\n\t}\n\n\treset() {\n\n\t\tthis.visibleEdges.length = 0;\n\t\tthis.hiddenEdges.length = 0;\n\n\t}\n\n\tgetVisibleLineGeometry() {\n\n\t\treturn toLineGeometry( this.visibleEdges );\n\n\t}\n\n\tgetHiddenLineGeometry() {\n\n\t\treturn toLineGeometry( this.hiddenEdges );\n\n\n\t}\n\n\taddEdges( ...args ) {\n\n\t\tconst currIterationTime = this.iterationTime;\n\t\tthis.iterationTime = Infinity;\n\n\t\tconst result = this.addEdgesGenerator( ...args ).next().value;\n\t\tthis.iterationTime = currIterationTime;\n\n\t\treturn result;\n\n\t}\n\n\t// all edges are expected to be in world coordinates\n\t*addEdgesGenerator( edges, options = {} ) {\n\n\t\tconst { meshes, bvhs, visibleEdges, hiddenEdges, iterationTime } = this;\n\t\tlet time = performance.now();\n\t\tfor ( let i = 0; i < meshes.length; i ++ ) {\n\n\t\t\tif ( performance.now() - time > iterationTime ) {\n\n\t\t\t\tyield;\n\t\t\t\ttime = performance.now();\n\n\t\t\t}\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tif ( ! bvhs.has( geometry ) ) {\n\n\t\t\t\tconst bvh = geometry.boundsTree || new MeshBVH( geometry );\n\t\t\t\tbvhs.set( geometry, bvh );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// initialize hidden line object\n\t\tconst hiddenOverlapMap = {};\n\t\tfor ( let i = 0; i < edges.length; i ++ ) {\n\n\t\t\thiddenOverlapMap[ i ] = [];\n\n\t\t}\n\n\t\t// construct bvh\n\t\tconst edgesBvh = new LineObjectsBVH( edges, { maxLeafSize: 2, strategy: SAH } );\n\n\t\tif ( this.lineIntersectionStrategy ) {\n\n\t\t\t// TODO: use objects bvh for scene to accelerate raycasts\n\t\t\t// TODO: cache inverse matrices to help speed things up\n\n\t\t\tmeshes.forEach( c => {\n\n\t\t\t\tc.geometry.boundsTree = bvhs.get( c.geometry );\n\t\t\t\tc.raycast = acceleratedRaycast;\n\n\t\t\t} );\n\n\t\t\tconst results = {};\n\t\t\ttime = performance.now();\n\t\t\tfor ( let i0 = 0, l = edgesBvh.lines.length; i0 < l; i0 ++ ) {\n\n\t\t\t\tif ( performance.now() - time > iterationTime ) {\n\n\t\t\t\t\tyield;\n\t\t\t\t\ttime = performance.now();\n\n\t\t\t\t}\n\n\t\t\t\t// get the projected line\n\t\t\t\tconst e0 = edgesBvh.lines[ i0 ];\n\t\t\t\t_line0.copy( e0 );\n\t\t\t\t_line0.start.y = 0;\n\t\t\t\t_line0.end.y = 0;\n\n\t\t\t\t// get the line direction\n\t\t\t\t_line0.delta( _dir0 ).normalize();\n\n\t\t\t\t// get the line bounds\n\t\t\t\t_box.makeEmpty();\n\t\t\t\t_box.expandByPoint( e0.start );\n\t\t\t\t_box.expandByPoint( e0.end );\n\n\t\t\t\t// expand the size\n\t\t\t\t_box.max.y = 1e5;\n\t\t\t\t_box.min.y = - 1e5;\n\n\t\t\t\t// reset the splits and\n\t\t\t\tedgesBvh.shapecast( {\n\n\t\t\t\t\tintersectsBounds( b ) {\n\n\t\t\t\t\t\treturn _box.intersectsBox( b );\n\n\t\t\t\t\t},\n\n\t\t\t\t\tintersectsRange( offset, count ) {\n\n\t\t\t\t\t\tfor ( let i1 = offset, l = offset + count; i1 < l; i1 ++ ) {\n\n\t\t\t\t\t\t\tif ( i1 <= i0 ) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( ! results[ i0 ] ) results[ i0 ] = [];\n\t\t\t\t\t\t\tif ( ! results[ i1 ] ) results[ i1 ] = [];\n\n\t\t\t\t\t\t\t// get the projected line\n\t\t\t\t\t\t\tconst e1 = edgesBvh.lines[ i1 ];\n\t\t\t\t\t\t\t_line1.copy( e1 );\n\t\t\t\t\t\t\t_line1.start.y = 0;\n\t\t\t\t\t\t\t_line1.end.y = 0;\n\n\t\t\t\t\t\t\t// get projected direction\n\t\t\t\t\t\t\t_line1.delta( _dir1 ).normalize();\n\n\t\t\t\t\t\t\t// early out if parallel\n\t\t\t\t\t\t\tif ( Math.abs( _dir0.dot( _dir1 ) ) > 1 - 1e-5 ) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// get the intersection point\n\t\t\t\t\t\t\tconst dist = _line0.distanceSqToLine3( _line1, _point0, _point1 );\n\t\t\t\t\t\t\tif ( dist < 1e-5 ) {\n\n\t\t\t\t\t\t\t\t// NOTE: only the second point from distanceSqToLine3 is valid due to a bug in r182 implementation\n\t\t\t\t\t\t\t\tresults[ i0 ].push( _line0.closestPointToPointParameter( _point1 ) );\n\t\t\t\t\t\t\t\tresults[ i1 ].push( _line1.closestPointToPointParameter( _point1 ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// save out all the lines\n\t\t\tfor ( let i = 0, l = edgesBvh.lines.length; i < l; i ++ ) {\n\n\t\t\t\tconst line = edgesBvh.lines[ i ];\n\t\t\t\tpushFromSplits( line, results[ i ] || [], meshes, bvhs, visibleEdges, objectsBVH );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttime = performance.now();\n\t\t\tfor ( let m = 0; m < meshes.length; m ++ ) {\n\n\t\t\t\tif ( performance.now() - time > iterationTime ) {\n\n\t\t\t\t\tif ( options.onProgress ) {\n\n\t\t\t\t\t\toptions.onProgress( m, meshes.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tyield;\n\t\t\t\t\ttime = performance.now();\n\n\t\t\t\t}\n\n\t\t\t\t// use bvhcast to compare all edges against all meshes\n\t\t\t\tconst mesh = meshes[ m ];\n\t\t\t\tbvhcastEdges( edgesBvh, bvhs.get( mesh.geometry ), mesh, hiddenOverlapMap );\n\n\t\t\t}\n\n\t\t\t// construct the projections\n\t\t\tfor ( let i = 0; i < edges.length; i ++ ) {\n\n\t\t\t\tif ( performance.now() - time > iterationTime ) {\n\n\t\t\t\t\tyield;\n\t\t\t\t\ttime = performance.now();\n\n\t\t\t\t}\n\n\t\t\t\t// convert the overlap points to proper lines\n\t\t\t\tconst line = edges[ i ];\n\t\t\t\tconst hiddenOverlaps = hiddenOverlapMap[ i ];\n\t\t\t\toverlapsToLines( line, hiddenOverlaps, false, visibleEdges );\n\t\t\t\toverlapsToLines( line, hiddenOverlaps, true, hiddenEdges );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport class ProjectionGenerator {\n\n\tconstructor() {\n\n\t\tthis.iterationTime = 30;\n\t\tthis.angleThreshold = 50;\n\t\tthis.includeIntersectionEdges = true;\n\n\t}\n\n\tgenerateAsync( geometry, options = {} ) {\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tconst { signal } = options;\n\t\t\tconst task = this.generate( geometry, options );\n\t\t\trun();\n\n\t\t\tfunction run() {\n\n\t\t\t\tif ( signal && signal.aborted ) {\n\n\t\t\t\t\treject( new Error( 'ProjectionGenerator: Process aborted via AbortSignal.' ) );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst result = task.next();\n\t\t\t\tif ( result.done ) {\n\n\t\t\t\t\tresolve( result.value );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trequestAnimationFrame( run );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} );\n\n\t}\n\n\t*generate( scene, options ) {\n\n\t\tconst { iterationTime, angleThreshold, includeIntersectionEdges } = this;\n\t\tconst { onProgress = () => {} } = options;\n\n\t\tif ( scene.isBufferGeometry ) {\n\n\t\t\tscene = new Mesh( scene );\n\n\t\t}\n\n\t\tconst edgeGenerator = new EdgeGenerator();\n\t\tedgeGenerator.iterationTime = iterationTime;\n\t\tedgeGenerator.thresholdAngle = angleThreshold;\n\t\tedgeGenerator.projectionDirection.copy( UP_VECTOR );\n\n\t\tonProgress( 'Extracting edges' );\n\t\tlet edges = [];\n\t\tyield* edgeGenerator.getEdgesGenerator( scene, edges, options );\n\t\tif ( includeIntersectionEdges ) {\n\n\t\t\tonProgress( 'Extracting self-intersecting edges' );\n\t\t\tyield* edgeGenerator.getIntersectionEdgesGenerator( scene, edges, options );\n\n\t\t}\n\n\t\t// filter out any degenerate projected edges\n\t\tonProgress( 'Filtering edges' );\n\t\tedges = edges.filter( e => ! isYProjectedLineDegenerate( e ) );\n\n\t\tyield;\n\n\t\tconst collector = new ProjectedEdgeCollector( scene );\n\t\tcollector.iterationTime = iterationTime;\n\n\t\tonProgress( 'Clipping edges' );\n\t\tyield* collector.addEdgesGenerator( edges, {\n\t\t\tonProgress: ! onProgress ? null : ( prog, tot ) => {\n\n\t\t\t\tonProgress( 'Clipping edges', prog / tot, collector );\n\n\t\t\t},\n\t\t} );\n\n\t\treturn collector;\n\n\t}\n\n}\n\nfunction pushFromSplits( line, splits, meshes, bvhs, target, objectsBVH ) {\n\n\tconst hits = [];\n\n\t// sort the splits\n\tsplits.push( 0, 1 );\n\tsplits.sort( ( a, b ) => a - b );\n\n\t// iterate over splits\n\t_raycaster.firstHitOnly = true;\n\tfor ( let i = 0; i < splits.length - 1; i ++ ) {\n\n\t\tconst s0 = splits[ i ];\n\t\tconst s1 = splits[ i + 1 ];\n\t\tif ( s0 === s1 ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// set up the raycaster to project check the middle of the line\n\t\tconst middle = ( s0 + s1 ) / 2;\n\t\tline.at( middle, _raycaster.ray.origin );\n\t\t_raycaster.ray.origin.y += 1e4;\n\t\t_raycaster.far = 1e4;\n\t\t_raycaster.ray.direction.set( 0, - 1, 0 );\n\n\t\t// perform the raycasting check\n\t\tlet visible = true;\n\t\tfor ( let m = 0, lm = meshes.length; m < lm; m ++ ) {\n\n\t\t\tconst mesh = meshes[ m ];\n\t\t\tconst bvh = bvhs.get( mesh.geometry );\n\t\t\thits.length = 0;\n\n\t\t\tbvh.raycastObject3D( mesh, _raycaster, hits );\n\t\t\tif ( hits.length > 0 ) {\n\n\t\t\t\tvisible = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if it's visible then save it\n\t\tif ( visible ) {\n\n\t\t\tline.at( s0, _line.start );\n\t\t\tline.at( s1, _line.end );\n\n\t\t\ttarget.push( new Float32Array( [\n\t\t\t\t_line.start.x, 0, _line.start.z,\n\t\t\t\t_line.end.x, 0, _line.end.z,\n\t\t\t] ) );\n\n\t\t}\n\n\t}\n\n}\n"],"names":["l","_line","UP_VECTOR","i","geometry","objectsBVH"],"mappings":"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","x_google_ignoreList":[0]}