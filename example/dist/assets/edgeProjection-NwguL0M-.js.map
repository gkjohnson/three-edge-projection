{"version":3,"file":"edgeProjection-NwguL0M-.js","sources":["../../../node_modules/three/examples/jsm/loaders/LDrawLoader.js","../../../node_modules/three/examples/jsm/materials/LDrawConditionalLineMaterial.js","../../edgeProjection.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMatrix4,\n\tMesh,\n\tMeshStandardMaterial,\n\tSRGBColorSpace,\n\tVector3,\n\tRay\n} from 'three';\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_TRY_PARTS = 0;\nconst FILE_LOCATION_TRY_P = 1;\nconst FILE_LOCATION_TRY_MODELS = 2;\nconst FILE_LOCATION_AS_IS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\n\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst COLOR_SPACE_LDRAW = SRGBColorSpace;\n\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\n\n\nclass ConditionalLineSegments extends LineSegments {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.isConditionalLine = true;\n\n\t}\n\n}\n\nfunction generateFaceNormals( faces ) {\n\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst face = faces[ i ];\n\t\tconst vertices = face.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\tconst v2 = vertices[ 2 ];\n\n\t\t_tempVec0.subVectors( v1, v0 );\n\t\t_tempVec1.subVectors( v2, v1 );\n\t\tface.faceNormal = new Vector3()\n\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t.normalize();\n\n\t}\n\n}\n\nconst _ray = new Ray();\nfunction smoothNormals( faces, lineSegments, checkSubSegments = false ) {\n\n\t// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n\t// it allows edges to be smoothed as expected (see minifig arms).\n\t// --\n\t// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n\t// point errors on vertices along quantization boundaries. Ie after matrix multiplication\n\t// vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n\t// get merged. This added epsilon attempts to push these error values to the same quantized\n\t// value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\n\t\treturn `${ x },${ y },${ z }`;\n\n\t}\n\n\tfunction hashEdge( v0, v1 ) {\n\n\t\treturn `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;\n\n\t}\n\n\t// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n\t// onto the original line.\n\tfunction toNormalizedRay( v0, v1, targetRay ) {\n\n\t\ttargetRay.direction.subVectors( v1, v0 ).normalize();\n\n\t\tconst scalar = v0.dot( targetRay.direction );\n\t\ttargetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );\n\n\t\treturn targetRay;\n\n\t}\n\n\tfunction hashRay( ray ) {\n\n\t\treturn hashEdge( ray.origin, ray.direction );\n\n\t}\n\n\tconst hardEdges = new Set();\n\tconst hardEdgeRays = new Map();\n\tconst halfEdgeList = {};\n\tconst normals = [];\n\n\t// Save the list of hard edges by hash\n\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\tconst ls = lineSegments[ i ];\n\t\tconst vertices = ls.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\thardEdges.add( hashEdge( v0, v1 ) );\n\t\thardEdges.add( hashEdge( v1, v0 ) );\n\n\t\t// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n\t\t// and requires more memory.\n\t\tif ( checkSubSegments ) {\n\n\t\t\t// add both ray directions to the map\n\t\t\tconst ray = toNormalizedRay( v0, v1, new Ray() );\n\t\t\tconst rh1 = hashRay( ray );\n\t\t\tif ( ! hardEdgeRays.has( rh1 ) ) {\n\n\t\t\t\ttoNormalizedRay( v1, v0, ray );\n\t\t\t\tconst rh2 = hashRay( ray );\n\n\t\t\t\tconst info = {\n\t\t\t\t\tray,\n\t\t\t\t\tdistances: [],\n\t\t\t\t};\n\n\t\t\t\thardEdgeRays.set( rh1, info );\n\t\t\t\thardEdgeRays.set( rh2, info );\n\n\t\t\t}\n\n\t\t\t// store both segments ends in min, max order in the distances array to check if a face edge is a\n\t\t\t// subsegment later.\n\t\t\tconst info = hardEdgeRays.get( rh1 );\n\t\t\tlet d0 = info.ray.direction.dot( v0 );\n\t\t\tlet d1 = info.ray.direction.dot( v1 );\n\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t}\n\n\t\t\tinfo.distances.push( d0, d1 );\n\n\t\t}\n\n\t}\n\n\t// track the half edges associated with each triangle\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst tri = faces[ i ];\n\t\tconst vertices = tri.vertices;\n\t\tconst vertCount = vertices.length;\n\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\tconst index = i2;\n\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\tconst v0 = vertices[ index ];\n\t\t\tconst v1 = vertices[ next ];\n\t\t\tconst hash = hashEdge( v0, v1 );\n\n\t\t\t// don't add the triangle if the edge is supposed to be hard\n\t\t\tif ( hardEdges.has( hash ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\t\t\tif ( checkSubSegments ) {\n\n\t\t\t\ttoNormalizedRay( v0, v1, _ray );\n\n\t\t\t\tconst rayHash = hashRay( _ray );\n\t\t\t\tif ( hardEdgeRays.has( rayHash ) ) {\n\n\t\t\t\t\tconst info = hardEdgeRays.get( rayHash );\n\t\t\t\t\tconst { ray, distances } = info;\n\t\t\t\t\tlet d0 = ray.direction.dot( v0 );\n\t\t\t\t\tlet d1 = ray.direction.dot( v1 );\n\n\t\t\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor ( let i = 0, l = distances.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tif ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( found ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst info = {\n\t\t\t\tindex: index,\n\t\t\t\ttri: tri\n\t\t\t};\n\t\t\thalfEdgeList[ hash ] = info;\n\n\t\t}\n\n\t}\n\n\t// Iterate until we've tried to connect all faces to share normals\n\twhile ( true ) {\n\n\t\t// Stop if there are no more faces left\n\t\tlet halfEdge = null;\n\t\tfor ( const key in halfEdgeList ) {\n\n\t\t\thalfEdge = halfEdgeList[ key ];\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( halfEdge === null ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t// Exhaustively find all connected faces\n\t\tconst queue = [ halfEdge ];\n\t\twhile ( queue.length > 0 ) {\n\n\t\t\t// initialize all vertex normals in this triangle\n\t\t\tconst tri = queue.pop().tri;\n\t\t\tconst vertices = tri.vertices;\n\t\t\tconst vertNormals = tri.normals;\n\t\t\tconst faceNormal = tri.faceNormal;\n\n\t\t\t// Check if any edge is connected to another triangle edge\n\t\t\tconst vertCount = vertices.length;\n\t\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\t\tconst index = i2;\n\t\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\t\tconst v0 = vertices[ index ];\n\t\t\t\tconst v1 = vertices[ next ];\n\n\t\t\t\t// delete this triangle from the list so it won't be found again\n\t\t\t\tconst hash = hashEdge( v0, v1 );\n\t\t\t\tdelete halfEdgeList[ hash ];\n\n\t\t\t\tconst reverseHash = hashEdge( v1, v0 );\n\t\t\t\tconst otherInfo = halfEdgeList[ reverseHash ];\n\t\t\t\tif ( otherInfo ) {\n\n\t\t\t\t\tconst otherTri = otherInfo.tri;\n\t\t\t\t\tconst otherIndex = otherInfo.index;\n\t\t\t\t\tconst otherNormals = otherTri.normals;\n\t\t\t\t\tconst otherVertCount = otherNormals.length;\n\t\t\t\t\tconst otherFaceNormal = otherTri.faceNormal;\n\n\t\t\t\t\t// NOTE: If the angle between faces is > 67.5 degrees then assume it's\n\t\t\t\t\t// hard edge. There are some cases where the line segments do not line up exactly\n\t\t\t\t\t// with or span multiple triangle edges (see Lunar Vehicle wheels).\n\t\t\t\t\tif ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if this triangle has already been traversed then it won't be in\n\t\t\t\t\t// the halfEdgeList. If it has not then add it to the queue and delete\n\t\t\t\t\t// it so it won't be found again.\n\t\t\t\t\tif ( reverseHash in halfEdgeList ) {\n\n\t\t\t\t\t\tqueue.push( otherInfo );\n\t\t\t\t\t\tdelete halfEdgeList[ reverseHash ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the first normal\n\t\t\t\t\tconst otherNext = ( otherIndex + 1 ) % otherVertCount;\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ index ] && otherNormals[ otherNext ] &&\n\t\t\t\t\t\tvertNormals[ index ] !== otherNormals[ otherNext ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );\n\t\t\t\t\t\tvertNormals[ index ].norm = otherNormals[ otherNext ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];\n\t\t\t\t\tif ( sharedNormal1 === null ) {\n\n\t\t\t\t\t\t// it's possible to encounter an edge of a triangle that has already been traversed meaning\n\t\t\t\t\t\t// both edges already have different normals defined and shared. To work around this we create\n\t\t\t\t\t\t// a wrapper object so when those edges are merged the normals can be updated everywhere.\n\t\t\t\t\t\tsharedNormal1 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal1.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ index ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ index ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherNext ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherNext ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the second normal\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ next ] && otherNormals[ otherIndex ] &&\n\t\t\t\t\t\tvertNormals[ next ] !== otherNormals[ otherIndex ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );\n\t\t\t\t\t\tvertNormals[ next ].norm = otherNormals[ otherIndex ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];\n\t\t\t\t\tif ( sharedNormal2 === null ) {\n\n\t\t\t\t\t\tsharedNormal2 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal2.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ next ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ next ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherIndex ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// The normals of each face have been added up so now we average them by normalizing the vector.\n\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\tnormals[ i ].normalize();\n\n\t}\n\n}\n\nfunction isPartType( type ) {\n\n\treturn type === 'Part' || type === 'Unofficial_Part';\n\n}\n\nfunction isPrimitiveType( type ) {\n\n\treturn /primitive/i.test( type ) || type === 'Subpart';\n\n}\n\nclass LineParser {\n\n\tconstructor( line, lineNumber ) {\n\n\t\tthis.line = line;\n\t\tthis.lineLength = line.length;\n\t\tthis.currentCharIndex = 0;\n\t\tthis.currentChar = ' ';\n\t\tthis.lineNumber = lineNumber;\n\n\t}\n\n\tseekNonSpace() {\n\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t}\n\n\tgetToken() {\n\n\t\tconst pos0 = this.currentCharIndex ++;\n\n\t\t// Seek space\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar === ' ' || this.currentChar === '\\t' ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t\tconst pos1 = this.currentCharIndex;\n\n\t\tthis.seekNonSpace();\n\n\t\treturn this.line.substring( pos0, pos1 );\n\n\t}\n\n\tgetVector() {\n\n\t\treturn new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );\n\n\t}\n\n\tgetRemainingString() {\n\n\t\treturn this.line.substring( this.currentCharIndex, this.lineLength );\n\n\t}\n\n\tisAtTheEnd() {\n\n\t\treturn this.currentCharIndex >= this.lineLength;\n\n\t}\n\n\tsetToEnd() {\n\n\t\tthis.currentCharIndex = this.lineLength;\n\n\t}\n\n\tgetLineNumberString() {\n\n\t\treturn this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n\n\t}\n\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis._cache = {};\n\n\t}\n\n\tcloneResult( original ) {\n\n\t\tconst result = {};\n\n\t\t// vertices are transformed and normals computed before being converted to geometry\n\t\t// so these pieces must be cloned.\n\t\tresult.faces = original.faces.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tnormals: face.normals.map( () => null ),\n\t\t\t\tfaceNormal: null\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.conditionalSegments = original.conditionalSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tcontrolPoints: face.controlPoints.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.lineSegments = original.lineSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\t// none if this is subsequently modified\n\t\tresult.type = original.type;\n\t\tresult.category = original.category;\n\t\tresult.keywords = original.keywords;\n\t\tresult.author = original.author;\n\t\tresult.subobjects = original.subobjects;\n\t\tresult.fileName = original.fileName;\n\t\tresult.totalFaces = original.totalFaces;\n\t\tresult.startingBuildingStep = original.startingBuildingStep;\n\t\tresult.materials = original.materials;\n\t\tresult.group = null;\n\t\treturn result;\n\n\t}\n\n\tasync fetchData( fileName ) {\n\n\t\tlet triedLowerCase = false;\n\t\tlet locationState = FILE_LOCATION_TRY_PARTS;\n\t\twhile ( locationState !== FILE_LOCATION_NOT_FOUND ) {\n\n\t\t\tlet subobjectURL = fileName;\n\t\t\tswitch ( locationState ) {\n\n\t\t\t\tcase FILE_LOCATION_AS_IS:\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_PARTS:\n\t\t\t\t\tsubobjectURL = 'parts/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_P:\n\t\t\t\t\tsubobjectURL = 'p/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_MODELS:\n\t\t\t\t\tsubobjectURL = 'models/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_RELATIVE:\n\t\t\t\t\tsubobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_ABSOLUTE:\n\n\t\t\t\t\tif ( triedLowerCase ) {\n\n\t\t\t\t\t\t// Try absolute path\n\t\t\t\t\t\tlocationState = FILE_LOCATION_NOT_FOUND;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Next attempt is lower case\n\t\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\t\tsubobjectURL = fileName;\n\t\t\t\t\t\ttriedLowerCase = true;\n\t\t\t\t\t\tlocationState = FILE_LOCATION_TRY_PARTS;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst loader = this.loader;\n\t\t\tconst fileLoader = new FileLoader( loader.manager );\n\t\t\tfileLoader.setPath( loader.partsLibraryPath );\n\t\t\tfileLoader.setRequestHeader( loader.requestHeader );\n\t\t\tfileLoader.setWithCredentials( loader.withCredentials );\n\n\t\t\ttry {\n\n\t\t\t\tconst text = await fileLoader.loadAsync( subobjectURL );\n\t\t\t\treturn text;\n\n\t\t\t} catch ( _ ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' );\n\n\t}\n\n\tparse( text, fileName = null ) {\n\n\t\tconst loader = this.loader;\n\n\t\t// final results\n\t\tconst faces = [];\n\t\tconst lineSegments = [];\n\t\tconst conditionalSegments = [];\n\t\tconst subobjects = [];\n\t\tconst materials = {};\n\n\t\tconst getLocalMaterial = colorCode => {\n\n\t\t\treturn materials[ colorCode ] || null;\n\n\t\t};\n\n\t\tlet type = 'Model';\n\t\tlet category = null;\n\t\tlet keywords = null;\n\t\tlet author = null;\n\t\tlet totalFaces = 0;\n\n\t\t// split into lines\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tconst numLines = lines.length;\n\n\t\tlet parsingEmbeddedFiles = false;\n\t\tlet currentEmbeddedFileName = null;\n\t\tlet currentEmbeddedText = null;\n\n\t\tlet bfcCertified = false;\n\t\tlet bfcCCW = true;\n\t\tlet bfcInverted = false;\n\t\tlet bfcCull = true;\n\n\t\tlet startingBuildingStep = false;\n\n\t\t// Parse all line commands\n\t\tfor ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {\n\n\t\t\tconst line = lines[ lineIndex ];\n\n\t\t\tif ( line.length === 0 ) continue;\n\n\t\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\t\tif ( line.startsWith( '0 FILE ' ) ) {\n\n\t\t\t\t\t// Save previous embedded file in the cache\n\t\t\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t\t\t\t// New embedded text file\n\t\t\t\t\tcurrentEmbeddedFileName = line.substring( 7 );\n\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentEmbeddedText += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst lp = new LineParser( line, lineIndex + 1 );\n\t\t\tlp.seekNonSpace();\n\n\t\t\tif ( lp.isAtTheEnd() ) {\n\n\t\t\t\t// Empty line\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Parse the line type\n\t\t\tconst lineType = lp.getToken();\n\n\t\t\tlet material;\n\t\t\tlet colorCode;\n\t\t\tlet segment;\n\t\t\tlet ccw;\n\t\t\tlet doubleSided;\n\t\t\tlet v0, v1, v2, v3, c0, c1;\n\n\t\t\tswitch ( lineType ) {\n\n\t\t\t\t// Line type 0: Comment or META\n\t\t\t\tcase '0':\n\n\t\t\t\t\t// Parse meta directive\n\t\t\t\t\tconst meta = lp.getToken();\n\n\t\t\t\t\tif ( meta ) {\n\n\t\t\t\t\t\tswitch ( meta ) {\n\n\t\t\t\t\t\t\tcase '!LDRAW_ORG':\n\n\t\t\t\t\t\t\t\ttype = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!COLOUR':\n\n\t\t\t\t\t\t\t\tmaterial = loader.parseColorMetaDirective( lp );\n\t\t\t\t\t\t\t\tif ( material ) {\n\n\t\t\t\t\t\t\t\t\tmaterials[ material.userData.code ] = material;\n\n\t\t\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!CATEGORY':\n\n\t\t\t\t\t\t\t\tcategory = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!KEYWORDS':\n\n\t\t\t\t\t\t\t\tconst newKeywords = lp.getRemainingString().split( ',' );\n\t\t\t\t\t\t\t\tif ( newKeywords.length > 0 ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! keywords ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords = [];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnewKeywords.forEach( function ( keyword ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords.push( keyword.trim() );\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'FILE':\n\n\t\t\t\t\t\t\t\tif ( lineIndex > 0 ) {\n\n\t\t\t\t\t\t\t\t\t// Start embedded text files parsing\n\t\t\t\t\t\t\t\t\tparsingEmbeddedFiles = true;\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedFileName = lp.getRemainingString();\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t\t\t\t\t\tbfcCertified = false;\n\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'BFC':\n\n\t\t\t\t\t\t\t\t// Changes to the backface culling state\n\t\t\t\t\t\t\t\twhile ( ! lp.isAtTheEnd() ) {\n\n\t\t\t\t\t\t\t\t\tconst token = lp.getToken();\n\n\t\t\t\t\t\t\t\t\tswitch ( token ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'CERTIFY':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCERTIFY':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCertified = token === 'CERTIFY';\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CW':\n\t\t\t\t\t\t\t\t\t\tcase 'CCW':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = token === 'CCW';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'INVERTNEXT':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcInverted = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CLIP':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCLIP':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCull = token === 'CLIP';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' );\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'STEP':\n\n\t\t\t\t\t\t\t\tstartingBuildingStep = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'Author:':\n\n\t\t\t\t\t\t\t\tauthor = lp.getToken();\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Other meta directives are not implemented\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 1: Sub-object file\n\t\t\t\tcase '1':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\n\t\t\t\t\tconst posX = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posY = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posZ = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m0 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m1 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m2 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m3 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m4 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m5 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m6 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m7 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m8 = parseFloat( lp.getToken() );\n\n\t\t\t\t\tconst matrix = new Matrix4().set(\n\t\t\t\t\t\tm0, m1, m2, posX,\n\t\t\t\t\t\tm3, m4, m5, posY,\n\t\t\t\t\t\tm6, m7, m8, posZ,\n\t\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t\t);\n\n\t\t\t\t\tlet fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( loader.fileMap[ fileName ] ) {\n\n\t\t\t\t\t\t// Found the subobject path in the preloaded file path map\n\t\t\t\t\t\tfileName = loader.fileMap[ fileName ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Standardized subfolders\n\t\t\t\t\t\tif ( fileName.startsWith( 's/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'parts/' + fileName;\n\n\t\t\t\t\t\t} else if ( fileName.startsWith( '48/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'p/' + fileName;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsubobjects.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tmatrix: matrix,\n\t\t\t\t\t\tfileName: fileName,\n\t\t\t\t\t\tinverted: bfcInverted,\n\t\t\t\t\t\tstartingBuildingStep: startingBuildingStep\n\t\t\t\t\t} );\n\n\t\t\t\t\tstartingBuildingStep = false;\n\t\t\t\t\tbfcInverted = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 2: Line segment\n\t\t\t\tcase '2':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tlineSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 5: Conditional Line segment\n\t\t\t\tcase '5':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\tc0 = lp.getVector();\n\t\t\t\t\tc1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t\tcontrolPoints: [ c0, c1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tconditionalSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 3: Triangle\n\t\t\t\tcase '3':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2 ],\n\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 4: Quadrilateral\n\t\t\t\tcase '4':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv3 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv3 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// specifically place the triangle diagonal in the v0 and v1 slots so we can\n\t\t\t\t\t// account for the doubling of vertices later when smoothing normals.\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2, v3 ],\n\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v3, v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t}\n\n\t\treturn {\n\t\t\tfaces,\n\t\t\tconditionalSegments,\n\t\t\tlineSegments,\n\t\t\ttype,\n\t\t\tcategory,\n\t\t\tkeywords,\n\t\t\tauthor,\n\t\t\tsubobjects,\n\t\t\ttotalFaces,\n\t\t\tstartingBuildingStep,\n\t\t\tmaterials,\n\t\t\tfileName,\n\t\t\tgroup: null\n\t\t};\n\n\t}\n\n\t// returns an (optionally cloned) instance of the data\n\tgetData( fileName, clone = true ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tconst result = this._cache[ key ];\n\t\tif ( result === null || result instanceof Promise ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( clone ) {\n\n\t\t\treturn this.cloneResult( result );\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n\t// the data is ready to use and can be retrieved synchronously with \"getData\".\n\tasync ensureDataLoaded( fileName ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( ! ( key in this._cache ) ) {\n\n\t\t\t// replace the promise with a copy of the parsed data for immediate processing\n\t\t\tthis._cache[ key ] = this.fetchData( fileName ).then( text => {\n\n\t\t\t\tconst info = this.parse( text, fileName );\n\t\t\t\tthis._cache[ key ] = info;\n\t\t\t\treturn info;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tawait this._cache[ key ];\n\n\t}\n\n\t// sets the data in the cache from parsed data\n\tsetData( fileName, text ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tthis._cache[ key ] = this.parse( text, fileName );\n\n\t}\n\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {\n\n\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\tif ( isPassthrough ) {\n\n\t\tcolorCode = parentColorCode;\n\n\t}\n\n\treturn materialHierarchy[ colorCode ] || null;\n\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis.parseCache = new LDrawParsedCache( loader );\n\t\tthis._cache = {};\n\n\t}\n\n\t// Convert the given file information into a mesh by processing subobjects.\n\tasync processIntoMesh( info ) {\n\n\t\tconst loader = this.loader;\n\t\tconst parseCache = this.parseCache;\n\t\tconst faceMaterials = new Set();\n\n\t\t// Processes the part subobject information to load child parts and merge geometry onto part\n\t\t// piece object.\n\t\tconst processInfoSubobjects = async ( info, subobject = null ) => {\n\n\t\t\tconst subobjects = info.subobjects;\n\t\t\tconst promises = [];\n\n\t\t\t// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n\t\t\t// group which lets instruction steps apply correctly.\n\t\t\tfor ( let i = 0, l = subobjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = subobjects[ i ];\n\t\t\t\tconst promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {\n\n\t\t\t\t\tconst subobjectInfo = parseCache.getData( subobject.fileName, false );\n\t\t\t\t\tif ( ! isPrimitiveType( subobjectInfo.type ) ) {\n\n\t\t\t\t\t\treturn this.loadModel( subobject.fileName ).catch( error => {\n\n\t\t\t\t\t\t\tconsole.warn( error );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );\n\n\t\t\t\t} );\n\n\t\t\t\tpromises.push( promise );\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.userData.category = info.category;\n\t\t\tgroup.userData.keywords = info.keywords;\n\t\t\tgroup.userData.author = info.author;\n\t\t\tgroup.userData.type = info.type;\n\t\t\tgroup.userData.fileName = info.fileName;\n\t\t\tinfo.group = group;\n\n\t\t\tconst subobjectInfos = await Promise.all( promises );\n\t\t\tfor ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = info.subobjects[ i ];\n\t\t\t\tconst subobjectInfo = subobjectInfos[ i ];\n\n\t\t\t\tif ( subobjectInfo === null ) {\n\n\t\t\t\t\t// the subobject failed to load\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// if the subobject was loaded as a separate group then apply the parent scopes materials\n\t\t\t\tif ( subobjectInfo.isGroup ) {\n\n\t\t\t\t\tconst subobjectGroup = subobjectInfo;\n\t\t\t\t\tsubobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );\n\t\t\t\t\tsubobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;\n\t\t\t\t\tsubobjectGroup.name = subobject.fileName;\n\n\t\t\t\t\tloader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );\n\t\t\t\t\tsubobjectGroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t\t\tgroup.add( subobjectGroup );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// add the subobject group if it has children in case it has both children and primitives\n\t\t\t\tif ( subobjectInfo.group.children.length ) {\n\n\t\t\t\t\tgroup.add( subobjectInfo.group );\n\n\t\t\t\t}\n\n\t\t\t\t// transform the primitives into the local space of the parent piece and append them to\n\t\t\t\t// to the parent primitives list.\n\t\t\t\tconst parentLineSegments = info.lineSegments;\n\t\t\t\tconst parentConditionalSegments = info.conditionalSegments;\n\t\t\t\tconst parentFaces = info.faces;\n\n\t\t\t\tconst lineSegments = subobjectInfo.lineSegments;\n\t\t\t\tconst conditionalSegments = subobjectInfo.conditionalSegments;\n\n\t\t\t\tconst faces = subobjectInfo.faces;\n\t\t\t\tconst matrix = subobject.matrix;\n\t\t\t\tconst inverted = subobject.inverted;\n\t\t\t\tconst matrixScaleInverted = matrix.determinant() < 0;\n\t\t\t\tconst colorCode = subobject.colorCode;\n\n\t\t\t\tconst lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\t\t\t\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst ls = lineSegments[ i ];\n\t\t\t\t\tconst vertices = ls.vertices;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n\t\t\t\t\tls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );\n\n\t\t\t\t\tparentLineSegments.push( ls );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst os = conditionalSegments[ i ];\n\t\t\t\t\tconst vertices = os.vertices;\n\t\t\t\t\tconst controlPoints = os.controlPoints;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tos.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n\t\t\t\t\tos.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );\n\n\t\t\t\t\tparentConditionalSegments.push( os );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst tri = faces[ i ];\n\t\t\t\t\tconst vertices = tri.vertices;\n\t\t\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertices[ i ].applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n\t\t\t\t\ttri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );\n\t\t\t\t\tfaceMaterials.add( tri.colorCode );\n\n\t\t\t\t\t// If the scale of the object is negated then the triangle winding order\n\t\t\t\t\t// needs to be flipped.\n\t\t\t\t\tif ( matrixScaleInverted !== inverted ) {\n\n\t\t\t\t\t\tvertices.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparentFaces.push( tri );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.totalFaces += subobjectInfo.totalFaces;\n\n\t\t\t}\n\n\t\t\t// Apply the parent subobjects pass through material code to this object. This is done several times due\n\t\t\t// to material scoping.\n\t\t\tif ( subobject ) {\n\n\t\t\t\tloader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );\n\t\t\t\tgroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t};\n\n\t\t// Track material use to see if we need to use the normal smooth slow path for hard edges.\n\t\tfor ( let i = 0, l = info.faces; i < l; i ++ ) {\n\n\t\t\tfaceMaterials.add( info.faces[ i ].colorCode );\n\n\t\t}\n\n\t\tawait processInfoSubobjects( info );\n\n\t\tif ( loader.smoothNormals ) {\n\n\t\t\tconst checkSubSegments = faceMaterials.size > 1;\n\t\t\tgenerateFaceNormals( info.faces );\n\t\t\tsmoothNormals( info.faces, info.lineSegments, checkSubSegments );\n\n\t\t}\n\n\t\t// Add the primitive objects and metadata.\n\t\tconst group = info.group;\n\t\tif ( info.faces.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.faces, 3, false, info.totalFaces ) );\n\n\t\t}\n\n\t\tif ( info.lineSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.lineSegments, 2 ) );\n\n\t\t}\n\n\t\tif ( info.conditionalSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.conditionalSegments, 2, true ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t}\n\n\thasCachedModel( fileName ) {\n\n\t\treturn fileName !== null && fileName.toLowerCase() in this._cache;\n\n\t}\n\n\tasync getCachedModel( fileName ) {\n\n\t\tif ( fileName !== null && this.hasCachedModel( fileName ) ) {\n\n\t\t\tconst key = fileName.toLowerCase();\n\t\t\tconst group = await this._cache[ key ];\n\t\t\treturn group.clone();\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// Loads and parses the model with the given file name. Returns a cached copy if available.\n\tasync loadModel( fileName ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t// Return cached model if available.\n\t\t\treturn this.getCachedModel( fileName );\n\n\t\t} else {\n\n\t\t\t// Otherwise parse a new model.\n\t\t\t// Ensure the file data is loaded and pre parsed.\n\t\t\tawait parseCache.ensureDataLoaded( fileName );\n\n\t\t\tconst info = parseCache.getData( fileName );\n\t\t\tconst promise = this.processIntoMesh( info );\n\n\t\t\t// Now that the file has loaded it's possible that another part parse has been waiting in parallel\n\t\t\t// so check the cache again to see if it's been added since the last async operation so we don't\n\t\t\t// do unnecessary work.\n\t\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t\treturn this.getCachedModel( fileName );\n\n\t\t\t}\n\n\t\t\t// Cache object if it's a part so it can be reused later.\n\t\t\tif ( isPartType( info.type ) ) {\n\n\t\t\t\tthis._cache[ key ] = promise;\n\n\t\t\t}\n\n\t\t\t// return a copy\n\t\t\tconst group = await promise;\n\t\t\treturn group.clone();\n\n\t\t}\n\n\t}\n\n\t// parses the given model text into a renderable object. Returns cached copy if available.\n\tasync parseModel( text ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst info = parseCache.parse( text );\n\t\tif ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {\n\n\t\t\treturn this.getCachedModel( info.fileName );\n\n\t\t}\n\n\t\treturn this.processIntoMesh( info );\n\n\t}\n\n}\n\nfunction sortByMaterial( a, b ) {\n\n\tif ( a.colorCode === b.colorCode ) {\n\n\t\treturn 0;\n\n\t}\n\n\tif ( a.colorCode < b.colorCode ) {\n\n\t\treturn - 1;\n\n\t}\n\n\treturn 1;\n\n}\n\nfunction createObject( loader, elements, elementSize, isConditionalSegments = false, totalElements = null ) {\n\n\t// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n\t// With per face / segment material, implemented with mesh groups and materials array\n\n\t// Sort the faces or line segments by color code to make later the mesh groups\n\telements.sort( sortByMaterial );\n\n\tif ( totalElements === null ) {\n\n\t\ttotalElements = elements.length;\n\n\t}\n\n\tconst positions = new Float32Array( elementSize * totalElements * 3 );\n\tconst normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;\n\tconst materials = [];\n\n\tconst quadArray = new Array( 6 );\n\tconst bufferGeometry = new BufferGeometry();\n\tlet prevMaterial = null;\n\tlet index0 = 0;\n\tlet numGroupVerts = 0;\n\tlet offset = 0;\n\n\tfor ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {\n\n\t\tconst elem = elements[ iElem ];\n\t\tlet vertices = elem.vertices;\n\t\tif ( vertices.length === 4 ) {\n\n\t\t\tquadArray[ 0 ] = vertices[ 0 ];\n\t\t\tquadArray[ 1 ] = vertices[ 1 ];\n\t\t\tquadArray[ 2 ] = vertices[ 2 ];\n\t\t\tquadArray[ 3 ] = vertices[ 0 ];\n\t\t\tquadArray[ 4 ] = vertices[ 2 ];\n\t\t\tquadArray[ 5 ] = vertices[ 3 ];\n\t\t\tvertices = quadArray;\n\n\t\t}\n\n\t\tfor ( let j = 0, l = vertices.length; j < l; j ++ ) {\n\n\t\t\tconst v = vertices[ j ];\n\t\t\tconst index = offset + j * 3;\n\t\t\tpositions[ index + 0 ] = v.x;\n\t\t\tpositions[ index + 1 ] = v.y;\n\t\t\tpositions[ index + 2 ] = v.z;\n\n\t\t}\n\n\t\t// create the normals array if this is a set of faces\n\t\tif ( elementSize === 3 ) {\n\n\t\t\tif ( ! elem.faceNormal ) {\n\n\t\t\t\tconst v0 = vertices[ 0 ];\n\t\t\t\tconst v1 = vertices[ 1 ];\n\t\t\t\tconst v2 = vertices[ 2 ];\n\t\t\t\t_tempVec0.subVectors( v1, v0 );\n\t\t\t\t_tempVec1.subVectors( v2, v1 );\n\t\t\t\telem.faceNormal = new Vector3()\n\t\t\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t\t\t.normalize();\n\n\t\t\t}\n\n\t\t\tlet elemNormals = elem.normals;\n\t\t\tif ( elemNormals.length === 4 ) {\n\n\t\t\t\tquadArray[ 0 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 1 ] = elemNormals[ 1 ];\n\t\t\t\tquadArray[ 2 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 3 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 4 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 5 ] = elemNormals[ 3 ];\n\t\t\t\telemNormals = quadArray;\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, l = elemNormals.length; j < l; j ++ ) {\n\n\t\t\t\t// use face normal if a vertex normal is not provided\n\t\t\t\tlet n = elem.faceNormal;\n\t\t\t\tif ( elemNormals[ j ] ) {\n\n\t\t\t\t\tn = elemNormals[ j ].norm;\n\n\t\t\t\t}\n\n\t\t\t\tconst index = offset + j * 3;\n\t\t\t\tnormals[ index + 0 ] = n.x;\n\t\t\t\tnormals[ index + 1 ] = n.y;\n\t\t\t\tnormals[ index + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( prevMaterial !== elem.colorCode ) {\n\n\t\t\tif ( prevMaterial !== null ) {\n\n\t\t\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst material = elem.material;\n\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tif ( elementSize === 3 ) {\n\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t} else if ( elementSize === 2 ) {\n\n\t\t\t\t\tif ( isConditionalSegments ) {\n\n\t\t\t\t\t\tconst edgeMaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\t\t\tmaterials.push( loader.conditionalEdgeMaterialCache.get( edgeMaterial ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( loader.edgeMaterialCache.get( material ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// If a material has not been made available yet then keep the color code string in the material array\n\t\t\t\t// to save the spot for the material once a parent scopes materials are being applied to the object.\n\t\t\t\tmaterials.push( elem.colorCode );\n\n\t\t\t}\n\n\t\t\tprevMaterial = elem.colorCode;\n\t\t\tindex0 = offset / 3;\n\t\t\tnumGroupVerts = vertices.length;\n\n\t\t} else {\n\n\t\t\tnumGroupVerts += vertices.length;\n\n\t\t}\n\n\t\toffset += 3 * vertices.length;\n\n\t}\n\n\tif ( numGroupVerts > 0 ) {\n\n\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\n\n\t}\n\n\tbufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tif ( normals !== null ) {\n\n\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tlet object3d = null;\n\n\tif ( elementSize === 2 ) {\n\n\t\tif ( isConditionalSegments ) {\n\n\t\t\tobject3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t} else {\n\n\t\t\tobject3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t}\n\n\t} else if ( elementSize === 3 ) {\n\n\t\tobject3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t}\n\n\tif ( isConditionalSegments ) {\n\n\t\tobject3d.isConditionalLine = true;\n\n\t\tconst controlArray0 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst controlArray1 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst directionArray = new Float32Array( elements.length * 3 * 2 );\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\tconst os = elements[ i ];\n\t\t\tconst vertices = os.vertices;\n\t\t\tconst controlPoints = os.controlPoints;\n\t\t\tconst c0 = controlPoints[ 0 ];\n\t\t\tconst c1 = controlPoints[ 1 ];\n\t\t\tconst v0 = vertices[ 0 ];\n\t\t\tconst v1 = vertices[ 1 ];\n\t\t\tconst index = i * 3 * 2;\n\t\t\tcontrolArray0[ index + 0 ] = c0.x;\n\t\t\tcontrolArray0[ index + 1 ] = c0.y;\n\t\t\tcontrolArray0[ index + 2 ] = c0.z;\n\t\t\tcontrolArray0[ index + 3 ] = c0.x;\n\t\t\tcontrolArray0[ index + 4 ] = c0.y;\n\t\t\tcontrolArray0[ index + 5 ] = c0.z;\n\n\t\t\tcontrolArray1[ index + 0 ] = c1.x;\n\t\t\tcontrolArray1[ index + 1 ] = c1.y;\n\t\t\tcontrolArray1[ index + 2 ] = c1.z;\n\t\t\tcontrolArray1[ index + 3 ] = c1.x;\n\t\t\tcontrolArray1[ index + 4 ] = c1.y;\n\t\t\tcontrolArray1[ index + 5 ] = c1.z;\n\n\t\t\tdirectionArray[ index + 0 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 1 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 2 ] = v1.z - v0.z;\n\t\t\tdirectionArray[ index + 3 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 4 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 5 ] = v1.z - v0.z;\n\n\t\t}\n\n\t\tbufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t}\n\n\treturn object3d;\n\n}\n\n/**\n * A loader for the LDraw format.\n *\n * [LDraw](https://ldraw.org/} (LEGO Draw) is an [open format specification](https://ldraw.org/article/218.html)\n * for describing LEGO and other construction set 3D models.\n *\n * An LDraw asset (a text file usually with extension .ldr, .dat or .txt) can describe just a single construction\n * piece, or an entire model. In the case of a model the LDraw file can reference other LDraw files, which are\n * loaded from a library path set with `setPartsLibraryPath`. You usually download the LDraw official parts library,\n * extract to a folder and point setPartsLibraryPath to it.\n *\n * Library parts will be loaded by trial and error in subfolders 'parts', 'p' and 'models'. These file accesses\n * are not optimal for web environment, so a script tool has been made to pack an LDraw file with all its dependencies\n * into a single file, which loads much faster. See section 'Packing LDraw models'. The LDrawLoader example loads\n * several packed files. The official parts library is not included due to its large size.\n *\n * `LDrawLoader` supports the following extensions:\n * - !COLOUR: Color and surface finish declarations.\n * - BFC: Back Face Culling specification.\n * - !CATEGORY: Model/part category declarations.\n * - !KEYWORDS: Model/part keywords declarations.\n *\n * ```js\n * const loader = new LDrawLoader();\n * loader.setConditionalLineMaterial( LDrawConditionalLineMaterial ); // the type of line material depends on the used renderer\n * const object = await loader.loadAsync( 'models/ldraw/officialLibrary/models/car.ldr_Packed.mpd' );\n * scene.add( object );\n * ```\n *\n * @augments Loader\n * @three_import import { LDrawLoader } from 'three/addons/loaders/LDrawLoader.js';\n */\nclass LDrawLoader extends Loader {\n\n\t/**\n\t * Constructs a new LDraw loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Array of THREE.Material\n\t\tthis.materials = [];\n\t\tthis.materialLibrary = {};\n\t\tthis.edgeMaterialCache = new WeakMap();\n\t\tthis.conditionalEdgeMaterialCache = new WeakMap();\n\n\t\t// This also allows to handle the embedded text files (\"0 FILE\" lines)\n\t\tthis.partsCache = new LDrawPartsGeometryCache( this );\n\n\t\t// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\t\tthis.fileMap = {};\n\n\t\t// If this flag is set to true the vertex normals will be smoothed.\n\t\tthis.smoothNormals = true;\n\n\t\t// The path to load parts from the LDraw parts library from.\n\t\tthis.partsLibraryPath = '';\n\n\t\t// this material type must be injected via setConditionalLineMaterial()\n\t\tthis.ConditionalLineMaterial = null;\n\n\t\t// Material assigned to not available colors for meshes and edges\n\t\tthis.missingColorMaterial = new MeshStandardMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF, roughness: 0.3, metalness: 0 } );\n\t\tthis.missingEdgeColorMaterial = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF } );\n\t\tthis.missingConditionalEdgeColorMaterial = null;\n\t\tthis.edgeMaterialCache.set( this.missingColorMaterial, this.missingEdgeColorMaterial );\n\t\tthis.conditionalEdgeMaterialCache.set( this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial );\n\n\t}\n\n\t/**\n\t * This method must be called prior to `load()` unless the model to load does not reference\n\t * library parts (usually it will be a model with all its parts packed in a single file).\n\t *\n\t * @param {string} path - Path to library parts files to load referenced parts from.\n\t * This is different from Loader.setPath, which indicates the path to load the main asset from.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetPartsLibraryPath( path ) {\n\n\t\tthis.partsLibraryPath = path;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the conditional line material type which depends on the used renderer.\n\t * Use {@link LDrawConditionalLineMaterial} when using `WebGLRenderer` and\n\t * {@link LDrawConditionalLineNodeMaterial} when using `WebGPURenderer`.\n\t *\n\t * @param {(LDrawConditionalLineMaterial.constructor|LDrawConditionalLineNodeMaterial.constructor)} type - The conditional line material type.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetConditionalLineMaterial( type ) {\n\n\t\tthis.ConditionalLineMaterial = type;\n\t\tthis.missingConditionalEdgeColorMaterial = new this.ConditionalLineMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, fog: true, color: 0xFF00FF } );\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * This async method preloads materials from a single LDraw file. In the official\n\t * parts library there is a special file which is loaded always the first (LDConfig.ldr)\n\t * and contains all the standard color codes. This method is intended to be used with\n\t * not packed files, for example in an editor where materials are preloaded and parts\n\t * are loaded on demand.\n\t *\n\t * @async\n\t * @param {string} url - Path of the LDraw materials asset.\n\t * @return {Promise} A Promise that resolves when the preload has finished.\n\t */\n\tasync preloadMaterials( url ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await fileLoader.loadAsync( url );\n\t\tconst colorLineRegex = /^0 !COLOUR/;\n\t\tconst lines = text.split( /[\\n\\r]/g );\n\t\tconst materials = [];\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tconst line = lines[ i ];\n\t\t\tif ( colorLineRegex.test( line ) ) {\n\n\t\t\t\tconst directive = line.replace( colorLineRegex, '' );\n\t\t\t\tconst material = this.parseColorMetaDirective( new LineParser( directive ) );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addMaterials( materials );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded LDraw asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\t\tfileLoader.load( url, text => {\n\n\t\t\t// Initializes the materials library with default materials\n\t\t\tthis.addDefaultMaterials();\n\n\t\t\tthis.partsCache\n\t\t\t\t.parseModel( text )\n\t\t\t\t.then( group => {\n\n\t\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\t\tgroup.userData.fileName = url;\n\t\t\t\t\tonLoad( group );\n\n\t\t\t\t} )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given LDraw data and returns the resulting group.\n\t *\n\t * @param {string} text - The raw VRML data as a string.\n\t * @param {function(Group)} onLoad - Executed when the loading/parsing process has been finished.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tparse( text, onLoad, onError ) {\n\n\t\tthis.partsCache\n\t\t\t.parseModel( text )\n\t\t\t.then( group => {\n\n\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\tgroup.userData.fileName = '';\n\t\t\t\tonLoad( group );\n\n\t\t\t} )\n\t\t\t.catch( onError );\n\n\t}\n\n\t/**\n\t * Sets the loader's material library. This method clears existing\n\t * material definitions.\n\t *\n\t * @param {Array<Material>} materials - The materials to set.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetMaterials( materials ) {\n\n\t\tthis.clearMaterials();\n\t\tthis.addMaterials( materials );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Clears the loader's material library.\n\t *\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tclearMaterials() {\n\n\t\tthis.materialLibrary = {};\n\t\tthis.materials = [];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a list of materials to the loader's material library.\n\t *\n\t * @param {Array<Material>} materials - The materials to add.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddMaterials( materials ) {\n\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tthis.addMaterial( materials[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Initializes the loader with default materials.\n\t *\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddDefaultMaterials() {\n\n\t\t// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets a map which maps referenced library filenames to new filenames.\n\t * If a fileMap is not specified (the default), library parts will be accessed by trial and\n\t * error in subfolders 'parts', 'p' and 'models'.\n\t *\n\t * @param {Object<string,string>} fileMap - The file map to set.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetFileMap( fileMap ) {\n\n\t\tthis.fileMap = fileMap;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a single material to the loader's material library.\n\t *\n\t * @param {Material} material - The material to add.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddMaterial( material ) {\n\n\t\t// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n\t\tconst matLib = this.materialLibrary;\n\t\tif ( ! matLib[ material.userData.code ] ) {\n\n\t\t\tthis.materials.push( material );\n\t\t\tmatLib[ material.userData.code ] = material;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a material for the given color code.\n\t *\n\t * @param {string} colorCode - The color code.\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMaterial( colorCode ) {\n\n\t\tif ( colorCode.startsWith( '0x2' ) ) {\n\n\t\t\t// Special 'direct' material value (RGB color)\n\t\t\tconst color = colorCode.substring( 3 );\n\n\t\t\treturn this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );\n\n\t\t}\n\n\t\treturn this.materialLibrary[ colorCode ] || null;\n\n\t}\n\n\t// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n\t// in the material array if they need to be filled in.\n\tapplyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {\n\n\t\t// find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n\t\tconst loader = this;\n\t\tconst parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n\t\tgroup.traverse( c => {\n\n\t\t\tif ( c.isMesh || c.isLineSegments ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = c.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( ! c.material[ i ].isMaterial ) {\n\n\t\t\t\t\t\t\tc.material[ i ] = getMaterial( c, c.material[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( ! c.material.isMaterial ) {\n\n\t\t\t\t\tc.material = getMaterial( c, c.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\n\t\t// Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n\t\t// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n\t\t// simply returned for the subsequent material application.\n\t\tfunction getMaterial( c, colorCode ) {\n\n\t\t\t// if our parent is a passthrough color code and we don't have the current material color available then\n\t\t\t// return early.\n\t\t\tif ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tconst forEdge = c.isLineSegments || c.isConditionalLine;\n\t\t\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\t\t\tif ( isPassthrough ) {\n\n\t\t\t\tcolorCode = parentColorCode;\n\n\t\t\t}\n\n\t\t\tlet material = null;\n\t\t\tif ( colorCode in materialHierarchy ) {\n\n\t\t\t\tmaterial = materialHierarchy[ colorCode ];\n\n\t\t\t} else if ( finalMaterialPass ) {\n\n\t\t\t\t// see if we can get the final material from the \"getMaterial\" function which will attempt to\n\t\t\t\t// parse the \"direct\" colors\n\t\t\t\tmaterial = loader.getMaterial( colorCode );\n\t\t\t\tif ( material === null ) {\n\n\t\t\t\t\t// otherwise throw a warning if this is final opportunity to set the material\n\t\t\t\t\tconsole.warn( `LDrawLoader: Material properties for code ${ colorCode } not available.` );\n\n\t\t\t\t\t// And return the 'missing color' material\n\t\t\t\t\tmaterial = loader.missingColorMaterial;\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\tmaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tmaterial = loader.conditionalEdgeMaterialCache.get( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the Material for the main LDraw color.\n\t *\n\t * For an already loaded LDraw asset, returns the Material associated with the main color code.\n\t * This method can be useful to modify the main material of a model or part that exposes it.\n\t *\n\t * The main color code is the standard way to color an LDraw part. It is '16' for triangles and\n\t * '24' for edges. Usually a complete model will not expose the main color (that is, no part\n\t * uses the code '16' at the top level, because they are assigned other specific colors) An LDraw\n\t *  part file on the other hand will expose the code '16' to be colored, and can have additional\n\t * fixed colors.\n\t *\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMainMaterial() {\n\n\t\treturn this.getMaterial( MAIN_COLOUR_CODE );\n\n\t}\n\n\t/**\n\t * Returns the material for the edges main LDraw color.\n\t *\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMainEdgeMaterial() {\n\n\t\tconst mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE );\n\t\treturn mat ? this.edgeMaterialCache.get( mat ) : null;\n\n\t}\n\n\tparseColorMetaDirective( lineParser ) {\n\n\t\t// Parses a color definition and returns a THREE.Material\n\n\t\tlet code = null;\n\n\t\t// Triangle and line colors\n\t\tlet fillColor = '#FF00FF';\n\t\tlet edgeColor = '#FF00FF';\n\n\t\t// Transparency\n\t\tlet alpha = 1;\n\t\tlet isTransparent = false;\n\t\t// Self-illumination:\n\t\tlet luminance = 0;\n\n\t\tlet finishType = FINISH_TYPE_DEFAULT;\n\n\t\tlet edgeMaterial = null;\n\n\t\tconst name = lineParser.getToken();\n\t\tif ( ! name ) {\n\n\t\t\tthrow new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' );\n\n\t\t}\n\n\t\t// Parse tag tokens and their parameters\n\t\tlet token = null;\n\t\twhile ( true ) {\n\n\t\t\ttoken = lineParser.getToken();\n\n\t\t\tif ( ! token ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( ! parseLuminance( token ) ) {\n\n\t\t\t\tswitch ( token.toUpperCase() ) {\n\n\t\t\t\t\tcase 'CODE':\n\n\t\t\t\t\t\tcode = lineParser.getToken();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'VALUE':\n\n\t\t\t\t\t\tfillColor = lineParser.getToken();\n\t\t\t\t\t\tif ( fillColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tfillColor = '#' + fillColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! fillColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EDGE':\n\n\t\t\t\t\t\tedgeColor = lineParser.getToken();\n\t\t\t\t\t\tif ( edgeColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tedgeColor = '#' + edgeColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! edgeColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\t// Try to see if edge color is a color code\n\t\t\t\t\t\t\tedgeMaterial = this.getMaterial( edgeColor );\n\t\t\t\t\t\t\tif ( ! edgeMaterial ) {\n\n\t\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the edge material for this triangle material\n\t\t\t\t\t\t\tedgeMaterial = this.edgeMaterialCache.get( edgeMaterial );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ALPHA':\n\n\t\t\t\t\t\talpha = parseInt( lineParser.getToken() );\n\n\t\t\t\t\t\tif ( isNaN( alpha ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\talpha = Math.max( 0, Math.min( 1, alpha / 255 ) );\n\n\t\t\t\t\t\tif ( alpha < 1 ) {\n\n\t\t\t\t\t\t\tisTransparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LUMINANCE':\n\n\t\t\t\t\t\tif ( ! parseLuminance( lineParser.getToken() ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid luminance value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CHROME':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_CHROME;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PEARLESCENT':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_PEARLESCENT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RUBBER':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_RUBBER;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATTE_METALLIC':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_MATTE_METALLIC;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'METAL':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_METAL;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATERIAL':\n\t\t\t\t\t\t// Not implemented\n\t\t\t\t\t\tlineParser.setToEnd();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet material = null;\n\n\t\tswitch ( finishType ) {\n\n\t\t\tcase FINISH_TYPE_DEFAULT:\n\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_PEARLESCENT:\n\n\t\t\t\t// Try to imitate pearlescency by making the surface glossy\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0.25 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_CHROME:\n\n\t\t\t\t// Mirror finish surface\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0, metalness: 1 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_RUBBER:\n\n\t\t\t\t// Rubber finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.9, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_MATTE_METALLIC:\n\n\t\t\t\t// Brushed metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.8, metalness: 0.4 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_METAL:\n\n\t\t\t\t// Average metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.2, metalness: 0.85 } );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Should not happen\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.color.setStyle( fillColor, COLOR_SPACE_LDRAW );\n\t\tmaterial.transparent = isTransparent;\n\t\tmaterial.opacity = alpha;\n\t\tmaterial.depthWrite = ! isTransparent;\n\n\t\tmaterial.polygonOffset = true;\n\t\tmaterial.polygonOffsetFactor = 1;\n\n\t\tif ( luminance !== 0 ) {\n\n\t\t\tmaterial.emissive.setStyle( fillColor, COLOR_SPACE_LDRAW ).multiplyScalar( luminance );\n\n\t\t}\n\n\t\tif ( ! edgeMaterial ) {\n\n\t\t\t// This is the material used for edges\n\t\t\tedgeMaterial = new LineBasicMaterial( {\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\topacity: alpha,\n\t\t\t\tdepthWrite: ! isTransparent\n\t\t\t} );\n\t\t\tedgeMaterial.color;\n\t\t\tedgeMaterial.userData.code = code;\n\t\t\tedgeMaterial.name = name + ' - Edge';\n\n\t\t\tif ( this.ConditionalLineMaterial === null ) {\n\n\t\t\t\tthrow new Error( 'THREE.LDrawLoader: ConditionalLineMaterial type must be specified via .setConditionalLineMaterial().' );\n\n\t\t\t}\n\n\t\t\t// This is the material used for conditional edges\n\t\t\tconst conditionalEdgeMaterial = new this.ConditionalLineMaterial( {\n\n\t\t\t\tfog: true,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\tdepthWrite: ! isTransparent,\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\topacity: alpha,\n\n\t\t\t} );\n\t\t\tconditionalEdgeMaterial.userData.code = code;\n\t\t\tconditionalEdgeMaterial.name = name + ' - Conditional Edge';\n\n\t\t\tthis.conditionalEdgeMaterialCache.set( edgeMaterial, conditionalEdgeMaterial );\n\n\t\t}\n\n\t\tmaterial.userData.code = code;\n\t\tmaterial.name = name;\n\n\t\tthis.edgeMaterialCache.set( material, edgeMaterial );\n\n\t\tthis.addMaterial( material );\n\n\t\treturn material;\n\n\t\tfunction parseLuminance( token ) {\n\n\t\t\t// Returns success\n\n\t\t\tlet lum;\n\n\t\t\tif ( token.startsWith( 'LUMINANCE' ) ) {\n\n\t\t\t\tlum = parseInt( token.substring( 9 ) );\n\n\t\t\t} else {\n\n\t\t\t\tlum = parseInt( token );\n\n\t\t\t}\n\n\t\t\tif ( isNaN( lum ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tluminance = Math.max( 0, Math.min( 1, lum / 255 ) );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\tcomputeBuildingSteps( model ) {\n\n\t\t// Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.\n\n\t\tlet stepNumber = 0;\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isGroup ) {\n\n\t\t\t\tif ( c.userData.startingBuildingStep ) {\n\n\t\t\t\t\tstepNumber ++;\n\n\t\t\t\t}\n\n\t\t\t\tc.userData.buildingStep = stepNumber;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tmodel.userData.numBuildingSteps = stepNumber + 1;\n\n\t}\n\n}\n\nexport { LDrawLoader };\n","import {\n\tColor,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n} from 'three';\n\n/**\n * A special line material for meshes loaded via {@link LDrawLoader}.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `LDrawConditionalLineNodeMaterial.js`.\n *\n * @augments ShaderMaterial\n * @three_import import { LDrawConditionalLineMaterial } from 'three/addons/materials/LDrawConditionalLineMaterial.js';\n */\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LDrawConditionalLineMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new conditional line material.\n\t *\n\t * @param {Object} [parameters] - An object with one or more properties\n\t * defining the material's appearance. Any property of the material\n\t * (including any property from inherited materials) can be passed\n\t * in here. Color values can be passed any type of value accepted\n\t * by {@link Color#set}.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.fog,\n\t\t\t\t{\n\t\t\t\t\tdiffuse: {\n\t\t\t\t\t\tvalue: new Color()\n\t\t\t\t\t},\n\t\t\t\t\topacity: {\n\t\t\t\t\t\tvalue: 1.0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t\tObject.defineProperties( this, {\n\n\t\t\t/**\n\t\t\t * The material's opacity.\n\t\t\t *\n\t\t\t * @name LDrawConditionalLineMaterial#opacity\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\topacity: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * The material's color.\n\t\t\t *\n\t\t\t * @name LDrawConditionalLineMaterial#color\n\t\t\t * @type {Color}\n\t\t\t * @default (1,1,1)\n\t\t\t */\n\t\t\tcolor: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLDrawConditionalLineMaterial = true;\n\n\t}\n\n}\n\nexport { LDrawConditionalLineMaterial };\n","import {\n\tBox3,\n\tWebGLRenderer,\n\tScene,\n\tDirectionalLight,\n\tAmbientLight,\n\tGroup,\n\tBufferGeometry,\n\tLineSegments,\n\tLineBasicMaterial,\n\tPerspectiveCamera,\n} from 'three';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { LDrawLoader } from 'three/examples/jsm/loaders/LDrawLoader.js';\nimport { LDrawConditionalLineMaterial } from 'three/examples/jsm/materials/LDrawConditionalLineMaterial.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { ProjectionGenerator, MeshVisibilityCuller } from '..';\nimport { MeshBVH, SAH } from 'three-mesh-bvh';\n\nconst params = {\n\tdisplayModel: true,\n\tdisplayDrawThroughProjection: false,\n\tincludeIntersectionEdges: true,\n\trotate: () => {\n\n\t\tgroup.quaternion.random();\n\t\tgroup.position.set( 0, 0, 0 );\n\t\tgroup.updateMatrixWorld( true );\n\n\t\tconst box = new Box3();\n\t\tbox.setFromObject( model, true );\n\t\tbox.getCenter( group.position ).multiplyScalar( - 1 );\n\t\tgroup.position.y = Math.max( 0, - box.min.y ) + 1;\n\t\tgroup.updateMatrixWorld( true );\n\n\t\tneedsRender = true;\n\n\t\ttask = updateEdges();\n\n\t},\n\tregenerate: () => {\n\n\t\ttask = updateEdges();\n\n\t},\n};\n\nconst ANGLE_THRESHOLD = 50;\nlet needsRender = false;\nlet renderer, camera, scene, gui, controls;\nlet model, projection, drawThroughProjection, group;\nlet outputContainer;\nlet task = null;\n\ninit();\n\nasync function init() {\n\n\toutputContainer = document.getElementById( 'output' );\n\n\tconst bgColor = 0xeeeeee;\n\n\t// renderer setup\n\trenderer = new WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( bgColor, 1 );\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene setup\n\tscene = new Scene();\n\n\t// lights\n\tconst light = new DirectionalLight( 0xffffff, 3.5 );\n\tlight.position.set( 1, 2, 3 );\n\tscene.add( light );\n\n\tconst ambientLight = new AmbientLight( 0xb0bec5, 0.5 );\n\tscene.add( ambientLight );\n\n\t// load model\n\tgroup = new Group();\n\tscene.add( group );\n\n\twindow.ROOT = group;\n\n\tif ( window.location.hash === '#lego' ) {\n\n\t\t// init loader\n\t\tconst loader = new LDrawLoader();\n\t\tloader.setConditionalLineMaterial( LDrawConditionalLineMaterial );\n\t\tawait loader.preloadMaterials( 'https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/colors/ldcfgalt.ldr' );\n\n\t\t// load model\n\t\tmodel = await loader\n\t\t\t.setPartsLibraryPath( 'https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/complete/ldraw/' )\n\t\t\t.loadAsync( 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/ldraw/officialLibrary/models/1621-1-LunarMPVVehicle.mpd_Packed.mpd' );\n\n\t\t// adjust model transforms\n\t\tmodel.scale.setScalar( 0.01 );\n\t\tmodel.rotation.x = Math.PI;\n\n\t\t// remove lines\n\t\tconst toRemove = [];\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isLine ) {\n\n\t\t\t\ttoRemove.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttoRemove.forEach( c => {\n\n\t\t\tc.removeFromParent();\n\n\t\t} );\n\n\t} else {\n\n\t\tconst gltf = await new GLTFLoader()\n\t\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t\t.loadAsync( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/nasa-m2020/Perseverance.glb' );\n\t\tmodel = gltf.scene;\n\n\t}\n\n\t// initialize BVHs\n\tmodel.traverse( c => {\n\n\t\tif ( c.geometry && ! c.geometry.boundsTree ) {\n\n\t\t\tconst elCount = c.geometry.index ? c.geometry.index.count : c.geometry.attributes.position.count;\n\t\t\tc.geometry.groups.forEach( group => {\n\n\t\t\t\tif ( group.count === Infinity ) {\n\n\t\t\t\t\tgroup.count = elCount - group.start;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tc.geometry.boundsTree = new MeshBVH( c.geometry, { maxLeafSize: 1, strategy: SAH } );\n\n\t\t}\n\n\t} );\n\n\t// center model\n\tconst box = new Box3();\n\tbox.setFromObject( model, true );\n\tbox.getCenter( group.position ).multiplyScalar( - 1 );\n\tgroup.position.y = Math.max( 0, - box.min.y ) + 1;\n\tgroup.add( model );\n\tgroup.updateMatrixWorld( true );\n\n\t// create projection display mesh\n\tprojection = new LineSegments( new BufferGeometry(), new LineBasicMaterial( { color: 0x030303, depthWrite: false } ) );\n\tdrawThroughProjection = new LineSegments( new BufferGeometry(), new LineBasicMaterial( { color: 0xcacaca, depthWrite: false } ) );\n\tdrawThroughProjection.renderOrder = - 1;\n\tscene.add( projection, drawThroughProjection );\n\n\t// camera setup\n\tcamera = new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.01, 1e3 );\n\tcamera.position.setScalar( 3.5 );//.multiplyScalar( 10 );\n\tcamera.updateProjectionMatrix();\n\n\tneedsRender = true;\n\n\t// controls\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\tcontrols.addEventListener( 'change', () => {\n\n\t\tneedsRender = true;\n\n\t} );\n\n\tgui = new GUI();\n\tgui.add( params, 'displayModel' ).onChange( () => needsRender = true );\n\tgui.add( params, 'displayDrawThroughProjection' ).onChange( () => needsRender = true );\n\tgui.add( params, 'includeIntersectionEdges' ).onChange( () => needsRender = true );\n\tgui.add( params, 'rotate' );\n\tgui.add( params, 'regenerate' ).onChange( () => needsRender = true );\n\n\trender();\n\n\ttask = updateEdges();\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t\tneedsRender = true;\n\n\t}, false );\n\n}\n\nfunction* updateEdges( runTime = 30 ) {\n\n\toutputContainer.innerText = 'Generating...';\n\n\t// dispose the geometry\n\tprojection.geometry.dispose();\n\tdrawThroughProjection.geometry.dispose();\n\n\t// initialize an empty geometry\n\tprojection.geometry = new BufferGeometry();\n\tdrawThroughProjection.geometry = new BufferGeometry();\n\n\tconst timeStart = window.performance.now();\n\tconst generator = new ProjectionGenerator();\n\tgenerator.iterationTime = runTime;\n\tgenerator.angleThreshold = ANGLE_THRESHOLD;\n\tgenerator.includeIntersectionEdges = params.includeIntersectionEdges;\n\n\tconst collection = yield* generator.generate( model, {\n\t\t// visibilityCuller: new MeshVisibilityCuller( renderer, { pixelsPerMeter: 0.01 } ),\n\t\tonProgress: ( msg, tot, edges ) => {\n\n\t\t\toutputContainer.innerText = msg;\n\t\t\tif ( tot ) outputContainer.innerText += ' ' + ( 100 * tot ).toFixed( 1 ) + '%';\n\n\t\t\tif ( edges ) {\n\n\t\t\t\tprojection.geometry.dispose();\n\t\t\t\tprojection.geometry = edges.getVisibleLineGeometry();\n\t\t\t\tneedsRender = true;\n\n\t\t\t}\n\n\t\t},\n\t} );\n\tdrawThroughProjection.geometry.dispose();\n\tdrawThroughProjection.geometry = collection.getHiddenLineGeometry();\n\n\tprojection.geometry.dispose();\n\tprojection.geometry = collection.getVisibleLineGeometry();\n\tconst geometry = projection.geometry;\n\tconst trimTime = window.performance.now() - timeStart;\n\n\tprojection.geometry.dispose();\n\tprojection.geometry = geometry;\n\toutputContainer.innerText = `Generation time: ${ trimTime.toFixed( 2 ) }ms`;\n\n\tneedsRender = true;\n\n}\n\n\nfunction render() {\n\n\trequestAnimationFrame( render );\n\n\tif ( task ) {\n\n\t\tconst res = task.next();\n\t\tif ( res.done ) {\n\n\t\t\ttask = null;\n\n\t\t}\n\n\t}\n\n\tmodel.visible = params.displayModel;\n\tdrawThroughProjection.visible = params.displayDrawThroughProjection;\n\n\tif ( needsRender ) {\n\n\t\trenderer.render( scene, camera );\n\t\tneedsRender = false;\n\n\t}\n\n}\n"],"names":["info","i","l","fileName","subobject","group","token","model","GUI"],"mappings":"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","x_google_ignoreList":[0,1]}